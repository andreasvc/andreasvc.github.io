<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.tree &mdash; Disco-DOP 0.5pre1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.5pre1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for discodop.tree</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Various Tree objects for representing syntax or morphological trees.&quot;&quot;&quot;</span>
<span class="c"># This is an adaptation of the original tree.py file from NLTK.</span>
<span class="c"># Removed: probabilistic &amp; multi-parented trees, binarization,</span>
<span class="c"># reading off CFG productions, &amp;c.</span>
<span class="c"># Original notice:</span>
<span class="c"># Natural Language Toolkit: Text Trees</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2010 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt;</span>
<span class="c">#         Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt; (tree transforms)</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> \
		<span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s">&#39;3&#39;</span><span class="p">:</span>
	<span class="nb">basestring</span> <span class="o">=</span> <span class="nb">str</span>  <span class="c"># pylint: disable=W0622,C0103</span>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree">[docs]</a><span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A mutable, labeled, n-ary tree structure.</span>

<span class="sd">	Each Tree represents a single hierarchical grouping of leaves and subtrees.</span>
<span class="sd">	A tree&#39;s children are encoded as a list of leaves and subtrees, where</span>
<span class="sd">	a leaf is a basic (non-tree) value; and a subtree is a nested Tree. Any</span>
<span class="sd">	other properties that a Tree defines are known as node properties, and are</span>
<span class="sd">	used to add information about individual hierarchical groupings. For</span>
<span class="sd">	example, syntax trees use a label property to label syntactic constituents</span>
<span class="sd">	with phrase labels, such as &quot;NP&quot; and &quot;VP&quot;.</span>
<span class="sd">	Several Tree methods use tree positions to specify children or descendants</span>
<span class="sd">	of a tree. Tree positions are defined as follows:</span>

<span class="sd">	- The tree position ``i`` specifies a Tree&#39;s ith child.</span>
<span class="sd">	- The tree position () specifies the Tree itself.</span>
<span class="sd">	- If ``p`` is the tree position of descendant ``d``, then</span>
<span class="sd">		``p + (i,)`` specifies the ith child of ``d``.</span>

<span class="sd">	i.e., every tree position is either a single index ``i``,</span>
<span class="sd">	specifying ``self[i]``; or a sequence ``(i1, i2, ..., iN)``,</span>
<span class="sd">	specifying ``self[i1][i2]...[iN]``.</span>

<span class="sd">	The constructor can be called in two ways:</span>

<span class="sd">	- ``Tree(label, children)`` constructs a new tree with the specified label</span>
<span class="sd">		and list of children.</span>
<span class="sd">	- ``Tree(s)`` constructs a new tree by parsing the string s. Equivalent to</span>
<span class="sd">		calling the class method ``Tree.parse(s)``.</span>
<span class="sd">		NB: expects integers as leaves by default;</span>
<span class="sd">		use ``Tree.parse(s, parse_leaf=None)`` to interpret leaves as strings.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="c"># NB: _parent is only used by ParentedTree subclass, but __slots__</span>
	<span class="c"># does not work with multiple inheritance.</span>
	<span class="c"># pylint believes unicode strings in slots attributes are illegal</span>
	<span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">,</span> <span class="s">&#39;children&#39;</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="s">&#39;head&#39;</span><span class="p">,</span> <span class="s">&#39;_parent&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">label_or_str</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">label_or_str</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>  <span class="c"># used by copy.deepcopy</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Expected a label and child list &quot;</span>
						<span class="s">&quot;or a single string; got: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
						<span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">or</span>
				<span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">() argument 2 should be a list, not a &quot;</span>
					<span class="s">&quot;string&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="c"># Because __new__ may delegate to Tree.parse(), the __init__</span>
		<span class="c"># method may end up getting called more than once (once when</span>
		<span class="c"># constructing the return value for Tree.parse; and again when</span>
		<span class="c"># __new__ returns). We therefore check if `children` is None</span>
		<span class="c"># (which will cause __new__ to call Tree.parse()); if so, then</span>
		<span class="c"># __init__ has already been called once, so just return.</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="c"># list.__init__(self, children)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label_or_str</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="bp">False</span>

	<span class="c"># === Comparison operators ==================================</span>
	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
				<span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

	<span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
				<span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
				<span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
				<span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span>
				<span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">)</span>

	<span class="c"># === Delegated list operations ==============================</span>
<div class="viewcode-block" id="Tree.append"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.append">[docs]</a>	<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Append ``child`` to this node.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.extend"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.extend">[docs]</a>	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Extend this node&#39;s children with an iterable.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.insert"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.insert">[docs]</a>	<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Insert child at integer index.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.pop"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.pop">[docs]</a>	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Remove child at specified integer index (or default to last).&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.remove"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.remove">[docs]</a>	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Remove child, based on equality.&quot;&quot;&quot;</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.index"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.index">[docs]</a>	<span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return index of child, based on equality.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
</div>
	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

	<span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

	<span class="c"># === Disabled list operations ==============================</span>
	<span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support multiplication&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support multiplication&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support addition&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support addition&#39;</span><span class="p">)</span>

	<span class="c"># === Indexing (with support for tree positions) ============</span>
	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
			<span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be &#39;</span>
						<span class="s">&#39;assigned to.&#39;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>

	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be deleted.&#39;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="c"># === Basic tree operations =================================</span>
<div class="viewcode-block" id="Tree.leaves"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.leaves">[docs]</a>	<span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: list containing this tree&#39;s leaves.</span>

<span class="sd">		The order reflects the order of the tree&#39;s hierarchical structure.&quot;&quot;&quot;</span>
		<span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">leaves</span>
</div>
<div class="viewcode-block" id="Tree.height"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.height">[docs]</a>	<span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: The longest distance from this node to a leaf node.</span>

<span class="sd">		- The height of a tree containing no children is 1;</span>
<span class="sd">		- the height of a tree containing only leaves is 2;</span>
<span class="sd">		- the height of any other tree is one plus the maximum of its</span>
<span class="sd">			children&#39;s heights.&quot;&quot;&quot;</span>
		<span class="n">max_child_height</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">height</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max_child_height</span>
</div>
<div class="viewcode-block" id="Tree.treepositions"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.treepositions">[docs]</a>	<span class="k">def</span> <span class="nf">treepositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;preorder&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:param order: One of preorder, postorder, bothorder, leaves.&quot;&quot;&quot;</span>
		<span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;preorder&#39;</span><span class="p">,</span> <span class="s">&#39;bothorder&#39;</span><span class="p">):</span>
			<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">childpos</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
				<span class="n">positions</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">childpos</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="p">))</span>
		<span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;postorder&#39;</span><span class="p">,</span> <span class="s">&#39;bothorder&#39;</span><span class="p">):</span>
			<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
		<span class="k">return</span> <span class="n">positions</span>
</div>
<div class="viewcode-block" id="Tree.subtrees"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.subtrees">[docs]</a>	<span class="k">def</span> <span class="nf">subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Traverse and generate subtrees of this tree in depth-first order.</span>

<span class="sd">		:param condition: a function to filter which nodes are generated.</span>

<span class="sd">		NB: store traversal as list before any structural modifications.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">yield</span> <span class="bp">self</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">subtree</span>
</div>
<div class="viewcode-block" id="Tree.postorder"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.postorder">[docs]</a>	<span class="k">def</span> <span class="nf">postorder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;A generator that does a postorder traversal of this tree.</span>

<span class="sd">		Similar to Tree.subtrees() which does a preorder traversal.</span>
<span class="sd">		NB: store traversal as list before any structural modifications.&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">subtree</span>
		<span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">yield</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="Tree.pos"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.pos">[docs]</a>	<span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: a list of tuples containing leaves and pre-terminals</span>
<span class="sd">			(part-of-speech tags). The order reflects the order of the tree&#39;s</span>
<span class="sd">			hierarchical structure.&quot;&quot;&quot;</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">pos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">pos</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pos</span>
</div>
<div class="viewcode-block" id="Tree.leaf_treeposition"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.leaf_treeposition">[docs]</a>	<span class="k">def</span> <span class="nf">leaf_treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: The tree position of the index-th leaf in this tree;</span>
<span class="sd">			i.e., if ``tp=self.leaf_treeposition(i)``, then</span>
<span class="sd">			``self[tp]==self.leaves()[i]``.</span>
<span class="sd">		:raises IndexError: if this tree contains fewer than ``index + 1``</span>
<span class="sd">			leaves, or if ``index &lt; 0``.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index must be non-negative&#39;</span><span class="p">)</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="p">())]</span>
		<span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
			<span class="n">value</span><span class="p">,</span> <span class="n">treepos</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">treepos</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
					<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">treepos</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">)))</span>
		<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index must be less than or equal to len(self)&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.treeposition_spanning_leaves"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.treeposition_spanning_leaves">[docs]</a>	<span class="k">def</span> <span class="nf">treeposition_spanning_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: The tree position of the lowest descendant of this tree</span>
<span class="sd">			that dominates ``self.leaves()[start:end]``.</span>
<span class="sd">		:raises ValueError: if ``end &lt;= start``.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;end must be greater than start&#39;</span><span class="p">)</span>
		<span class="c"># Find the tree positions of the start &amp; end leaves,</span>
		<span class="c"># and take the longest common subsequence.</span>
		<span class="n">start_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
		<span class="n">end_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c"># Find the first index where they mismatch:</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_treepos</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_treepos</span><span class="p">)</span> <span class="ow">or</span> <span class="n">start_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
				<span class="k">return</span> <span class="n">start_treepos</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">start_treepos</span>

	<span class="c"># === Convert, copy =========================================</span></div>
	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="Tree.convert"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.convert">[docs]</a>	<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Convert a tree between different subtypes of Tree.</span>

<span class="sd">		:param cls: the class that will be used for the new tree.</span>
<span class="sd">		:param val: The tree that should be converted.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
			<span class="n">tree</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
			<span class="n">tree</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">source</span>
			<span class="n">tree</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">head</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">ImmutableTree</span><span class="p">)</span>
					<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ImmutableTree</span><span class="p">)):</span>
				<span class="n">tree</span><span class="o">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">bitset</span>  <span class="c"># pylint: disable=W0201,E0237</span>
			<span class="k">return</span> <span class="n">tree</span>
		<span class="k">return</span> <span class="n">val</span>
</div>
<div class="viewcode-block" id="Tree.copy"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.copy">[docs]</a>	<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Create a copy of this tree.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
	<span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The frozen version of this class.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">ImmutableTree</span>

<div class="viewcode-block" id="Tree.freeze"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.freeze">[docs]</a>	<span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf_freezer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: an immutable version of this tree.&quot;&quot;&quot;</span>
		<span class="n">frozen_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen_class</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">leaf_freezer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">newcopy</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
				<span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_freezer</span><span class="p">(</span><span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>
		<span class="nb">hash</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>  <span class="c"># Make sure the leaves are hashable.</span>
		<span class="k">return</span> <span class="n">newcopy</span>

	<span class="c"># === Parsing ===============================================</span></div>
	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="Tree.parse"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.parse">[docs]</a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">brackets</span><span class="o">=</span><span class="s">&#39;()&#39;</span><span class="p">,</span> <span class="n">parse_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parse_leaf</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
			<span class="n">label_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">leaf_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Parse a bracketed tree string and return the resulting tree.</span>
<span class="sd">		Trees are represented as nested bracketings, such as:</span>
<span class="sd">		``(S (NP (NNP John)) (VP (V runs)))``</span>

<span class="sd">		:param s: The string to parse</span>
<span class="sd">		:param brackets: The two bracket characters used to mark the</span>
<span class="sd">			beginning and end of trees and subtrees.</span>
<span class="sd">		:param parse_label, parse_leaf: If specified, these functions are</span>
<span class="sd">			applied to the substrings of s corresponding to labels and leaves</span>
<span class="sd">			(respectively) to obtain the values for those labels and leaves.</span>
<span class="sd">			They should have the following signature: parse_label(str) -&gt; value</span>
<span class="sd">		:param label_pattern, leaf_pattern: Regular expression patterns used to</span>
<span class="sd">			find label and leaf substrings in s. By default, both label and</span>
<span class="sd">			leaf patterns are defined to match any sequence of non-whitespace</span>
<span class="sd">			non-bracket characters.</span>
<span class="sd">		:returns: A tree corresponding to the string representation s.</span>
<span class="sd">			If this class method is called using a subclass of Tree, then it</span>
<span class="sd">			will return a tree of that type.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">brackets</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;brackets must be a length-2 string&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r&#39;\s&#39;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;whitespace brackets not allowed&#39;</span><span class="p">)</span>
		<span class="c"># Construct a regexp that will tokenize the string.</span>
		<span class="n">open_b</span><span class="p">,</span> <span class="n">close_b</span> <span class="o">=</span> <span class="n">brackets</span><span class="p">[:</span><span class="mi">1</span><span class="p">],</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">open_b</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">close_b</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">label_pattern</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">label_pattern</span> <span class="o">=</span> <span class="s">r&#39;[^\s</span><span class="si">%s%s</span><span class="s">]+&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">leaf_pattern</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">leaf_pattern</span> <span class="o">=</span> <span class="s">r&#39;[^\s</span><span class="si">%s%s</span><span class="s">]+&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">)</span>
		<span class="n">token_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;</span><span class="si">%s</span><span class="s">\s*(</span><span class="si">%s</span><span class="s">)?|</span><span class="si">%s</span><span class="s">|(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
				<span class="n">open_pattern</span><span class="p">,</span> <span class="n">label_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">,</span> <span class="n">leaf_pattern</span><span class="p">))</span>
		<span class="c"># Walk through each token, updating a stack of trees.</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[])]</span>  <span class="c"># list of (label, children) tuples</span>
		<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">token_re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
			<span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">open_b</span><span class="p">:</span>  <span class="c"># Beginning of a tree/subtree</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">)</span>
				<span class="n">label</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">parse_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">label</span> <span class="o">=</span> <span class="n">parse_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
				<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="p">[]))</span>
			<span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">close_b</span><span class="p">:</span>  <span class="c"># End of a tree/subtree</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">)</span>
				<span class="n">label</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>  <span class="c"># Leaf node</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">parse_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">token</span> <span class="o">=</span> <span class="n">parse_leaf</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
				<span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
		<span class="c"># check that we got exactly one complete tree.</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">,</span> <span class="n">close_b</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">assert</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
		<span class="n">tree</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">tree</span>
</div>
	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">_parse_error</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">expecting</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Display a friendly error message when parsing a tree string fails.</span>

<span class="sd">		:param orig: The string we&#39;re parsing.</span>
<span class="sd">		:param match: regexp match of the problem token.</span>
<span class="sd">		:param expecting: what we expected to see instead.&quot;&quot;&quot;</span>
		<span class="c"># Construct a basic error message</span>
		<span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">:</span>
			<span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig</span><span class="p">),</span> <span class="s">&#39;end-of-string&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.parse(): expected </span><span class="si">%r</span><span class="s"> but got </span><span class="si">%r</span><span class="se">\n</span><span class="si">%s</span><span class="s">at index </span><span class="si">%d</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">expecting</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">12</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
		<span class="c"># Add a display showing the error token itself:</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;...&#39;</span>
		<span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;...&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">10</span><span class="p">:]</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">13</span>
		<span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s">^&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span>
		<span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">orig</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

	<span class="c"># === String Representations ================================</span>
	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">childstr</span> <span class="o">=</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%r</span><span class="s">, [</span><span class="si">%s</span><span class="s">])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">childstr</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="s">&#39;()&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.pprint"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.pprint">[docs]</a>	<span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">brackets</span><span class="o">=</span><span class="s">&#39;()&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;	:returns: A pretty-printed string representation of this tree.</span>
<span class="sd">		:param margin: The right margin at which to do line-wrapping.</span>
<span class="sd">		:param indent: The indentation level at which printing begins. This</span>
<span class="sd">			number is used to decide how far to indent subsequent lines.&quot;&quot;&quot;</span>
		<span class="c"># Try writing it on one line.</span>
		<span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="n">brackets</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">indent</span> <span class="o">&lt;</span> <span class="n">margin</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">s</span>
		<span class="c"># If it doesn&#39;t fit on one line, then write it on multi-lines.</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span>
						<span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">brackets</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span>
		<span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
	<span class="k">def</span> <span class="nf">_pprint_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">brackets</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Pretty-printing helper function.&quot;&quot;&quot;</span>
		<span class="n">childstrs</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="n">brackets</span><span class="p">))</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s"> </span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
									<span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%r</span><span class="s"> </span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
					<span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<div class="viewcode-block" id="Tree.draw"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.Tree.draw">[docs]</a>	<span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: an ASCII art visualization of tree.&quot;&quot;&quot;</span>
		<span class="kn">from</span> <span class="nn">discodop.treedraw</span> <span class="kn">import</span> <span class="n">DrawTree</span>
		<span class="k">return</span> <span class="n">DrawTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">()])</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
</div>
	<span class="k">def</span> <span class="nf">_repr_svg_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return a rich representation for IPython notebook.&quot;&quot;&quot;</span>
		<span class="kn">from</span> <span class="nn">discodop.treedraw</span> <span class="kn">import</span> <span class="n">DrawTree</span>
		<span class="k">return</span> <span class="n">DrawTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">()])</span><span class="o">.</span><span class="n">svg</span><span class="p">()</span>

</div>
<div class="viewcode-block" id="ImmutableTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.ImmutableTree">[docs]</a><span class="k">class</span> <span class="nc">ImmutableTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A tree which may not be modified.; has a hash() value.</span>

<span class="sd">	NB: the ``label`` and ``children`` attributes should not be modified, but</span>
<span class="sd">	this is not enforced.&quot;&quot;&quot;</span>
	<span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;_hash&#39;</span><span class="p">,</span> <span class="s">&#39;_leaves&#39;</span><span class="p">,</span> <span class="s">&#39;bitset&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="c"># Precompute our hash value. This ensures that we&#39;re really</span>
		<span class="c"># immutable. It also means we only have to calculate it once.</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTree</span><span class="se">\&#39;</span><span class="s">s label and children &#39;</span>
					<span class="s">&#39;must be immutable:</span><span class="se">\n</span><span class="si">%s</span><span class="s"> </span><span class="si">%r</span><span class="se">\n</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="c"># self._leaves = Tree.leaves(self)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_addleaves</span><span class="p">()</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span><span class="p">)</span>
			<span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="k">def</span> <span class="nf">_addleaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Set leaves attribute of this node and its descendants.&quot;&quot;&quot;</span>
		<span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">_leaves</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">child</span><span class="o">.</span><span class="n">_addleaves</span><span class="p">()</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_leaves</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span> <span class="o">=</span> <span class="n">leaves</span>

	<span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">_value</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_stop</span><span class="p">,</span> <span class="n">_value</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_index</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_stop</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

</div>
<div class="viewcode-block" id="ParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.ParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ParentedTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A Tree that maintains parent pointers for single-parented trees.</span>

<span class="sd">	The parent pointers are updated whenever any change is made to a tree&#39;s</span>
<span class="sd">	structure. Two subclasses are defined: ParentedTree, MultiParentedTree</span>

<span class="sd">	The following read-only property values are automatically updated</span>
<span class="sd">	whenever the structure of a parented tree is modified: parent,</span>
<span class="sd">	parent_index, left_sibling, right_sibling, root, treeposition.</span>
<span class="sd">	Each ParentedTree may have at most one parent; i.e., subtrees may not be</span>
<span class="sd">	shared. Any attempt to reuse a single ParentedTree as a child of more than</span>
<span class="sd">	one parent (or as multiple children of the same parent) will cause a</span>
<span class="sd">	ValueError exception to be raised. ParentedTrees should never be used in</span>
<span class="sd">	the same tree as Trees or MultiParentedTrees. Mixing tree implementations</span>
<span class="sd">	may result in incorrect parent pointers and in TypeError exceptions.</span>

<span class="sd">	The ParentedTree class redefines all operations that modify a</span>
<span class="sd">	tree&#39;s structure to call two methods, which are used by subclasses to</span>
<span class="sd">	update parent information:</span>

<span class="sd">	- ``_setparent()`` is called whenever a new child is added.</span>
<span class="sd">	- ``_delparent()`` is called whenever a child is removed.&quot;&quot;&quot;</span>
	<span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="c"># iterate over self.children, *not* children,</span>
		<span class="c"># because children might be an iterator.</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">ImmutableParentedTree</span>

	<span class="c"># === Properties =================================================</span>
	<span class="k">def</span> <span class="nf">_get_parent_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The index of this tree in its parent.</span>

<span class="sd">		i.e., ptree.parent[ptree.parent_index] is ptree.</span>
<span class="sd">		Note that ptree.parent_index is not necessarily equal to</span>
<span class="sd">		ptree.parent.index(ptree), since the index() method</span>
<span class="sd">		returns the first child that is _equal_ to its argument.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">None</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">i</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expected to find self in self._parent!&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_get_left_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The left sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
		<span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">None</span>  <span class="c"># no left sibling</span>

	<span class="k">def</span> <span class="nf">_get_right_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The right sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
		<span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">None</span>  <span class="c"># no right sibling</span>

	<span class="k">def</span> <span class="nf">_get_treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The tree position of this tree, relative to the root of the tree.</span>

<span class="sd">		i.e., ptree.root[ptree.treeposition] is ptree.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">()</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_get_treeposition</span><span class="p">()</span> <span class="o">+</span>
				<span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">(),</span> <span class="p">))</span>

	<span class="k">def</span> <span class="nf">_get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: the root of this tree.&quot;&quot;&quot;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">return</span> <span class="n">node</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span>
			<span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;The parent of this tree, or None if it has no parent.&quot;&quot;&quot;</span><span class="p">)</span>
	<span class="n">parent_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_parent_index</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_parent_index</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">left_sibling</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_left_sibling</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_left_sibling</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">right_sibling</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_right_sibling</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_right_sibling</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">root</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_root</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_root</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">treeposition</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_treeposition</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_treeposition</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

	<span class="c"># === Parent Management ==========================================</span>
	<span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Update child&#39;s parent pointer to not point to self.</span>

<span class="sd">		This method is only called if child&#39;s type is Tree; i.e., it is not</span>
<span class="sd">		called when removing a leaf from a tree. This method is always called</span>
<span class="sd">		before the child is actually removed from self&#39;s child list.</span>

<span class="sd">		:param index: The index of child in self.&quot;&quot;&quot;</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">)</span>
		<span class="k">assert</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">self</span>
		<span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Update child&#39;s parent pointer to point to self.</span>

<span class="sd">		This method is only called if child&#39;s type is Tree; i.e., it is not</span>
<span class="sd">		called when adding a leaf to a tree. This method is always called</span>
<span class="sd">		before the child is actually added to self&#39;s child list. Typically, if</span>
<span class="sd">		child is a tree, then its type needs to match self&#39;s type. This</span>
<span class="sd">		prevents mixing of different tree types (single-, multi-, and</span>
<span class="sd">		non-parented).</span>

<span class="sd">		:param index: The index of child in self.</span>
<span class="sd">		:param dry_run: If true, the don&#39;t actually set the child&#39;s parent</span>
<span class="sd">			pointer; just check for any error conditions, and raise an</span>
<span class="sd">			exception if one is found.</span>
<span class="sd">		:raises TypeError: if child is a tree with an inappropriate type.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Cannot insert a non-ParentedTree &#39;</span>
					<span class="s">&#39;into a ParentedTree&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot insert a subtree that already &#39;</span>
					<span class="s">&#39;has a parent.&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
			<span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>

	<span class="c"># === Methods that add/remove children ======================</span>
	<span class="c"># Every method that adds or removes a child must make</span>
	<span class="c"># appropriate calls to _setparent() and _delparent().</span>
	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c"># del ptree[start:stop]</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Clear all the children pointers.</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># Delete the children from our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c"># del ptree[i]</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
			<span class="c"># Clear the child&#39;s parent pointer.</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Remove the child from our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># del ptree[()]</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be deleted.&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># del ptree[(i, )]</span>
			<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># del ptree[i1, i2, i3]</span>
			<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c"># ptree[start:stop] = value</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># make a copy of value, in case it&#39;s an iterator</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
				<span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
			<span class="c"># Check for any error conditions, so we can avoid ending</span>
			<span class="c"># up in an inconsistent state if an error does occur.</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
			<span class="c"># clear the child pointers of all parents we&#39;re removing</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># set the child pointers of the new children. We do this</span>
			<span class="c"># after clearing *all* child pointers, in case we&#39;re e.g.</span>
			<span class="c"># reversing the elements in a tree.</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># finally, update the content of the child list itself.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c"># ptree[i] = value</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
			<span class="c"># if the value is not changing, do nothing.</span>
			<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
				<span class="k">return</span>
			<span class="c"># Set the new child&#39;s parent pointer.</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Remove the old child&#39;s parent pointer</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Update our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># ptree[()] = value</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be assigned to.&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># ptree[(i, )] = value</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># ptree[i1, i2, i3] = value</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>

	<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="c"># Handle negative indexes. Note that if index &lt; -len(self),</span>
		<span class="c"># we do *not* raise an IndexError, unlike __getitem__. This</span>
		<span class="c"># is done for consistency with list.__getitem__ and list.index.</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c"># Set the child&#39;s parent, and update our child list.</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

	<span class="c"># NB: like `list`, this is done by equality, not identity!</span>
	<span class="c"># To remove a specific child, use del ptree[i].</span>
	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ImmutableParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.ImmutableParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ImmutableParentedTree</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Combination of an Immutable and Parented Tree.&quot;&quot;&quot;</span>
	<span class="n">__slots__</span> <span class="o">=</span> <span class="p">()</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ImmutableParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="DiscTree"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.DiscTree">[docs]</a><span class="k">class</span> <span class="nc">DiscTree</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Wrap an immutable tree with indices as leaves and a sentence.</span>

<span class="sd">	Provides hash &amp; equality.&quot;&quot;&quot;</span>
	<span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;sent&#39;</span><span class="p">,</span> <span class="p">)</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">sent</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">DiscTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span>
				<span class="n">DiscTree</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="k">else</span> <span class="n">child</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Test whether two discontinuous trees are equivalent.</span>

<span class="sd">		Assumes canonicalized() ordering.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
			<span class="n">istree</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">istree</span> <span class="o">!=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">return</span> <span class="bp">False</span>
			<span class="k">elif</span> <span class="ow">not</span> <span class="n">istree</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sent</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">sent</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>
			<span class="k">elif</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
				<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">True</span>

	<span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">__hash__</span><span class="p">()</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">sent</span><span class="p">[</span><span class="n">child</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="s">&quot;DisctTree(</span><span class="si">%r</span><span class="s">, </span><span class="si">%r</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span>
				<span class="nb">super</span><span class="p">(</span><span class="n">DiscTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__repr__</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">sent</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="slice_bounds"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.grammar.slice_bounds">[docs]</a><span class="k">def</span> <span class="nf">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">slice_obj</span><span class="p">,</span> <span class="n">allow_step</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculate the effective (start, stop) bounds of a slice.</span>

<span class="sd">	Takes into account ``None`` indices and negative indices.</span>

<span class="sd">	:returns: tuple ``(start, stop, 1)``, s.t. ``0 &lt;= start &lt;= stop &lt;= len(seq)``</span>
<span class="sd">	:raises ValueError: if slice_obj.step is not None.</span>
<span class="sd">	:param allow_step: If true, then the slice object may have a non-None step.</span>
<span class="sd">		If it does, then return a tuple (start, stop, step).&quot;&quot;&quot;</span>
	<span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_obj</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">allow_step</span><span class="p">:</span>
		<span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span>
		<span class="c"># Use a recursive call without allow_step to find the slice</span>
		<span class="c"># bounds. If step is negative, then the roles of start and</span>
		<span class="c"># stop (in terms of default values, etc), are swapped.</span>
		<span class="k">if</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span>
	<span class="k">elif</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;slices with steps are not supported by </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
				<span class="n">seq</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
	<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">start</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">stop</span>
	<span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">start</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">stop</span><span class="p">)</span> <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">stop</span>
	<span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Make sure stop doesn&#39;t go past the end of the list.</span>
		<span class="k">try</span><span class="p">:</span>  <span class="c"># Avoid calculating len(seq), may be expensive for lazy sequences</span>
			<span class="n">seq</span><span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
			<span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
	<span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="mi">1</span>
</div>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Tree&#39;</span><span class="p">,</span> <span class="s">&#39;ImmutableTree&#39;</span><span class="p">,</span> <span class="s">&#39;ParentedTree&#39;</span><span class="p">,</span> <span class="s">&#39;ImmutableParentedTree&#39;</span><span class="p">,</span>
		<span class="s">&#39;slice_bounds&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref.html">Reference</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>