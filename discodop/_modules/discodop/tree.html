<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.tree &mdash; Disco-DOP 0.4.1pre1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.4.1pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.4.1pre1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../index.html">Disco-DOP 0.4.1pre1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for discodop.tree</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Various Tree objects for representing syntax or morphological trees.</span>

<span class="sd">This is an adaptation of the original tree.py file from NLTK.</span>
<span class="sd">Removed: probabilistic trees, binarization, reading off CFG productions, &amp;c.&quot;&quot;&quot;</span>
<span class="c"># Original notice:</span>
<span class="c"># Natural Language Toolkit: Text Trees</span>
<span class="c">#</span>
<span class="c"># Copyright (C) 2001-2010 NLTK Project</span>
<span class="c"># Author: Edward Loper &lt;edloper@gradient.cis.upenn.edu&gt;</span>
<span class="c">#         Steven Bird &lt;sb@csse.unimelb.edu.au&gt;</span>
<span class="c">#         Nathan Bodenstab &lt;bodenstab@cslu.ogi.edu&gt; (tree transforms)</span>
<span class="c"># URL: &lt;http://www.nltk.org/&gt;</span>
<span class="c"># For license information, see LICENSE.TXT</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s">&#39;3&#39;</span><span class="p">:</span>
	<span class="nb">basestring</span> <span class="o">=</span> <span class="nb">str</span>  <span class="c"># pylint: disable=W0622,C0103</span>


<div class="viewcode-block" id="Tree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree">[docs]</a><span class="k">class</span> <span class="nc">Tree</span><span class="p">(</span><span class="nb">list</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A mutable, labeled, n-ary tree structure.</span>

<span class="sd">	Each Tree represents a single hierarchical grouping of leaves and subtrees.</span>
<span class="sd">	A tree&#39;s children are encoded as a list of leaves and subtrees, where</span>
<span class="sd">	a leaf is a basic (non-tree) value; and a subtree is a nested Tree. Any</span>
<span class="sd">	other properties that a Tree defines are known as node properties, and are</span>
<span class="sd">	used to add information about individual hierarchical groupings. For</span>
<span class="sd">	example, syntax trees use a label property to label syntactic constituents</span>
<span class="sd">	with phrase labels, such as &quot;NP&quot; and &quot;VP&quot;.</span>
<span class="sd">	Several Tree methods use tree positions to specify children or descendants</span>
<span class="sd">	of a tree. Tree positions are defined as follows:</span>

<span class="sd">	- The tree position ``i`` specifies a Tree&#39;s ith child.</span>
<span class="sd">	- The tree position () specifies the Tree itself.</span>
<span class="sd">	- If ``p`` is the tree position of descendant ``d``, then</span>
<span class="sd">		``p + (i,)`` specifies the ith child of ``d``.</span>

<span class="sd">	i.e., every tree position is either a single index ``i``,</span>
<span class="sd">	specifying ``self[i]``; or a sequence ``(i1, i2, ..., iN)``,</span>
<span class="sd">	specifying ``self[i1][i2]...[iN]``.</span>

<span class="sd">	The constructor can be called in two ways:</span>

<span class="sd">	- ``Tree(label, children)`` constructs a new tree with the specified label</span>
<span class="sd">		and list of children.</span>
<span class="sd">	- ``Tree(s)`` constructs a new tree by parsing the string s. Equivalent to</span>
<span class="sd">		calling the class method ``Tree.parse(s)``.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">label_or_str</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">label_or_str</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>  <span class="c"># used by copy.deepcopy</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">: Expected a label and child list &quot;</span>
						<span class="s">&quot;or a single string&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">or</span>
				<span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="s">&#39;__iter__&#39;</span><span class="p">)):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">() argument 2 should be a list, not a &quot;</span>
					<span class="s">&quot;string&quot;</span> <span class="o">%</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="c"># Because __new__ may delegate to Tree.parse(), the __init__</span>
		<span class="c"># method may end up getting called more than once (once when</span>
		<span class="c"># constructing the return value for Tree.parse; and again when</span>
		<span class="c"># __new__ returns). We therefore check if `children` is None</span>
		<span class="c"># (which will cause __new__ to call Tree.parse()); if so, then</span>
		<span class="c"># __init__ has already been called once, so just return.</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>
		<span class="nb">list</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label_or_str</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bitset</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="c"># === Comparison operators ==================================</span>
	<span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">and</span> <span class="nb">list</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">return</span> <span class="ow">not</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span>

	<span class="k">def</span> <span class="nf">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&lt;</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">list</span><span class="o">.</span><span class="n">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&lt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">list</span><span class="o">.</span><span class="n">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">True</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&gt;</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">list</span><span class="o">.</span><span class="n">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">False</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">&gt;=</span> <span class="n">other</span><span class="o">.</span><span class="n">label</span> <span class="ow">or</span> <span class="nb">list</span><span class="o">.</span><span class="n">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

	<span class="c"># === Disabled list operations ==============================</span>
	<span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support multiplication&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support multiplication&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support addition&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Tree does not support addition&#39;</span><span class="p">)</span>

	<span class="c"># === Indexing (with support for tree positions) ============</span>
	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
			<span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be &#39;</span>
						<span class="s">&#39;assigned to.&#39;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>

	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)):</span>
			<span class="k">return</span> <span class="nb">list</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be deleted.&#39;</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="c"># === Basic tree operations =================================</span>
<div class="viewcode-block" id="Tree.leaves"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.leaves">[docs]</a>	<span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: list containing this tree&#39;s leaves.</span>

<span class="sd">		The order reflects the order of the tree&#39;s hierarchical structure.&quot;&quot;&quot;</span>
		<span class="n">leaves</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">leaves</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">leaves</span>
</div>
<div class="viewcode-block" id="Tree.height"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.height">[docs]</a>	<span class="k">def</span> <span class="nf">height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: The longest distance from this node to a leaf node.</span>

<span class="sd">		- The height of a tree containing no children is 1;</span>
<span class="sd">		- the height of a tree containing only leaves is 2;</span>
<span class="sd">		- the height of any other tree is one plus the maximum of its</span>
<span class="sd">			children&#39;s heights.&quot;&quot;&quot;</span>
		<span class="n">max_child_height</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="n">child</span><span class="o">.</span><span class="n">height</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">max_child_height</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_child_height</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">max_child_height</span>
</div>
<div class="viewcode-block" id="Tree.treepositions"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.treepositions">[docs]</a>	<span class="k">def</span> <span class="nf">treepositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s">&#39;preorder&#39;</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:param order: One of preorder, postorder, bothorder, leaves.&quot;&quot;&quot;</span>
		<span class="n">positions</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;preorder&#39;</span><span class="p">,</span> <span class="s">&#39;bothorder&#39;</span><span class="p">):</span>
			<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">childpos</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="n">order</span><span class="p">)</span>
				<span class="n">positions</span><span class="o">.</span><span class="n">extend</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">childpos</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="p">))</span>
		<span class="k">if</span> <span class="n">order</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;postorder&#39;</span><span class="p">,</span> <span class="s">&#39;bothorder&#39;</span><span class="p">):</span>
			<span class="n">positions</span><span class="o">.</span><span class="n">append</span><span class="p">(())</span>
		<span class="k">return</span> <span class="n">positions</span>
</div>
<div class="viewcode-block" id="Tree.subtrees"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.subtrees">[docs]</a>	<span class="k">def</span> <span class="nf">subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Traverse and generate subtrees of this tree in depth-first order.</span>

<span class="sd">		:param condition: a function to filter which nodes are generated.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">condition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">yield</span> <span class="bp">self</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="n">condition</span><span class="p">):</span>
					<span class="k">yield</span> <span class="n">subtree</span>
</div>
<div class="viewcode-block" id="Tree.pos"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.pos">[docs]</a>	<span class="k">def</span> <span class="nf">pos</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: a list of tuples containing leaves and pre-terminals</span>
<span class="sd">			(part-of-speech tags). The order reflects the order of the tree&#39;s</span>
<span class="sd">			hierarchical structure.&quot;&quot;&quot;</span>
		<span class="n">pos</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">pos</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">pos</span><span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">pos</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">child</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">pos</span>
</div>
<div class="viewcode-block" id="Tree.leaf_treeposition"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.leaf_treeposition">[docs]</a>	<span class="k">def</span> <span class="nf">leaf_treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: The tree position of the index-th leaf in this tree;</span>
<span class="sd">			i.e., if ``tp=self.leaf_treeposition(i)``, then</span>
<span class="sd">			``self[tp]==self.leaves()[i]``.</span>
<span class="sd">		:raises IndexError: if this tree contains fewer than ``index + 1``</span>
<span class="sd">			leaves, or if ``index &lt; 0``.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index must be non-negative&#39;</span><span class="p">)</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">self</span><span class="p">,</span> <span class="p">())]</span>
		<span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
			<span class="n">value</span><span class="p">,</span> <span class="n">treepos</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
					<span class="k">return</span> <span class="n">treepos</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">index</span> <span class="o">-=</span> <span class="mi">1</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
					<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">treepos</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="p">)))</span>
		<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index must be less than or equal to len(self)&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Tree.treeposition_spanning_leaves"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.treeposition_spanning_leaves">[docs]</a>	<span class="k">def</span> <span class="nf">treeposition_spanning_leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: The tree position of the lowest descendant of this tree</span>
<span class="sd">			that dominates ``self.leaves()[start:end]``.</span>
<span class="sd">		:raises ValueError: if ``end &lt;= start``.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;end must be greater than start&#39;</span><span class="p">)</span>
		<span class="c"># Find the tree positions of the start &amp; end leaves,</span>
		<span class="c"># and take the longest common subsequence.</span>
		<span class="n">start_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
		<span class="n">end_treepos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaf_treeposition</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="c"># Find the first index where they mismatch:</span>
		<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">start_treepos</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_treepos</span><span class="p">)</span> <span class="ow">or</span> <span class="n">start_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">end_treepos</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
				<span class="k">return</span> <span class="n">start_treepos</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">start_treepos</span>

	<span class="c"># === Convert, copy =========================================</span></div>
	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="Tree.convert"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.convert">[docs]</a>	<span class="k">def</span> <span class="nf">convert</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Convert a tree between different subtypes of Tree.</span>

<span class="sd">		:param cls: the class that will be used for the new tree.</span>
<span class="sd">		:param val: The tree that should be converted.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">cls</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
			<span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">val</span>
</div>
<div class="viewcode-block" id="Tree.copy"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.copy">[docs]</a>	<span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Create a copy of this tree.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">deep</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</div>
	<span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The frozen version of this class.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="n">ImmutableTree</span>

<div class="viewcode-block" id="Tree.freeze"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.freeze">[docs]</a>	<span class="k">def</span> <span class="nf">freeze</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">leaf_freezer</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: an immutable version of this tree.&quot;&quot;&quot;</span>
		<span class="n">frozen_class</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_frozen_class</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">leaf_freezer</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">newcopy</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
				<span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">leaf_freezer</span><span class="p">(</span><span class="n">newcopy</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
			<span class="n">newcopy</span> <span class="o">=</span> <span class="n">frozen_class</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>
		<span class="nb">hash</span><span class="p">(</span><span class="n">newcopy</span><span class="p">)</span>  <span class="c"># Make sure the leaves are hashable.</span>
		<span class="k">return</span> <span class="n">newcopy</span>

	<span class="c"># === Parsing ===============================================</span></div>
	<span class="nd">@classmethod</span>
<div class="viewcode-block" id="Tree.parse"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.parse">[docs]</a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">brackets</span><span class="o">=</span><span class="s">&#39;()&#39;</span><span class="p">,</span> <span class="n">parse_label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">parse_leaf</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
			<span class="n">label_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">leaf_pattern</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Parse a bracketed tree string and return the resulting tree.</span>
<span class="sd">		Trees are represented as nested brackettings, such as:</span>
<span class="sd">		``(S (NP (NNP John)) (VP (V runs)))``</span>

<span class="sd">		:param s: The string to parse</span>
<span class="sd">		:param brackets: The two bracket characters used to mark the</span>
<span class="sd">			beginning and end of trees and subtrees.</span>
<span class="sd">		:param parse_label, parse_leaf: If specified, these functions are</span>
<span class="sd">			applied to the substrings of s corresponding to labels and leaves</span>
<span class="sd">			(respectively) to obtain the values for those labels and leaves.</span>
<span class="sd">			They should have the following signature: parse_label(str) -&gt; value</span>
<span class="sd">		:param label_pattern, leaf_pattern: Regular expression patterns used to</span>
<span class="sd">			find label and leaf substrings in s. By default, both label and</span>
<span class="sd">			leaf patterns are defined to match any sequence of non-whitespace</span>
<span class="sd">			non-bracket characters.</span>
<span class="sd">		:returns: A tree corresponding to the string representation s.</span>
<span class="sd">			If this class method is called using a subclass of Tree, then it</span>
<span class="sd">			will return a tree of that type.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">brackets</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;brackets must be a length-2 string&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r&#39;\s&#39;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;whitespace brackets not allowed&#39;</span><span class="p">)</span>
		<span class="c"># Construct a regexp that will tokenize the string.</span>
		<span class="n">open_b</span><span class="p">,</span> <span class="n">close_b</span> <span class="o">=</span> <span class="n">brackets</span>
		<span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span> <span class="o">=</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">open_b</span><span class="p">),</span> <span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">close_b</span><span class="p">))</span>
		<span class="k">if</span> <span class="n">label_pattern</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">label_pattern</span> <span class="o">=</span> <span class="s">r&#39;[^\s</span><span class="si">%s%s</span><span class="s">]+&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">leaf_pattern</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">leaf_pattern</span> <span class="o">=</span> <span class="s">r&#39;[^\s</span><span class="si">%s%s</span><span class="s">]+&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">open_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">)</span>
		<span class="n">token_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;</span><span class="si">%s</span><span class="s">\s*(</span><span class="si">%s</span><span class="s">)?|</span><span class="si">%s</span><span class="s">|(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span>
			<span class="n">open_pattern</span><span class="p">,</span> <span class="n">label_pattern</span><span class="p">,</span> <span class="n">close_pattern</span><span class="p">,</span> <span class="n">leaf_pattern</span><span class="p">))</span>
		<span class="c"># Walk through each token, updating a stack of trees.</span>
		<span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="bp">None</span><span class="p">,</span> <span class="p">[])]</span>  <span class="c"># list of (label, children) tuples</span>
		<span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">token_re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
			<span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">token</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">open_b</span><span class="p">:</span>  <span class="c"># Beginning of a tree/subtree</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">)</span>
				<span class="n">label</span> <span class="o">=</span> <span class="n">token</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">parse_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">label</span> <span class="o">=</span> <span class="n">parse_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
				<span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="p">[]))</span>
			<span class="k">elif</span> <span class="n">token</span> <span class="o">==</span> <span class="n">close_b</span><span class="p">:</span>  <span class="c"># End of a tree/subtree</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
						<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">)</span>
				<span class="n">label</span><span class="p">,</span> <span class="n">children</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cls</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">))</span>
			<span class="k">else</span><span class="p">:</span>  <span class="c"># Leaf node</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
					<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">parse_leaf</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
					<span class="n">token</span> <span class="o">=</span> <span class="n">parse_leaf</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
				<span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">token</span><span class="p">)</span>
		<span class="c"># check that we got exactly one complete tree.</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">,</span> <span class="n">close_b</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">_parse_error</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">,</span> <span class="n">open_b</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">assert</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
		<span class="n">tree</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">tree</span>
</div>
	<span class="nd">@classmethod</span>
	<span class="k">def</span> <span class="nf">_parse_error</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">orig</span><span class="p">,</span> <span class="n">match</span><span class="p">,</span> <span class="n">expecting</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Display a friendly error message when parsing a tree string fails.</span>

<span class="sd">		:param orig: The string we&#39;re parsing.</span>
<span class="sd">		:param match: regexp match of the problem token.</span>
<span class="sd">		:param expecting: what we expected to see instead.&quot;&quot;&quot;</span>
		<span class="c"># Construct a basic error message</span>
		<span class="k">if</span> <span class="n">match</span> <span class="o">==</span> <span class="s">&#39;end-of-string&#39;</span><span class="p">:</span>
			<span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orig</span><span class="p">),</span> <span class="s">&#39;end-of-string&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">pos</span><span class="p">,</span> <span class="n">token</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">()</span>
		<span class="n">msg</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.parse(): expected </span><span class="si">%r</span><span class="s"> but got </span><span class="si">%r</span><span class="se">\n</span><span class="si">%s</span><span class="s">at index </span><span class="si">%d</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span>
			<span class="n">cls</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">expecting</span><span class="p">,</span> <span class="n">token</span><span class="p">,</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">12</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
		<span class="c"># Add a display showing the error token itself:</span>
		<span class="n">s</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">10</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;...&#39;</span>
		<span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;...&#39;</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">pos</span> <span class="o">-</span> <span class="mi">10</span><span class="p">:]</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">13</span>
		<span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">&quot;</span><span class="se">\n</span><span class="si">%s</span><span class="s">^&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="mi">17</span> <span class="o">+</span> <span class="n">offset</span><span class="p">))</span>
		<span class="n">msg</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">orig</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

	<span class="c"># === String Representation =================================</span>
	<span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="n">childstr</span> <span class="o">=</span> <span class="s">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>
		<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">(</span><span class="si">%r</span><span class="s">, [</span><span class="si">%s</span><span class="s">])&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">childstr</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;()&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

<div class="viewcode-block" id="Tree.pprint"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.pprint">[docs]</a>	<span class="k">def</span> <span class="nf">pprint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">margin</span><span class="o">=</span><span class="mi">70</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">labelsep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">brackets</span><span class="o">=</span><span class="s">&#39;()&#39;</span><span class="p">,</span>
			<span class="n">quotes</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;	:returns: A pretty-printed string representation of this tree.</span>
<span class="sd">		:param margin: The right margin at which to do line-wrapping.</span>
<span class="sd">		:param indent: The indentation level at which printing begins. This</span>
<span class="sd">			number is used to decide how far to indent subsequent lines.</span>
<span class="sd">		:param labelsep: A string that is used to separate the label from the</span>
<span class="sd">			children; e.g., the value &#39;:&#39; gives trees like::</span>

<span class="sd">				(S: (NP: I) (VP: (V: saw) (NP: it))).&quot;&quot;&quot;</span>
		<span class="c"># Try writing it on one line.</span>
		<span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="n">labelsep</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="n">quotes</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">indent</span> <span class="o">&lt;</span> <span class="n">margin</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">s</span>
		<span class="c"># If it doesn&#39;t fit on one line, then write it on multi-lines.</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">s</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s%r%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">margin</span><span class="p">,</span>
						<span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="n">quotes</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quotes</span><span class="p">:</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">s</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="p">(</span><span class="n">indent</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span>
		<span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
</div>
	<span class="k">def</span> <span class="nf">_pprint_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="n">quotes</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;pretty-printing helper function.&quot;&quot;&quot;</span>
		<span class="n">childstrs</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">_pprint_flat</span><span class="p">(</span><span class="n">labelsep</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="n">quotes</span><span class="p">))</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;/&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
			<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quotes</span><span class="p">:</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span><span class="p">)</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">childstrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">child</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
			<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s%s</span><span class="s"> </span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">,</span>
									<span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%r%s</span><span class="s"> </span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">brackets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">labelsep</span><span class="p">,</span>
								<span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">childstrs</span><span class="p">),</span> <span class="n">brackets</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<div class="viewcode-block" id="Tree.draw"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.Tree.draw">[docs]</a>	<span class="k">def</span> <span class="nf">draw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: an ASCII art visualization of tree.&quot;&quot;&quot;</span>
		<span class="kn">from</span> <span class="nn">discodop.treedraw</span> <span class="kn">import</span> <span class="n">DrawTree</span>
		<span class="k">return</span> <span class="n">DrawTree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">leaves</span><span class="p">()])</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>

</div></div>
<div class="viewcode-block" id="ImmutableTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.ImmutableTree">[docs]</a><span class="k">class</span> <span class="nc">ImmutableTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A tree which may not be modified.; has a hash() value.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="c"># Precompute our hash value. This ensures that we&#39;re really</span>
		<span class="c"># immutable. It also means we only have to calculate it once.</span>
		<span class="k">try</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_hash</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
		<span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;ImmutableTree&#39;s label and children &quot;</span>
					<span class="s">&quot;must be immutable:</span><span class="se">\n</span><span class="si">%s</span><span class="s"> </span><span class="si">%r</span><span class="se">\n</span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">err</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_subtrees</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">Tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_leaves</span>

	<span class="k">def</span> <span class="nf">subtrees</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">condition</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtrees</span>
		<span class="k">return</span> <span class="nb">filter</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_subtrees</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">_value</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_stop</span><span class="p">,</span> <span class="n">_value</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_index</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_start</span><span class="p">,</span> <span class="n">_stop</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hash</span>

	<span class="k">def</span> <span class="nf">_set_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Set self._label.</span>

<span class="sd">		This will only succeed the first time the label is set, which should</span>
<span class="sd">		occur in Tree.__init__().&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_label&#39;</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;ImmutableTrees may not be modified&#39;</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_label</span> <span class="o">=</span> <span class="n">label</span>  <span class="c"># pylint: disable=W0201</span>

	<span class="k">def</span> <span class="nf">_get_label</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Get node label.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_label</span>
	<span class="n">label</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_label</span><span class="p">,</span> <span class="n">_set_label</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_label</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

</div>
<span class="k">class</span> <span class="nc">AbstractParentedTree</span><span class="p">(</span><span class="n">Tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;An abstract base class for Trees that maintain parent pointers.</span>

<span class="sd">	The parent pointers are updated whenever any change is made to a tree&#39;s</span>
<span class="sd">	structure. Two subclasses are defined: ParentedTree, MultiParentedTree</span>

<span class="sd">	The AbstractParentedTree class redefines all operations that modify a</span>
<span class="sd">	tree&#39;s structure to call two methods, which are used by subclasses to</span>
<span class="sd">	update parent information:</span>

<span class="sd">	- ``_setparent()`` is called whenever a new child is added.</span>
<span class="sd">	- ``_delparent()`` is called whenever a child is removed.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
		<span class="c"># iterate over self, and *not* children, because children</span>
		<span class="c"># might be an iterator.</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

	<span class="c"># === Parent management =====================================</span>
	<span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_child</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Update child&#39;s parent pointer to point to self.</span>

<span class="sd">		This method is only called if child&#39;s type is Tree; i.e., it is not</span>
<span class="sd">		called when adding a leaf to a tree. This method is always called</span>
<span class="sd">		before the child is actually added to self&#39;s child list. Typically, if</span>
<span class="sd">		child is a tree, then its type needs to match self&#39;s type. This</span>
<span class="sd">		prevents mixing of different tree types (single-, multi-, and</span>
<span class="sd">		non-parented).</span>

<span class="sd">		:param index: The index of child in self.</span>
<span class="sd">		:param dry_run: If true, the don&#39;t actually set the child&#39;s parent</span>
<span class="sd">			pointer; just check for any error conditions, and raise an</span>
<span class="sd">			exception if one is found.</span>
<span class="sd">		:raises TypeError: if child is a tree with an inappropriate type.&quot;&quot;&quot;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Abstract base class&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_child</span><span class="p">,</span> <span class="n">_index</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Update child&#39;s parent pointer to not point to self.</span>

<span class="sd">		This method is only called if child&#39;s type is Tree; i.e., it is not</span>
<span class="sd">		called when removing a leaf from a tree. This method is always called</span>
<span class="sd">		before the child is actually removed from self&#39;s child list.</span>

<span class="sd">		:param index: The index of child in self.&quot;&quot;&quot;</span>
		<span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&#39;Abstract base class&#39;</span><span class="p">)</span>

	<span class="c"># === Methods that add/remove children ======================</span>
	<span class="c"># Every method that adds or removes a child must make</span>
	<span class="c"># appropriate calls to _setparent() and _delparent().</span>
	<span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c"># del ptree[start:stop]</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Clear all the children pointers.</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># Delete the children from our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c"># del ptree[i]</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
			<span class="c"># Clear the child&#39;s parent pointer.</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Remove the child from our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># del ptree[()]</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be deleted.&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># del ptree[(i, )]</span>
			<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># del ptree[i1, i2, i3]</span>
			<span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

	<span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>  <span class="c"># ptree[start:stop] = value</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># make a copy of value, in case it&#39;s an iterator</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
				<span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
			<span class="c"># Check for any error conditions, so we can avoid ending</span>
			<span class="c"># up in an inconsistent state if an error does occur.</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
			<span class="c"># clear the child pointers of all parents we&#39;re removing</span>
			<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># set the child pointers of the new children. We do this</span>
			<span class="c"># after clearing *all* child pointers, in case we&#39;re e.g.</span>
			<span class="c"># reversing the elements in a tree.</span>
			<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
				<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
					<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>
			<span class="c"># finally, update the content of the child list itself.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>  <span class="c"># ptree[i] = value</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
			<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
			<span class="c"># if the value is not changing, do nothing.</span>
			<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]:</span>
				<span class="k">return</span>
			<span class="c"># Set the new child&#39;s parent pointer.</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Remove the old child&#39;s parent pointer</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
			<span class="c"># Update our child list.</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># ptree[()] = value</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;The tree position () may not be assigned to.&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># ptree[(i, )] = value</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># ptree[i1, i2, i3] = value</span>
			<span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>

	<span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">children</span><span class="p">):</span>
		<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
			<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="c"># Handle negative indexes. Note that if index &lt; -len(self),</span>
		<span class="c"># we do *not* raise an IndexError, unlike __getitem__. This</span>
		<span class="c"># is done for consistency with list.__getitem__ and list.index.</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="c"># Set the child&#39;s parent, and update our child list.</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_setparent</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">index</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;index out of range&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>

	<span class="c"># NB: like `list`, this is done by equality, not identity!</span>
	<span class="c"># To remove a specific child, use del ptree[i].</span>
	<span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">):</span>
		<span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

	<span class="c"># We need to implement __getslice__ and friends, even though</span>
	<span class="c"># they&#39;re deprecated, because otherwise list.__getslice__ will get</span>
	<span class="c"># called (since we&#39;re subclassing from list). Just delegate to</span>
	<span class="c"># __getitem__ etc., but use max(0, start) and max(0, stop) because</span>
	<span class="c"># because negative indices are already handled *before*</span>
	<span class="c"># __getslice__ is called; and we don&#39;t want to double-count them.</span>
	<span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="s">&#39;__getslice__&#39;</span><span class="p">):</span>
		<span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>

		<span class="k">def</span> <span class="nf">__delslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)))</span>

		<span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="p">)),</span> <span class="n">value</span><span class="p">)</span>


<div class="viewcode-block" id="ParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.ParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ParentedTree</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A Tree that maintains parent pointers for single-parented trees.</span>

<span class="sd">	The following read-only property values are automatically updated</span>
<span class="sd">	whenever the structure of a parented tree is modified: parent,</span>
<span class="sd">	parent_index, left_sibling, right_sibling, root, treeposition.</span>
<span class="sd">	Each ParentedTree may have at most one parent; i.e., subtrees may not be</span>
<span class="sd">	shared. Any attempt to reuse a single ParentedTree as a child of more than</span>
<span class="sd">	one parent (or as multiple children of the same parent) will cause a</span>
<span class="sd">	ValueError exception to be raised. ParentedTrees should never be used in</span>
<span class="sd">	the same tree as Trees or MultiParentedTrees. Mixing tree implementations</span>
<span class="sd">	may result in incorrect parent pointers and in TypeError exceptions.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">None</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">ImmutableParentedTree</span>

	<span class="c"># === Properties =================================================</span>
	<span class="k">def</span> <span class="nf">_get_parent_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The index of this tree in its parent.</span>

<span class="sd">		i.e., ptree.parent[ptree.parent_index] is ptree.</span>
<span class="sd">		Note that ptree.parent_index is not necessarily equal to</span>
<span class="sd">		ptree.parent.index(ptree), since the index() method</span>
<span class="sd">		returns the first child that is _equal_ to its argument.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">None</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
				<span class="k">return</span> <span class="n">i</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expected to find self in self._parent!&#39;</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_get_left_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The left sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
		<span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">None</span>  <span class="c"># no left sibling</span>

	<span class="k">def</span> <span class="nf">_get_right_sibling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The right sibling of this tree, or None if it has none.&quot;&quot;&quot;</span>
		<span class="n">parent_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">()</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">and</span> <span class="n">parent_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">[</span><span class="n">parent_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">None</span>  <span class="c"># no right sibling</span>

	<span class="k">def</span> <span class="nf">_get_treeposition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The tree position of this tree, relative to the root of the tree.</span>

<span class="sd">		i.e., ptree.root[ptree.treeposition] is ptree.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">()</span>
		<span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_get_treeposition</span><span class="p">()</span> <span class="o">+</span>
				<span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_index</span><span class="p">(),</span> <span class="p">))</span>

	<span class="k">def</span> <span class="nf">_get_root</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The root of this tree.</span>

<span class="sd">		i.e., the unique ancestor of this tree whose parent is None.</span>
<span class="sd">		If ptree.parent is None, then ptree is its own root.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="bp">self</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="o">.</span><span class="n">_get_root</span><span class="p">()</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span>
			<span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;The parent of this tree, or None if it has no parent.&quot;&quot;&quot;</span><span class="p">)</span>
	<span class="n">parent_index</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_parent_index</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_parent_index</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">left_sibling</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_left_sibling</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_left_sibling</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">right_sibling</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_right_sibling</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_right_sibling</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">root</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_root</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_root</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">treeposition</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_treeposition</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_treeposition</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

	<span class="c"># === Parent Management ==========================================</span>
	<span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">)</span>
		<span class="k">assert</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="bp">self</span>
		<span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">None</span>

	<span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Cannot insert a non-ParentedTree &#39;</span>
					<span class="s">&#39;into a ParentedTree&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Cannot insert a subtree that already &#39;</span>
					<span class="s">&#39;has a parent.&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
			<span class="n">child</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="bp">self</span>

</div>
<div class="viewcode-block" id="ImmutableParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.ImmutableParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ImmutableParentedTree</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Combination of an Immutable and Parented Tree.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ImmutableParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="MultiParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.MultiParentedTree">[docs]</a><span class="k">class</span> <span class="nc">MultiParentedTree</span><span class="p">(</span><span class="n">AbstractParentedTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A Tree that maintains parent pointers for multi-parented trees.</span>

<span class="sd">	The following read-only property values are automatically updated</span>
<span class="sd">	whenever the structure of a multi-parented tree is modified: parents,</span>
<span class="sd">	parent_indices, left_siblings, right_siblings, roots, treepositions. Each</span>
<span class="sd">	MultiParentedTree may have zero or more parents. In particular, subtrees</span>
<span class="sd">	may be shared. If a single MultiParentedTree is used as multiple children</span>
<span class="sd">	of the same parent, then that parent will appear multiple times in its</span>
<span class="sd">	parents property. MultiParentedTrees should never be used in the same tree</span>
<span class="sd">	as Trees or ParentedTrees. Mixing tree implementations may result in</span>
<span class="sd">	incorrect parent pointers and in TypeError exceptions.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="c"># This list should not contain duplicates, even if a parent contains</span>
		<span class="c"># this tree multiple times.</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">_parents</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">MultiParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_frozen_class</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">ImmutableMultiParentedTree</span>

	<span class="c"># === Properties =================================================</span>
	<span class="k">def</span> <span class="nf">_get_parent_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Collect tuples of (parent, index) for all parents in a list.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span>
				<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_get_left_siblings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;A list of left siblings of this tree, in any of its parent trees.</span>

<span class="sd">		A tree may be its own left sibling if it is used as multiple</span>
<span class="sd">		contiguous children of the same parent. A tree may appear multiple</span>
<span class="sd">		times in this list if it is the left sibling of this tree with respect</span>
<span class="sd">		to multiple parents.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_indices</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">_get_right_siblings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;A list of right siblings of this tree, in any of its parent trees.</span>

<span class="sd">		A tree may be its own right sibling if it is used as multiple</span>
<span class="sd">		contiguous children of the same parent. A tree may appear multiple</span>
<span class="sd">		times in this list if it is the right sibling of this tree with respect</span>
<span class="sd">		to multiple parents.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">parent</span><span class="p">[</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parent_indices</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

	<span class="k">def</span> <span class="nf">_get_roots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;The set of all roots of this tree.</span>

<span class="sd">		This set is formed by tracing all possible parent paths until trees</span>
<span class="sd">		with no parents are found.&quot;&quot;&quot;</span>
		<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_roots_helper</span><span class="p">({})</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

	<span class="k">def</span> <span class="nf">_get_roots_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Collect all roots for this node.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
				<span class="n">parent</span><span class="o">.</span><span class="n">_get_roots_helper</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">result</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="bp">self</span>
		<span class="k">return</span> <span class="n">result</span>

	<span class="n">parents</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">),</span>
		<span class="n">doc</span><span class="o">=</span><span class="s">&quot;&quot;&quot;The set of parents of this tree.</span>

<span class="s">		If this tree has no parents, then parents is the empty set. To check if</span>
<span class="s">		a tree is used as multiple children of the same parent, use the</span>
<span class="s">		parent_indices property.&quot;&quot;&quot;</span><span class="p">)</span>
	<span class="n">left_siblings</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_left_siblings</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_left_siblings</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">right_siblings</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_right_siblings</span><span class="p">,</span>
			<span class="n">doc</span><span class="o">=</span><span class="n">_get_right_siblings</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
	<span class="n">roots</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_get_roots</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="n">_get_roots</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>

<div class="viewcode-block" id="MultiParentedTree.parent_indices"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.MultiParentedTree.parent_indices">[docs]</a>	<span class="k">def</span> <span class="nf">parent_indices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: list of indices where this tree occurs as child of parent.</span>

<span class="sd">		If this child does not occur as a child of parent, then the</span>
<span class="sd">		empty list is returned. The following is always true::</span>

<span class="sd">			for parent_index in ptree.parent_indices(parent):</span>
<span class="sd">				parent[parent_index] is ptree&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="n">parent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[]</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">index</span> <span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="MultiParentedTree.treepositions"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.MultiParentedTree.treepositions">[docs]</a>	<span class="k">def</span> <span class="nf">treepositions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">		:returns: a list of all tree positions that can be used to reach</span>
<span class="sd">			this multi-parented tree starting from root.</span>

<span class="sd">		i.e., the following holds::</span>

<span class="sd">			for treepos in ptree.treepositions(root):</span>
<span class="sd">				root[treepos] is ptree</span>
<span class="sd">		&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">root</span><span class="p">:</span>
			<span class="k">return</span> <span class="p">[()]</span>
		<span class="k">return</span> <span class="p">[</span><span class="n">treepos</span> <span class="o">+</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="p">)</span> <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parents</span>
				<span class="k">for</span> <span class="n">treepos</span> <span class="ow">in</span> <span class="n">parent</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="k">if</span> <span class="n">child</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">]</span>

	<span class="c"># === Parent Management ==========================================</span></div>
	<span class="k">def</span> <span class="nf">_delparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
		<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">MultiParentedTree</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="ow">is</span> <span class="n">child</span>
		<span class="k">assert</span> <span class="nb">len</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_parents</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span>
		<span class="c"># If the only copy of child in self is at index, then delete</span>
		<span class="c"># self from child&#39;s parent list.</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">c</span> <span class="ow">is</span> <span class="n">child</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">index</span><span class="p">:</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">_setparent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">_index</span><span class="p">,</span> <span class="n">dry_run</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">MultiParentedTree</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Cannot insert a non-MultiParentedTree &#39;</span>
					<span class="s">&#39;into a MultiParentedTree&#39;</span><span class="p">)</span>
		<span class="c"># Add self as a parent pointer if it&#39;s not already listed.</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">dry_run</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
					<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">child</span><span class="o">.</span><span class="n">_parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ImmutableMultiParentedTree"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.ImmutableMultiParentedTree">[docs]</a><span class="k">class</span> <span class="nc">ImmutableMultiParentedTree</span><span class="p">(</span><span class="n">ImmutableTree</span><span class="p">,</span> <span class="n">MultiParentedTree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Combination of an Immutable and Multi Parented Tree.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">children</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span>  <span class="c"># see note in Tree.__init__()</span>
		<span class="nb">super</span><span class="p">(</span><span class="n">ImmutableMultiParentedTree</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">label_or_str</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="slice_bounds"><a class="viewcode-back" href="../../api/discodop.tree.html#discodop.tree.slice_bounds">[docs]</a><span class="k">def</span> <span class="nf">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">slice_obj</span><span class="p">,</span> <span class="n">allow_step</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Calculate the effective (start, stop) bounds of a slice.</span>

<span class="sd">	Takes into account ``None`` indices and negative indices.</span>

<span class="sd">	:returns: tuple ``(start, stop, 1)``, s.t. ``0 &lt;= start &lt;= stop &lt;= len(seq)``</span>
<span class="sd">	:raises ValueError: if slice_obj.step is not None.</span>
<span class="sd">	:param allow_step: If true, then the slice object may have a non-None step.</span>
<span class="sd">		If it does, then return a tuple (start, stop, step).&quot;&quot;&quot;</span>
	<span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="o">=</span> <span class="p">(</span><span class="n">slice_obj</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">allow_step</span><span class="p">:</span>
		<span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span>
		<span class="c"># Use a recursive call without allow_step to find the slice</span>
		<span class="c"># bounds. If step is negative, then the roles of start and</span>
		<span class="c"># stop (in terms of default values, etc), are swapped.</span>
		<span class="k">if</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">stop</span><span class="p">,</span> <span class="n">start</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">slice_bounds</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span>
	<span class="k">elif</span> <span class="n">slice_obj</span><span class="o">.</span><span class="n">step</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;slices with steps are not supported by </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
				<span class="n">seq</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
	<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">start</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">stop</span>
	<span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">start</span><span class="p">)</span> <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">start</span>
	<span class="n">stop</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">+</span> <span class="n">stop</span><span class="p">)</span> <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">stop</span>
	<span class="k">if</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># Make sure stop doesn&#39;t go past the end of the list.</span>
		<span class="k">try</span><span class="p">:</span>  <span class="c"># Avoid calculating len(seq), may be expensive for lazy sequences</span>
			<span class="n">seq</span><span class="p">[</span><span class="n">stop</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
		<span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
			<span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
	<span class="n">start</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="mi">1</span>
</div>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Tree&#39;</span><span class="p">,</span> <span class="s">&#39;ImmutableTree&#39;</span><span class="p">,</span> <span class="s">&#39;ParentedTree&#39;</span><span class="p">,</span> <span class="s">&#39;ImmutableParentedTree&#39;</span><span class="p">,</span>
		<span class="s">&#39;MultiParentedTree&#39;</span><span class="p">,</span> <span class="s">&#39;ImmutableMultiParentedTree&#39;</span><span class="p">,</span> <span class="s">&#39;slice_bounds&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref.html">Reference</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../index.html">Disco-DOP 0.4.1pre1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>