<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.treebanktransforms &mdash; Disco-DOP 0.4.1pre1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.4.1pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.4.1pre1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../index.html">Disco-DOP 0.4.1pre1 documentation</a> &raquo;</li>
          <li><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for discodop.treebanktransforms</h1><div class="highlight"><pre>
<span class="c"># -*- coding: UTF-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Treebank transformations.</span>

<span class="sd">- generic transforms listed by name</span>
<span class="sd">- Relational-realizational transform</span>
<span class="sd">- reattaching punctuation&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span><span class="p">,</span> <span class="n">repeat</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span> <span class="k">as</span> <span class="n">multiset</span>
<span class="kn">from</span> <span class="nn">discodop.tree</span> <span class="kn">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">ParentedTree</span>

<span class="n">FIELDS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="n">WORD</span><span class="p">,</span> <span class="n">LEMMA</span><span class="p">,</span> <span class="n">TAG</span><span class="p">,</span> <span class="n">MORPH</span><span class="p">,</span> <span class="n">FUNC</span><span class="p">,</span> <span class="n">PARENT</span><span class="p">,</span> <span class="n">SECEDGETAG</span><span class="p">,</span> <span class="n">SECEDGEPARENT</span> <span class="o">=</span> <span class="n">FIELDS</span>
<span class="n">STATESPLIT</span> <span class="o">=</span> <span class="s">&#39;^&#39;</span>
<span class="n">LABELRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;[^^|&lt;&gt;-]+&quot;</span><span class="p">)</span>
<span class="n">HEADRULERE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;^(\S+)\s+(LEFT-TO-RIGHT|RIGHT-TO-LEFT)(?:\s+(.*))?$&#39;</span><span class="p">)</span>
<span class="n">NEGRATAGUNARY</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
		<span class="s">&#39;NN NNE PNC PRF PDS PIS PPER PPOS PRELS PWS&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="n">repeat</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">)))</span>
<span class="n">NEGRACONSTUNARY</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="s">&#39;CNP NM PN&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">(),</span> <span class="n">repeat</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">)))</span>
<span class="n">NUMBERRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;^[0-9]+(?:[,.][0-9]+)*$&#39;</span><span class="p">)</span>
<span class="n">DERE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;^([Dd]es?|du|d&#39;)$&quot;</span><span class="p">)</span>
<span class="n">PPORNP</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;^(NP|PP)+PP$&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="transform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.transform">[docs]</a><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">transformations</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Perform specified sequence of transformations on a tree.</span>

<span class="sd">	State-splits are preceded by &#39;^&#39;. ``transformations`` is a sequence of</span>
<span class="sd">	transformation names that will be performed on the given tree (in-place).</span>
<span class="sd">	Presets for particular treebanks:</span>

<span class="sd">	:negra:  ``transformations=(&#39;S-RC&#39;, &#39;VP-GF&#39;, &#39;NP&#39;, &#39;PUNCT&#39;)``</span>
<span class="sd">	:wsj:    ``transformations=(&#39;S-WH&#39;, &#39;VP-HD&#39;, &#39;S-INF&#39;)``</span>
<span class="sd">	:alpino: ``transformations=(&#39;PUNCT&#39;, )``</span>
<span class="sd">	:ftb:</span>
<span class="sd">			``transformations=(&#39;markinf markpart de2 markp1 mwadvs mwadvsel1 &#39;</span>
<span class="sd">			&#39;mwadvsel2 mwnsel1 mwnsel2 PUNCT tagpa&#39;).split()``&quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">transformations</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;APPEND-FUNC&#39;</span><span class="p">:</span>  <span class="c"># add function to phrasal label</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">func</span> <span class="o">!=</span> <span class="s">&#39;--&#39;</span><span class="p">:</span>
					<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="n">func</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FUNC-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/function above phrasal label</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">func</span> <span class="o">!=</span> <span class="s">&#39;--&#39;</span><span class="p">:</span>
					<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
							<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
					<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="n">func</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MORPH-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/morph. features above POS</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">morph</span> <span class="o">=</span> <span class="s">&#39;--&#39;</span>
				<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">morph</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">morph</span><span class="p">,</span>
						<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;LEMMA-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/lemma above terminal</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="kn">from</span> <span class="nn">discodop.treebank</span> <span class="kn">import</span> <span class="n">quote</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">lemma</span> <span class="o">=</span> <span class="s">&#39;--&#39;</span>
				<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">lemma</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">LEMMA</span><span class="p">])</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span>
						<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NP-PP&#39;</span><span class="p">:</span>  <span class="c"># mark PPs under NPs</span>
			<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span>
					<span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">):</span>
				<span class="n">pp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;NP&#39;</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FOLD-NUMBERS&#39;</span><span class="p">:</span>
			<span class="n">sent</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;000&#39;</span> <span class="k">if</span> <span class="n">NUMBERRE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sent</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">:</span>  <span class="c"># distinguish sentence-ending punctuation.</span>
			<span class="k">for</span> <span class="n">punct</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">in</span> <span class="s">&#39;.?!&#39;</span><span class="p">):</span>
				<span class="n">punct</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">sent</span><span class="p">[</span><span class="n">punct</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FANOUT&#39;</span><span class="p">:</span>  <span class="c"># add fan-out markers</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">addfanoutmarkers</span>
			<span class="n">addfanoutmarkers</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="k">elif</span> <span class="p">(</span><span class="n">negratransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
				<span class="ow">or</span> <span class="n">wsjtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
				<span class="ow">or</span> <span class="n">ftbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)):</span>
			<span class="k">pass</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;unrecognized transformation </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">tree</span>

</div>
<div class="viewcode-block" id="negratransforms"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.negratransforms">[docs]</a><span class="k">def</span> <span class="nf">negratransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">_sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Negra / Tiger transforms.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-RC&#39;</span><span class="p">:</span>  <span class="c"># relative clause =&gt; S becomes SRC</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;RC&#39;</span><span class="p">):</span>
			<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;RC&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">:</span>  <span class="c"># case</span>
		<span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">):</span>
			<span class="n">np</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PP-NP&#39;</span><span class="p">:</span>  <span class="c"># un-flatten PPs by introducing NPs</span>
		<span class="n">addtopp</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">,</span> <span class="p">)</span>
		<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span><span class="p">):</span>
			<span class="n">ac</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="n">addtopp</span><span class="p">]</span>
			<span class="c"># anything before an initial preposition goes to the PP</span>
			<span class="c"># (modifiers, punctuation), otherwise it goes to the NP;</span>
			<span class="c"># mutatis mutandis for postpositions.</span>
			<span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">]</span>
			<span class="k">if</span> <span class="s">&#39;AC&#39;</span> <span class="ow">in</span> <span class="n">functions</span> <span class="ow">and</span> <span class="s">&#39;NK&#39;</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">functions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">functions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;NK&#39;</span><span class="p">):</span>
					<span class="n">ac</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[:</span><span class="n">functions</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">)]</span>
				<span class="k">if</span> <span class="n">rindex</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rindex</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="s">&#39;NK&#39;</span><span class="p">):</span>
					<span class="n">ac</span> <span class="o">+=</span> <span class="n">pp</span><span class="p">[</span><span class="n">rindex</span><span class="p">(</span><span class="n">functions</span><span class="p">,</span> <span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
			<span class="c"># else:</span>
			<span class="c"># 	print(&#39;PP but no AC or NK&#39;, &#39; &#39;.join(functions))</span>
			<span class="n">nk</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ac</span><span class="p">]</span>
			<span class="c"># introduce a PP unless there is already an NP in the PP</span>
			<span class="c"># (annotation mistake?), or there is a PN and we want to avoid</span>
			<span class="c"># a cylic unary of NP -&gt; PN -&gt; NP.</span>
			<span class="k">if</span> <span class="n">ac</span> <span class="ow">and</span> <span class="n">nk</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
					<span class="ow">or</span> <span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">)):</span>
				<span class="n">pp</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">pp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ac</span> <span class="o">+</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="n">nk</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">:</span>  <span class="c"># introduce determiner phrases (DPs)</span>
		<span class="c"># determiners = set(&#39;ART PDS PDAT PIS PIAT PPOSAT PRELS PRELAT &#39;</span>
		<span class="c"># 	&#39;PWS PWAT PWAV&#39;.split())</span>
		<span class="n">determiners</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ART&#39;</span><span class="p">}</span>
		<span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">determiners</span><span class="p">:</span>
				<span class="n">np</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;DP&#39;</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;PN&#39;</span><span class="p">:</span>
					<span class="n">np1</span> <span class="o">=</span> <span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
					<span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="n">np1</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-GF&#39;</span><span class="p">:</span>  <span class="c"># VP category split based on head</span>
		<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
			<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_NEGRA&#39;</span><span class="p">:</span>  <span class="c"># introduce finite VP at S level</span>
		<span class="c"># collect objects and modifiers</span>
		<span class="c"># introduce new S level for discourse markers</span>
		<span class="n">newlevel</span> <span class="o">=</span> <span class="s">&#39;DM&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">addtovp</span> <span class="o">=</span> <span class="s">&#39;HD AC DA MO NG OA OA2 OC OG PD VO SVP&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

		<span class="k">def</span> <span class="nf">finitevp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
			<span class="sd">&quot;&quot;&quot;Introduce finite VPs grouping verbs and their objects.&quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;FIN&#39;</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)):</span>
				<span class="n">vp</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="n">addtovp</span><span class="p">]</span>
				<span class="c"># introduce a VP unless it would lead to a unary</span>
				<span class="c"># VP -&gt; VP production</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">vp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;VP&#39;</span><span class="p">:</span>
					<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">addtovp</span>
							<span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">vp</span><span class="p">]</span>
		<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="s">&#39;S&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
			<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">toplevel_s</span><span class="p">:</span>
				<span class="k">while</span> <span class="n">function</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">newlevel</span><span class="p">:</span>
					<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
					<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
					<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
		<span class="k">elif</span> <span class="s">&#39;CS&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
			<span class="n">cs</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;CS&#39;</span><span class="p">)]</span>
			<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">toplevel_s</span><span class="p">:</span>
			<span class="n">finitevp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;POS-PART&#39;</span><span class="p">:</span>  <span class="c"># introduce POS tag for particle verbs</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span>
				<span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;SVP&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)):</span>
			<span class="n">svp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;SVP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="c"># apparently there can be a _verb_ particle without a verb.</span>
			<span class="c"># headlines? annotation mistake?</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ishead</span><span class="p">,</span> <span class="n">a</span><span class="p">)):</span>
				<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
					<span class="n">particleverb</span> <span class="o">=</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="n">hd</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">hd</span><span class="p">,</span> <span class="n">svp</span><span class="p">])</span>
					<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">particleverb</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
										<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;SVP&#39;</span><span class="p">]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">:</span>  <span class="c"># introduce SBAR level</span>
		<span class="n">sbarfunc</span> <span class="o">=</span> <span class="s">&#39;CP&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="c"># in the annotation, complementizers belong to the first S</span>
		<span class="c"># in S conjunctions, even when they appear to apply to the whole</span>
		<span class="c"># conjunction.</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">sbarfunc</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
			<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;SBAR&#39;</span>
			<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NEST&#39;</span><span class="p">:</span>  <span class="c"># introduce nested structures for modifiers</span>
		<span class="c"># (iterated adjunction instead of sister adjunction)</span>
		<span class="n">adjunctable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>  <span class="c"># PP AP VP</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">adjunctable</span>
				<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">))):</span>
			<span class="n">modifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">modifiers</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">modifiers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="k">while</span> <span class="n">modifiers</span><span class="p">:</span>
				<span class="n">modifier</span> <span class="o">=</span> <span class="n">modifiers</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
						<span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">modifier</span><span class="p">]),</span> <span class="n">modifier</span><span class="p">]</span>
				<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;UNARY&#39;</span><span class="p">:</span>  <span class="c"># introduce phrasal projections for single tokens</span>
		<span class="c"># currently only adds NPs.</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>   <span class="c"># e.g. NN</span>
			<span class="n">const</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>  <span class="c"># e.g. S</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">NEGRATAGUNARY</span>
					<span class="ow">and</span> <span class="n">const</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">NEGRATAGUNARY</span><span class="p">[</span><span class="n">tag</span><span class="o">.</span><span class="n">label</span><span class="p">]):</span>
				<span class="c"># NN -&gt; NN -&gt; word</span>
				<span class="n">tag</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">]])]</span>
				<span class="c"># NP -&gt; NN -&gt; word</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">NEGRATAGUNARY</span><span class="p">[</span><span class="n">tag</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">tag</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
				<span class="c"># tag[0].source[FUNC] = &#39;NK&#39;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="wsjtransforms"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.wsjtransforms">[docs]</a><span class="k">def</span> <span class="nf">wsjtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">_sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Transforms for WSJ section of Penn treebank.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-WH&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">sbar</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sbar</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
						<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;WH&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)):</span>
					<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;WH&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-HD&#39;</span><span class="p">:</span>  <span class="c"># VP category split based on head</span>
		<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
			<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vp</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VB&#39;</span><span class="p">:</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HINF&#39;</span>
			<span class="k">elif</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;TO&#39;</span><span class="p">:</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HTO&#39;</span>
			<span class="k">elif</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;VBN&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">):</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HPART&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-INF&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
			<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;VP&#39;</span> <span class="o">+</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HINF&#39;</span><span class="p">,</span>
					<span class="s">&#39;VP&#39;</span> <span class="o">+</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HTO&#39;</span><span class="p">):</span>
				<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;INF&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_WSJ&#39;</span><span class="p">:</span>  <span class="c"># add disc. finite VP when verb is under S</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;VP&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">):</span>
				<span class="k">raise</span> <span class="ne">NotImplementedError</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MARK-UNARY&#39;</span><span class="p">:</span>  <span class="c"># add -U to unary nodes to avoid cycles</span>
		<span class="k">for</span> <span class="n">unary</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
			<span class="n">unary</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;U&#39;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="ftbtransforms"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.ftbtransforms">[docs]</a><span class="k">def</span> <span class="nf">ftbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Port of manual FTB enrichments specified in Stanford parser.</span>

<span class="sd">	cf. ``FrenchTreebankParserParams.java``&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markinf&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;V&quot;</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VPinf&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^infinitive&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markpart&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;V&quot;</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VPpart&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^participle&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markvn&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
				<span class="n">sub</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^withVN&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;tagpa&#39;</span><span class="p">:</span>  <span class="c"># Add parent annotation to POS tags</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
				<span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&quot;PUNC&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^&quot;</span> <span class="o">+</span> <span class="n">t</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;coord1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;COORD&#39;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^&quot;</span> <span class="o">+</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;de2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;P&#39;</span>
				<span class="ow">and</span> <span class="n">DERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^de2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;de3&#39;</span><span class="p">:</span>
		<span class="c"># @NP|PP|COORD &gt;+(@NP|PP) (@PP &lt;, (@P &lt; /^([Dd]es?|du|d&#39;)$/))</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
				<span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;PP&quot;</span><span class="p">,</span> <span class="s">&quot;COORD&quot;</span><span class="p">)):</span>
			<span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ancestors</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">PPORNP</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[:</span><span class="n">n</span><span class="p">])):</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
							<span class="ow">and</span> <span class="n">DERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])):</span>
						<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^de3&quot;</span>
						<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markp1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;PP&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;NP&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^n&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvs&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="s">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwadv-s&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvsel1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwadv1&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvsel2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;D&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwadv2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;A&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwn1&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwn2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel3&#39;</span><span class="p">:</span>  <span class="c"># noun-noun compound joined with dash.</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&quot;^mwn3&quot;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>

</div>
<div class="viewcode-block" id="reversetransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.reversetransform">[docs]</a><span class="k">def</span> <span class="nf">reversetransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">transformations</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Undo specified transformations and remove state splits marked by ``^``.</span>

<span class="sd">	Do not apply twice (might remove VPs which shouldn&#39;t be).&quot;&quot;&quot;</span>
	<span class="c"># Generic state-split removal</span>
	<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">STATESPLIT</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
		<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">[:</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">STATESPLIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>

	<span class="c"># restore linear precedence ordering</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
	<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">transformations</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FANOUT&#39;</span><span class="p">:</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">removefanoutmarkers</span>
			<span class="n">removefanoutmarkers</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">:</span>  <span class="c"># remove DPs</span>
			<span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">):</span>
				<span class="n">dp</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;NP&#39;</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">:</span>
					<span class="c"># dp1 = dp[1][:]</span>
					<span class="c"># dp[1][:] = []</span>
					<span class="c"># dp[1:] = dp1</span>
					<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][:],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NEST&#39;</span><span class="p">:</span>  <span class="c"># flatten adjunctions</span>
			<span class="n">nkonly</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s">&#39;PDAT CAP PPOSS PPOSAT ADJA FM PRF NM NN NE PIAT &#39;</span>
					<span class="s">&#39;PRELS PN TRUNC CH CNP PWAT PDS VP CS CARD ART PWS PPER&#39;</span>
					<span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
			<span class="n">probably_nk</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="s">&#39;AP PIS&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">|</span> <span class="n">nkonly</span>
			<span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
					<span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span>
					<span class="ow">and</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
					<span class="ow">and</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">probably_nk</span><span class="p">):</span>
				<span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
				<span class="n">np</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">np</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PP-NP&#39;</span><span class="p">:</span>  <span class="c"># flatten PPs</span>
			<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span><span class="p">):</span>
				<span class="k">if</span> <span class="s">&#39;NP&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&#39;NN&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">pp</span><span class="p">):</span>
					<span class="c"># ensure NP is in last position</span>
					<span class="n">pp</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
					<span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:],</span> <span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">:</span>  <span class="c"># merge extra S level</span>
			<span class="k">for</span> <span class="n">sbar</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span>
					<span class="ow">or</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
						<span class="ow">and</span> <span class="n">labels</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s">&#39;PTKANT&#39;</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">]))):</span>
				<span class="n">sbar</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span>
				<span class="k">if</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">:</span>
					<span class="n">sbar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">sbar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sbar</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_NEGRA&#39;</span><span class="p">:</span>
			<span class="k">def</span> <span class="nf">mergevp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
				<span class="sd">&quot;&quot;&quot;Merge finite VP with S level.&quot;&quot;&quot;</span>
				<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
					<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;FIN&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">]):</span>
						<span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">][:],</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">:</span><span class="n">vp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">][:]</span>
			<span class="c"># if any(a.label == &#39;S&#39; for a in tree):</span>
			<span class="c"># 	map(mergevp, [a for a in tree if a.label == &#39;S&#39;])</span>
			<span class="c"># elif any(a.label == &#39;CS&#39; for a in tree):</span>
			<span class="c"># 	map(mergevp, [s for cs in tree for s in cs if cs.label == &#39;CS&#39;</span>
			<span class="c"># 		and s.label == &#39;S&#39;])</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
				<span class="n">mergevp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;POS-PART&#39;</span><span class="p">:</span>
			<span class="c"># remove constituents for particle verbs</span>
			<span class="c"># get the grandfather of each verb particle</span>
			<span class="n">hasparticle</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="s">&#39;PTKVZ&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span>
					<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">m</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="n">hasparticle</span><span class="p">)):</span>
				<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
					<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
						<span class="ow">and</span> <span class="s">&#39;PTKVZ&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span>
							<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span>
						<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">)):</span>
						<span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;UNARY&#39;</span><span class="p">:</span>
			<span class="c"># remove phrasal projections for single tokens</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
				<span class="n">tag</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>    <span class="c"># NN</span>
				<span class="n">const</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>  <span class="c"># NP</span>
				<span class="n">parent</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">3</span><span class="p">]]</span>  <span class="c"># PP</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">const</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tag</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">NEGRATAGUNARY</span>
						<span class="ow">and</span> <span class="n">const</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">NEGRATAGUNARY</span><span class="p">[</span><span class="n">tag</span><span class="o">.</span><span class="n">label</span><span class="p">]):</span>
					<span class="n">parent</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]]</span> <span class="o">=</span> <span class="n">const</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
					<span class="k">del</span> <span class="n">const</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;APPEND-FUNC&#39;</span><span class="p">:</span>  <span class="c"># functions appended to phrasal labels</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
				<span class="k">if</span> <span class="s">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
					<span class="n">label</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FUNC-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with function above phrasal labels</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MORPH-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with morph. above preterminals</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;LEMMA-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with lemmas above words</span>
			<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">postorder</span>
			<span class="kn">from</span> <span class="nn">discodop.treebank</span> <span class="kn">import</span> <span class="n">unquote</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">postorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">LEMMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">unquote</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="c"># restore linear precedence ordering</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">tree</span>

</div>
<div class="viewcode-block" id="collapselabels"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.collapselabels">[docs]</a><span class="k">def</span> <span class="nf">collapselabels</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">_sents</span><span class="p">,</span> <span class="n">mapping</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Collapse non-root phrasal labels with specified mapping.</span>

<span class="sd">	The mapping is of the form::</span>

<span class="sd">		{coarselabel1: {finelabel1, finelabel2, ...}, ...}</span>

<span class="sd">	For example following Charniak et al. (2006),</span>
<span class="sd">	multi-level coarse-to-fine parsing:</span>
<span class="sd">	:level 0: single label P</span>
<span class="sd">	:level 1: HP, MP (arguments, modifiers)</span>
<span class="sd">	:level 2: S, N, A, P (verbal, nominal, adjectival, prepositional)</span>
<span class="sd">	:level 3: no-op, return original treebank labels&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">orig</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Collapse labels of a single tree; returns a new Tree object.&quot;&quot;&quot;</span>
		<span class="n">tree</span> <span class="o">=</span> <span class="n">orig</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">subtree</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
			<span class="k">if</span> <span class="n">subtree</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&quot;ROOT&quot;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subtree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="n">subtree</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">LABELRE</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">revmapping</span><span class="o">.</span><span class="n">get</span><span class="p">,</span> <span class="n">subtree</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>

	<span class="n">revmapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">finelabel</span><span class="p">:</span> <span class="n">coarselabel</span> <span class="k">for</span> <span class="n">coarselabel</span> <span class="ow">in</span> <span class="n">mapping</span>
			<span class="k">for</span> <span class="n">finelabel</span> <span class="ow">in</span> <span class="n">mapping</span><span class="p">[</span><span class="n">coarselabel</span><span class="p">]}</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">collapse</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="unifymorphfeat"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.unifymorphfeat">[docs]</a><span class="k">def</span> <span class="nf">unifymorphfeat</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Get the sorted union of features for a sequence of feature vectors.</span>

<span class="sd">	:param feats: a sequence of strings of comma/dot separated feature vectors.</span>
<span class="sd">	:param percolatefeatures: if a set is given, select only these features;</span>
<span class="sd">		by default all features are used.</span>

<span class="sd">	&gt;&gt;&gt; print(unifymorphfeat({&#39;Def.*.*&#39;, &#39;*.Sg.*&#39;, &#39;*.*.Akk&#39;}))</span>
<span class="sd">	Akk.Def.Sg</span>
<span class="sd">	&gt;&gt;&gt; print(unifymorphfeat({&#39;LID[bep,stan,rest]&#39;, &#39;N[soort,ev,zijd,stan]&#39;}))</span>
<span class="sd">	bep,ev,rest,soort,stan,zijd&quot;&quot;&quot;</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">feats</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;,&#39;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">feats</span><span class="p">:</span>
		<span class="k">if</span> <span class="s">&#39;[&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">)]</span>
		<span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">percolatefeatures</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">percolatefeatures</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span> <span class="o">-</span> <span class="p">{</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;--&#39;</span><span class="p">}))</span>

</div>
<div class="viewcode-block" id="rrtransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rrtransform">[docs]</a><span class="k">def</span> <span class="nf">rrtransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">morphlevels</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">adjunctionlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignorefunctions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignorecategories</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">adjleft</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">adjright</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Relational-realizational tree transformation.</span>

<span class="sd">	Every constituent node is expanded to three levels:</span>

<span class="sd">	1) syntactic category, e.g., S</span>
<span class="sd">	2) unordered functional argument structure of children, e.g., S/&lt;SBJ,HD,OBJ&gt;</span>
<span class="sd">	3) for each child:</span>
<span class="sd">		grammatical function + parent syntactic category, e.g., OBJ/S</span>

<span class="sd">	Example::</span>

<span class="sd">		(NP-SBJ (NN-HD ...)) =&gt; (NP (&lt;HD&gt;/NP (HD/NP (NN ...))))</span>

<span class="sd">	:param adjunctionlabel: a grammatical function label identifying</span>
<span class="sd">			adjunctions. They will not be part of argument structures, and</span>
<span class="sd">			their grammatical function will be replaced with their neighboring</span>
<span class="sd">			non-adjunctive functions.</span>
<span class="sd">	:param adjleft, adjright: whether to include the left and right sibling,</span>
<span class="sd">			respectively, when replacing the function label for</span>
<span class="sd">			``adjunctionlabel``.</span>
<span class="sd">	:param ignorefunctions: function labels that do not go into argument</span>
<span class="sd">			structure, but keep their function in their realization to make</span>
<span class="sd">			backtransform possible.</span>
<span class="sd">	:param morphlevels: if nonzero, percolate morphological features this many</span>
<span class="sd">			levels upwards. For a given node, the union of the features of its</span>
<span class="sd">			children are collected, and the result is appended to its syntactic</span>
<span class="sd">			category.</span>
<span class="sd">	:param percolatefeatures: if a sequence is given, percolate only these</span>
<span class="sd">			morphological features; by default all features are used.</span>
<span class="sd">	:returns: a new, transformed tree.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">realize</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Generate realization of a child node by recursion.&quot;&quot;&quot;</span>
		<span class="n">newchild</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">rrtransform</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">morphlevels</span><span class="p">,</span>
				<span class="n">percolatefeatures</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="p">,</span> <span class="n">ignorefunctions</span><span class="p">,</span>
				<span class="n">ignorecategories</span><span class="p">,</span> <span class="n">adjleft</span><span class="p">,</span> <span class="n">adjright</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">==</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="p">(</span><span class="n">prevfunc</span> <span class="ow">or</span> <span class="n">nextfunc</span><span class="p">)</span>
				<span class="k">else</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]),</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">),</span> <span class="p">[</span><span class="n">newchild</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span>

	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
		<span class="n">morph</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
		<span class="n">preterminal</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">morph</span><span class="p">),</span> <span class="n">tree</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">morphlevels</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">preterminal</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">morphlevels</span>
		<span class="k">return</span> <span class="n">preterminal</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span>
	<span class="c"># for each node, collect the functions of closest non-adjunctive sibling</span>
	<span class="n">childfuncsl</span> <span class="o">=</span> <span class="p">(</span><span class="n">prevfunc</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">):</span>
			<span class="n">prevfunc</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
		<span class="n">childfuncsl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prevfunc</span><span class="p">)</span>
	<span class="n">childfuncsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextfunc</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">):</span>
			<span class="n">nextfunc</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
		<span class="n">childfuncsr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">)</span>
	<span class="n">funcstr</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">))</span>
	<span class="n">children</span><span class="p">,</span> <span class="n">feats</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">childfuncsl</span><span class="p">,</span> <span class="n">childfuncsr</span><span class="p">):</span>
		<span class="n">newchild</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">realize</span><span class="p">(</span><span class="n">child</span><span class="p">,</span>
				<span class="n">prevfunc</span> <span class="k">if</span> <span class="n">adjleft</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">,</span>
				<span class="n">nextfunc</span> <span class="k">if</span> <span class="n">adjright</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
		<span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">morph</span> <span class="ow">and</span> <span class="n">lvl</span><span class="p">:</span>
			<span class="n">feats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morph</span><span class="p">)</span>
			<span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lvl</span><span class="p">)</span>
	<span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="n">feats</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;ROOT&#39;</span><span class="p">:</span>
		<span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">unifymorphfeat</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="n">configuration</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/&lt;</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">funcstr</span><span class="p">),</span>
			<span class="n">children</span><span class="p">)</span>
	<span class="n">projection</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">morph</span><span class="p">))</span> <span class="k">if</span> <span class="n">morph</span>
			<span class="k">else</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">configuration</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">projection</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span>

</div>
<div class="viewcode-block" id="rrbacktransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rrbacktransform">[docs]</a><span class="k">def</span> <span class="nf">rrbacktransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Reverse relational-realizational transformation.</span>

<span class="sd">	:param adjunctionlabel: used to assign a grammatical function to</span>
<span class="sd">		adjunctions that have been converted to contextual labels &#39;next:prev&#39;.</span>
<span class="sd">	:param func: used internally to percolate functional labels.</span>
<span class="sd">	:returns: a new tree.&quot;&quot;&quot;</span>
	<span class="n">morph</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
		<span class="n">tag</span><span class="p">,</span> <span class="n">morph</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
	<span class="k">elif</span> <span class="s">&#39;/&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
				<span class="p">[</span><span class="n">rrbacktransform</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
				<span class="p">[</span><span class="n">rrbacktransform</span><span class="p">(</span>
						<span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">adjunctionlabel</span><span class="p">,</span>
						<span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
	<span class="n">result</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">8</span>
	<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">label</span>
	<span class="k">if</span> <span class="n">morph</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">,</span> <span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">,</span> <span class="s">&#39;)&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">adjunctionlabel</span> <span class="ow">and</span> <span class="s">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">func</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjunctionlabel</span>
	<span class="k">elif</span> <span class="n">func</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
	<span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="removeterminals"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.removeterminals">[docs]</a><span class="k">def</span> <span class="nf">removeterminals</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Remove any terminals for which func is True, and any empty ancestors.&quot;&quot;&quot;</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">)):</span>
		<span class="k">if</span> <span class="n">func</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">]],</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">del</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">]]</span>
				<span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]]:</span>
					<span class="k">break</span>
	<span class="c"># renumber</span>
	<span class="n">oldleaves</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
	<span class="n">newleaves</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">:</span> <span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">oldleaves</span><span class="p">)}</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
		<span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">newleaves</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">]]</span>
	<span class="k">assert</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">()))),</span> <span class="n">tree</span>

</div>
<div class="viewcode-block" id="removeemptynodes"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.removeemptynodes">[docs]</a><span class="k">def</span> <span class="nf">removeemptynodes</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Remove any empty nodes, and any empty ancestors.&quot;&quot;&quot;</span>
	<span class="n">removeterminals</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;-NONE-&#39;</span><span class="p">))</span>


<span class="c"># fixme: treebank specific parameters for detecting punctuation.</span></div>
<span class="n">PUNCTTAGS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;&#39;&#39;&quot;</span><span class="p">,</span> <span class="s">&#39;``&#39;</span><span class="p">,</span> <span class="s">&#39;-LRB-&#39;</span><span class="p">,</span> <span class="s">&#39;-RRB-&#39;</span><span class="p">,</span> <span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;:&#39;</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="p">,</span>  <span class="c"># PTB</span>
		<span class="s">&#39;$,&#39;</span><span class="p">,</span> <span class="s">&#39;$.&#39;</span><span class="p">,</span> <span class="s">&#39;$[&#39;</span><span class="p">,</span> <span class="s">&#39;$(&#39;</span><span class="p">,</span>  <span class="c"># Negra/Tiger</span>
		<span class="s">&#39;let&#39;</span><span class="p">,</span> <span class="s">&#39;LET[]&#39;</span><span class="p">,</span> <span class="s">&#39;SPEC[symb]&#39;</span><span class="p">,</span> <span class="s">&#39;TW[hoofd,vrij]&#39;</span><span class="p">,</span>  <span class="c"># Alpino/Lassy</span>
		<span class="s">&#39;COMMA&#39;</span><span class="p">,</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">,</span> <span class="s">&#39;PAREN&#39;</span><span class="p">}</span>  <span class="c"># Grammatical Framework</span>
<span class="n">PUNCTUATION</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="s">u&#39;.,():-&quot;;?/!*&amp;`[]&lt;&gt;{}|=</span><span class="se">\&#39;\xc2\xab\xc2\xbb\xb7\xad\\</span><span class="s">&#39;</span>
		<span class="p">)</span> <span class="o">|</span> <span class="p">{</span><span class="s">u&#39;&amp;bullet;&#39;</span><span class="p">,</span> <span class="s">u&#39;..&#39;</span><span class="p">,</span> <span class="s">u&#39;...&#39;</span><span class="p">,</span> <span class="s">u&#39;....&#39;</span><span class="p">,</span> <span class="s">u&#39;.....&#39;</span><span class="p">,</span> <span class="s">u&#39;......&#39;</span><span class="p">,</span>
		<span class="s">u&#39;!!&#39;</span><span class="p">,</span> <span class="s">u&#39;!!!&#39;</span><span class="p">,</span> <span class="s">u&#39;??&#39;</span><span class="p">,</span> <span class="s">u&#39;???&#39;</span><span class="p">,</span> <span class="s">u&quot;&#39;&#39;&quot;</span><span class="p">,</span> <span class="s">u&#39;``&#39;</span><span class="p">,</span> <span class="s">u&#39;,,&#39;</span><span class="p">,</span>
		<span class="s">u&#39;--&#39;</span><span class="p">,</span> <span class="s">u&#39;---&#39;</span><span class="p">,</span> <span class="s">u&#39;----&#39;</span><span class="p">,</span> <span class="s">u&#39;-LRB-&#39;</span><span class="p">,</span> <span class="s">u&#39;-RRB-&#39;</span><span class="p">,</span> <span class="s">u&#39;-LCB-&#39;</span><span class="p">,</span> <span class="s">u&#39;-RCB-&#39;</span><span class="p">}</span>


<div class="viewcode-block" id="ispunct"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.ispunct">[docs]</a><span class="k">def</span> <span class="nf">ispunct</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">tag</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Test whether a word and/or tag is punctuation.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">PUNCTTAGS</span> <span class="ow">or</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">PUNCTUATION</span>

</div>
<div class="viewcode-block" id="punctremove"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.punctremove">[docs]</a><span class="k">def</span> <span class="nf">punctremove</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Remove any punctuation nodes, and any empty ancestors.&quot;&quot;&quot;</span>
	<span class="n">removeterminals</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">ispunct</span><span class="p">)</span>

</div>
<span class="k">def</span> <span class="nf">punctroot</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Move punctuation directly under ROOT, as in the Negra annotation.&quot;&quot;&quot;</span>
	<span class="n">punct</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">)):</span>
		<span class="k">if</span> <span class="n">ispunct</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">]],</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
			<span class="c"># store punctuation node</span>
			<span class="n">punct</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
			<span class="c"># remove this punctuation node and any empty ancestors</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">del</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="n">n</span><span class="p">]]</span>
				<span class="k">if</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]]:</span>
					<span class="k">break</span>
	<span class="n">tree</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">punct</span><span class="p">)</span>


<div class="viewcode-block" id="punctlower"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.punctlower">[docs]</a><span class="k">def</span> <span class="nf">punctlower</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Find suitable constituent for punctuation marks and add it there.</span>

<span class="sd">	Initial candidate is the root node. Note that ``punctraise()`` performs</span>
<span class="sd">	better. Based on rparse code.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">lower</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">candidate</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Lower a specific instance of punctuation in tree.</span>

<span class="sd">		Recurses top-down on suitable candidates.&quot;&quot;&quot;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">leaves</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">leaves</span><span class="p">())):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">continue</span>
			<span class="n">termdom</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">termdom</span><span class="p">):</span>
				<span class="n">candidate</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
				<span class="k">break</span>
			<span class="k">elif</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">termdom</span><span class="p">):</span>
				<span class="n">lower</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">)</span>
				<span class="k">break</span>

	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">treepositions</span><span class="p">(</span><span class="s">&#39;leaves&#39;</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">ispunct</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">]],</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
			<span class="k">del</span> <span class="n">tree</span><span class="p">[</span><span class="n">a</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
			<span class="n">lower</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="punctraise"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.punctraise">[docs]</a><span class="k">def</span> <span class="nf">punctraise</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">rootpreterms</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Attach punctuation nodes to an appropriate constituent.</span>

<span class="sd">	Trees in the Negra corpus have punctuation attached to the root;</span>
<span class="sd">	i.e., it is not part of the phrase-structure. This function moves the</span>
<span class="sd">	punctuation to an appropriate level in the tree. A punctuation node is a</span>
<span class="sd">	POS tag with a punctuation terminal. Modifies trees in-place.</span>

<span class="sd">	:param rootpreterms: if True, move all preterminals under root,</span>
<span class="sd">		instead of only recognized punctuation.&quot;&quot;&quot;</span>
	<span class="c"># punct = [node for node in tree.subtrees() if isinstance(node[0], int)</span>
	<span class="n">punct</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
			<span class="ow">and</span> <span class="p">(</span><span class="n">rootpreterms</span> <span class="ow">or</span> <span class="n">ispunct</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">))]</span>
	<span class="k">while</span> <span class="n">punct</span><span class="p">:</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">punct</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
		<span class="k">while</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="n">tree</span><span class="p">:</span>
			<span class="k">continue</span>
		<span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent_index</span><span class="p">)</span>
		<span class="n">phrasalnode</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="n">phrasalnode</span><span class="p">):</span>
			<span class="c"># add punctuation mark to highest left/right neighbor</span>
			<span class="c"># if any(node[0] - 1 == max(a.leaves()) for a in candidate):</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">candidate</span><span class="p">):</span>
				<span class="n">candidate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
				<span class="k">break</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">tree</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</div>
<span class="n">BALANCEDPUNCTMATCH</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;&quot;&#39;</span><span class="p">:</span> <span class="s">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">:</span> <span class="s">&#39;]&#39;</span><span class="p">,</span> <span class="s">&#39;(&#39;</span><span class="p">:</span> <span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;-LRB-&#39;</span><span class="p">:</span> <span class="s">&#39;-RRB-&#39;</span><span class="p">,</span>
		<span class="s">&#39;-&#39;</span><span class="p">:</span> <span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;&quot;</span><span class="p">:</span> <span class="s">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\xc2\xab</span><span class="s">&#39;</span><span class="p">:</span> <span class="s">&#39;</span><span class="se">\xc2\xbb</span><span class="s">&#39;</span><span class="p">}</span>  <span class="c"># unicode &lt;&lt; and &gt;&gt;</span>


<div class="viewcode-block" id="balancedpunctraise"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.balancedpunctraise">[docs]</a><span class="k">def</span> <span class="nf">balancedpunctraise</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Move balanced punctuation ``&quot; &#39; - ( ) [ ]`` to a common constituent.</span>

<span class="sd">	Based on rparse code.&quot;&quot;&quot;</span>
	<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">ParentedTree</span><span class="p">)</span>
	<span class="c"># right punct str as key, mapped to left index as value</span>
	<span class="n">punctmap</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="c"># punctuation indices mapped to preterminal nodes</span>
	<span class="n">termparent</span> <span class="o">=</span> <span class="p">{</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">a</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ispunct</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)}</span>
	<span class="k">for</span> <span class="n">terminal</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">termparent</span><span class="p">):</span>
		<span class="n">preterminal</span> <span class="o">=</span> <span class="n">termparent</span><span class="p">[</span><span class="n">terminal</span><span class="p">]</span>
		<span class="c"># do we know the matching punctuation mark for this one?</span>
		<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">terminal</span><span class="p">]</span> <span class="ow">in</span> <span class="n">punctmap</span><span class="p">:</span>
			<span class="n">right</span> <span class="o">=</span> <span class="n">terminal</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">punctmap</span><span class="p">[</span><span class="n">sent</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span>
			<span class="n">rightparent</span> <span class="o">=</span> <span class="n">preterminal</span><span class="o">.</span><span class="n">parent</span>
			<span class="n">leftparent</span> <span class="o">=</span> <span class="n">termparent</span><span class="p">[</span><span class="n">left</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span>
			<span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">leftparent</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span> <span class="o">==</span> <span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">termparent</span><span class="p">[</span><span class="n">right</span><span class="p">]</span>
				<span class="n">leftparent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent_index</span><span class="p">))</span>
			<span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">rightparent</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span> <span class="o">==</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">termparent</span><span class="p">[</span><span class="n">left</span><span class="p">]</span>
				<span class="n">rightparent</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent_index</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="ow">in</span> <span class="n">punctmap</span><span class="p">:</span>
				<span class="k">del</span> <span class="n">punctmap</span><span class="p">[</span><span class="n">sent</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span>
		<span class="k">elif</span> <span class="n">sent</span><span class="p">[</span><span class="n">terminal</span><span class="p">]</span> <span class="ow">in</span> <span class="n">BALANCEDPUNCTMATCH</span><span class="p">:</span>
			<span class="n">punctmap</span><span class="p">[</span><span class="n">BALANCEDPUNCTMATCH</span><span class="p">[</span><span class="n">sent</span><span class="p">[</span><span class="n">terminal</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">terminal</span>

</div>
<div class="viewcode-block" id="function"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.function">[docs]</a><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: grammatical function for node, or an empty string.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
		<span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">return</span> <span class="s">&#39;&#39;</span>

</div>
<div class="viewcode-block" id="ishead"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.ishead">[docs]</a><span class="k">def</span> <span class="nf">ishead</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Test whether this node is the head of the parent constituent.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
		<span class="k">return</span> <span class="s">&#39;HD&#39;</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="rindex"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rindex">[docs]</a><span class="k">def</span> <span class="nf">rindex</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Like list.index(), but go from right to left.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="labels"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.labels">[docs]</a><span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: the labels of the children of this node.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)]</span>

</div>
<div class="viewcode-block" id="pop"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.pop">[docs]</a><span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Remove this node from its parent node, if it has one.</span>

<span class="sd">	Convenience function for ParentedTrees.&quot;&quot;&quot;</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">parent_index</span><span class="p">)</span>
	<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">a</span>

</div>
<div class="viewcode-block" id="strip"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.strip">[docs]</a><span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Equivalent to the effect of the @ operator in tregex.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="n">label</span><span class="p">[:</span><span class="n">label</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&quot;^&quot;</span><span class="p">)]</span> <span class="k">if</span> <span class="s">&quot;^&quot;</span> <span class="ow">in</span> <span class="n">label</span> <span class="k">else</span> <span class="n">label</span>

</div>
<div class="viewcode-block" id="ancestors"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.ancestors">[docs]</a><span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Yield ancestors of node from direct parent to root node.&quot;&quot;&quot;</span>
	<span class="k">while</span> <span class="n">node</span><span class="p">:</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">yield</span> <span class="n">node</span>

</div>
<div class="viewcode-block" id="bracketings"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.bracketings">[docs]</a><span class="k">def</span> <span class="nf">bracketings</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Labeled bracketings of a tree.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">leaves</span><span class="p">())))</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">))]</span>

</div>
<div class="viewcode-block" id="readheadrules"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.readheadrules">[docs]</a><span class="k">def</span> <span class="nf">readheadrules</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Read a file containing heuristic rules for head assignment.</span>

<span class="sd">	Example line: ``s right-to-left vmfin vafin vaimp``, which means</span>
<span class="sd">	traverse siblings of an S constituent from right to left, the first child</span>
<span class="sd">	with a label of vmfin, vafin, or vaimp will be marked as head.&quot;&quot;&quot;</span>
	<span class="n">headrules</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
		<span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">line</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&quot;%&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">label</span><span class="p">,</span> <span class="n">lr</span><span class="p">,</span> <span class="n">heads</span> <span class="o">=</span> <span class="n">HEADRULERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
			<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
				<span class="k">print</span><span class="p">(</span><span class="s">&#39;no match:&#39;</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
				<span class="k">raise</span>
			<span class="k">if</span> <span class="n">heads</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
				<span class="n">heads</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
			<span class="n">headrules</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lr</span><span class="p">,</span> <span class="n">heads</span><span class="o">.</span><span class="n">split</span><span class="p">()))</span>
	<span class="k">return</span> <span class="n">headrules</span>

</div>
<div class="viewcode-block" id="headfinder"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.headfinder">[docs]</a><span class="k">def</span> <span class="nf">headfinder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">headrules</span><span class="p">,</span> <span class="n">headlabels</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">({</span><span class="s">&#39;HD&#39;</span><span class="p">})):</span>
	<span class="sd">&quot;&quot;&quot;Use head finding rules to select one child of tree as head.&quot;&quot;&quot;</span>
	<span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
			<span class="ow">and</span> <span class="n">headlabels</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">))]</span>
	<span class="k">if</span> <span class="n">candidates</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">candidates</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
	<span class="k">for</span> <span class="n">lr</span><span class="p">,</span> <span class="n">heads</span> <span class="ow">in</span> <span class="n">headrules</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[]):</span>
		<span class="k">if</span> <span class="n">lr</span> <span class="o">==</span> <span class="s">&#39;LEFT-TO-RIGHT&#39;</span><span class="p">:</span>
			<span class="n">children</span> <span class="o">=</span> <span class="n">tree</span>
		<span class="k">elif</span> <span class="n">lr</span> <span class="o">==</span> <span class="s">&#39;RIGHT-TO-LEFT&#39;</span><span class="p">:</span>
			<span class="n">children</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;expected RIGHT-TO-LEFT or LEFT-TO-RIGHT.&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">head</span> <span class="ow">in</span> <span class="n">heads</span><span class="p">:</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
						<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">head</span><span class="p">):</span>
					<span class="k">return</span> <span class="n">child</span>
	<span class="c"># default head is initial/last nonterminal (depending on direction lr)</span>
	<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">child</span>

</div>
<div class="viewcode-block" id="sethead"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.sethead">[docs]</a><span class="k">def</span> <span class="nf">sethead</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Mark node as head in an auxiliary field.&quot;&quot;&quot;</span>
	<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&quot;source&quot;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="mi">6</span> <span class="o">*</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
		<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span>
	<span class="k">if</span> <span class="s">&#39;HD&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">):</span>
		<span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;--&#39;</span><span class="p">):</span>
			<span class="n">x</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;-HD&#39;</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">x</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">+</span> <span class="s">&#39;-HD&#39;</span>
		<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="headmark"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.headmark">[docs]</a><span class="k">def</span> <span class="nf">headmark</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Add marker to label of head node.&quot;&quot;&quot;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
			<span class="ow">and</span> <span class="s">&#39;HD&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)]</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="n">head</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&#39;-HD&#39;</span>

</div>
<div class="viewcode-block" id="headorder"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.headorder">[docs]</a><span class="k">def</span> <span class="nf">headorder</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">headfinal</span><span class="p">,</span> <span class="n">reverse</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Order constituents based on head (identified with function tag).&quot;&quot;&quot;</span>
	<span class="n">head</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
		<span class="ow">and</span> <span class="s">&#39;HD&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">)]</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">head</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="n">headidx</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
	<span class="c"># everything until the head is reversed and prepended to the rest,</span>
	<span class="c"># leaving the head as the first element</span>
	<span class="n">nodes</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[:]</span>
	<span class="n">tree</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">if</span> <span class="n">headfinal</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>  <span class="c"># head final, reverse rhs: A B C^ D E =&gt; A B E D C^</span>
			<span class="n">tree</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:</span><span class="n">headidx</span><span class="p">]</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="n">headidx</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># head final, reverse lhs:  A B C^ D E =&gt; E D A B C^</span>
			<span class="n">tree</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">headidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[:</span><span class="n">headidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>  <span class="c"># head first, reverse lhs: A B C^ D E =&gt; C^ B A D E</span>
			<span class="n">tree</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[:</span><span class="n">headidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[</span><span class="n">headidx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># head first, reverse rhs: A B C^ D E =&gt; C^ D E B A</span>
			<span class="n">tree</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">headidx</span><span class="p">:]</span> <span class="o">+</span> <span class="n">nodes</span><span class="p">[:</span><span class="n">headidx</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="saveheads"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.saveheads">[docs]</a><span class="k">def</span> <span class="nf">saveheads</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">tailmarker</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Store head as grammatical function when inferrable from binarization.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">tailmarker</span><span class="p">:</span>
		<span class="k">return</span>
	<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">tailmarker</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
		<span class="n">node</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
		<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HD&#39;</span>

</div>
<div class="viewcode-block" id="headstats"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.headstats">[docs]</a><span class="k">def</span> <span class="nf">headstats</span><span class="p">(</span><span class="n">trees</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Collect some information useful for writing headrules.</span>

<span class="sd">	- ``heads[&#39;NP&#39;][&#39;NN&#39;] ==`` number of times NN occurs as head of NP.</span>
<span class="sd">	- ``pos1[&#39;NP&#39;][1] ==`` number of times head of NP is at position 1.</span>
<span class="sd">	- ``pos2`` is like pos1, but position is from the right.</span>
<span class="sd">	- ``unknown[&#39;NP&#39;][&#39;NN&#39;] ==`` number of times NP that does not have a head</span>
<span class="sd">		dominates an NN.&quot;&quot;&quot;</span>
	<span class="n">heads</span><span class="p">,</span> <span class="n">unknown</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">multiset</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">multiset</span><span class="p">)</span>
	<span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">multiset</span><span class="p">),</span> <span class="n">defaultdict</span><span class="p">(</span><span class="n">multiset</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
				<span class="k">if</span> <span class="s">&#39;hd&#39;</span> <span class="ow">in</span> <span class="n">b</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
					<span class="n">heads</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">][</span><span class="n">b</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="n">pos1</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">][</span><span class="n">n</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="n">pos2</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">+=</span> <span class="mi">1</span>
					<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">unknown</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">a</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">heads</span><span class="p">,</span> <span class="n">unknown</span><span class="p">,</span> <span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span>

</div>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;transform&#39;</span><span class="p">,</span> <span class="s">&#39;negratransforms&#39;</span><span class="p">,</span> <span class="s">&#39;wsjtransforms&#39;</span><span class="p">,</span> <span class="s">&#39;ftbtransforms&#39;</span><span class="p">,</span>
		<span class="s">&#39;reversetransform&#39;</span><span class="p">,</span> <span class="s">&#39;collapselabels&#39;</span><span class="p">,</span> <span class="s">&#39;unifymorphfeat&#39;</span><span class="p">,</span> <span class="s">&#39;rrtransform&#39;</span><span class="p">,</span>
		<span class="s">&#39;rrbacktransform&#39;</span><span class="p">,</span> <span class="s">&#39;removeterminals&#39;</span><span class="p">,</span> <span class="s">&#39;removeemptynodes&#39;</span><span class="p">,</span> <span class="s">&#39;ispunct&#39;</span><span class="p">,</span>
		<span class="s">&#39;punctremove&#39;</span><span class="p">,</span> <span class="s">&#39;punctremove&#39;</span><span class="p">,</span> <span class="s">&#39;punctlower&#39;</span><span class="p">,</span> <span class="s">&#39;punctraise&#39;</span><span class="p">,</span>
		<span class="s">&#39;balancedpunctraise&#39;</span><span class="p">,</span> <span class="s">&#39;function&#39;</span><span class="p">,</span> <span class="s">&#39;ishead&#39;</span><span class="p">,</span> <span class="s">&#39;rindex&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;pop&#39;</span><span class="p">,</span>
		<span class="s">&#39;strip&#39;</span><span class="p">,</span> <span class="s">&#39;ancestors&#39;</span><span class="p">,</span> <span class="s">&#39;bracketings&#39;</span><span class="p">,</span> <span class="s">&#39;readheadrules&#39;</span><span class="p">,</span> <span class="s">&#39;headfinder&#39;</span><span class="p">,</span>
		<span class="s">&#39;sethead&#39;</span><span class="p">,</span> <span class="s">&#39;headmark&#39;</span><span class="p">,</span> <span class="s">&#39;headorder&#39;</span><span class="p">,</span> <span class="s">&#39;saveheads&#39;</span><span class="p">,</span> <span class="s">&#39;headstats&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref.html">Reference</a></li>
</ul>

<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li><a href="../../index.html">Disco-DOP 0.4.1pre1 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>