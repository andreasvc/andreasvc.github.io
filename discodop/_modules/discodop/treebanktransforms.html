<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.treebanktransforms &mdash; Disco-DOP 0.5pre1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.5pre1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for discodop.treebanktransforms</h1><div class="highlight"><pre>
<span class="c"># -*- coding: UTF-8 -*-</span>
<span class="sd">&quot;&quot;&quot;Treebank transformations.</span>

<span class="sd">- Transforms (primarily state splits) listed by name</span>
<span class="sd">- Relational-realizational transform</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> \
		<span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">islice</span>
<span class="kn">from</span> <span class="nn">discodop.tree</span> <span class="kn">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">ParentedTree</span>
<span class="kn">from</span> <span class="nn">discodop.treebank</span> <span class="kn">import</span> <span class="n">quote</span><span class="p">,</span> <span class="n">unquote</span>
<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">addfanoutmarkers</span><span class="p">,</span> <span class="n">removefanoutmarkers</span>
<span class="kn">from</span> <span class="nn">discodop.heads</span> <span class="kn">import</span> <span class="n">ishead</span>
<span class="kn">from</span> <span class="nn">discodop.punctuation</span> <span class="kn">import</span> <span class="n">punctprune</span><span class="p">,</span> <span class="n">PUNCTUATION</span>

<span class="n">FIELDS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="n">WORD</span><span class="p">,</span> <span class="n">LEMMA</span><span class="p">,</span> <span class="n">TAG</span><span class="p">,</span> <span class="n">MORPH</span><span class="p">,</span> <span class="n">FUNC</span><span class="p">,</span> <span class="n">PARENT</span> <span class="o">=</span> <span class="n">FIELDS</span>
<span class="n">STATESPLIT</span> <span class="o">=</span> <span class="s">&#39;^&#39;</span>
<span class="n">LABELRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;[^^|&lt;&gt;,;:_-]+&quot;</span><span class="p">)</span>
<span class="n">CASERE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\b(Nom|Acc|Gen|Dat)\b&#39;</span><span class="p">)</span>
<span class="n">DERE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&quot;^([Dd]es?|du|d&#39;)$&quot;</span><span class="p">)</span>
<span class="n">PPORNP</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;^(NP|PP)+PP$&#39;</span><span class="p">)</span>
<span class="n">YEARRE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">&#39;^(?:19|20)[0-9]{2}$&#39;</span><span class="p">)</span>
<span class="n">PRESETS</span> <span class="o">=</span> <span class="p">{</span>
		<span class="c"># basic state splits:</span>
		<span class="s">&#39;negra&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;S-RC&#39;</span><span class="p">,</span> <span class="s">&#39;VP-GF&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">),</span>
		<span class="s">&#39;wsj&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;S-WH&#39;</span><span class="p">,</span> <span class="s">&#39;VP-HD&#39;</span><span class="p">,</span> <span class="s">&#39;S-INF&#39;</span><span class="p">),</span>
		<span class="s">&#39;alpino&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;PUNCT&#39;</span><span class="p">,</span> <span class="p">),</span>
		<span class="c"># extensive state splits following particular papers:</span>
		<span class="s">&#39;green2013ftb&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;markinf,markpart,de2,markp1,mwadvs,mwadvsel1,&#39;</span>
			<span class="s">&#39;mwadvsel2,mwnsel1,mwnsel2,PUNCT,TAGPA&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">),</span>
		<span class="c"># These are the &quot;-goodPCFG&quot; options of the Stanford Parser</span>
		<span class="s">&#39;km2003wsj&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;splitIN4,splitPercent,splitPoss,splitCC,unaryDT,&#39;</span>
			<span class="s">&#39;unaryRB,splitAux2,splitVP3,splitSGapped,splitTMP,splitBaseNP,&#39;</span>
			<span class="s">&#39;dominatesV,splitNPADV,markDitransV,MARK-YEAR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">),</span>
		<span class="s">&#39;km2003simple&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;splitIN4,splitPercent,splitPoss,splitCC,unaryDT,&#39;</span>
			<span class="s">&#39;unaryRB,splitAux2,splitSGapped,splitBaseNP,dominatesV,&#39;</span>
			<span class="s">&#39;splitNPADV,markDitransV,MARK-YEAR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">),</span>
		<span class="s">&#39;fraser2013tiger&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;elimNKCJ,addUnary,APPEND-FUNC,addCase,lexPrep,&#39;</span>
			<span class="s">&#39;PUNCT,adjAttach,relPath,whFeat,nounSeq,properChunks,markAP,&#39;</span>
			<span class="s">&#39;subConjType,VPfeat,noHead,noSubj,MARK-YEAR&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">),</span>
		<span class="s">&#39;lassy&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;nlselectmorph&#39;</span><span class="p">,</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">,</span> <span class="s">&#39;MARK-YEAR&#39;</span><span class="p">,</span> <span class="s">&#39;nlpercolatemorph&#39;</span><span class="p">,</span>
			<span class="s">&#39;nlmwuhead&#39;</span><span class="p">,</span> <span class="s">&#39;nladdunary&#39;</span><span class="p">,</span> <span class="s">&#39;nlelimcnj&#39;</span><span class="p">),</span>
		<span class="c"># this variant adds function tags to non-terminal labels</span>
		<span class="s">&#39;lassy-func&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s">&#39;nladdunary&#39;</span><span class="p">,</span> <span class="s">&#39;nlelimcnj&#39;</span><span class="p">,</span> <span class="s">&#39;APPEND-FUNC&#39;</span><span class="p">,</span>
			<span class="s">&#39;nlselectmorph&#39;</span><span class="p">,</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">,</span> <span class="s">&#39;MARK-YEAR&#39;</span><span class="p">,</span> <span class="s">&#39;nlpercolatemorph&#39;</span><span class="p">,</span>
			<span class="s">&#39;nlmwuhead&#39;</span><span class="p">)</span>
		<span class="p">}</span>

<span class="c"># Mappings for multi-level coarse-to-fine parsing</span>
<span class="c"># following Charniak et al. (2006), multi-level coarse-to-fine parsing.</span>
<span class="n">MAPPINGS</span> <span class="o">=</span> <span class="p">{</span>
		<span class="s">&#39;ptb&#39;</span><span class="p">:</span> <span class="p">{</span>
			<span class="c"># level 0: P (all phrase labels)</span>
			<span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;P&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;UCP&#39;</span><span class="p">,</span> <span class="s">&#39;SQ&#39;</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">,</span> <span class="s">&#39;SBARQ&#39;</span><span class="p">,</span> <span class="s">&#39;SINV&#39;</span><span class="p">,</span>
					<span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;NAC&#39;</span><span class="p">,</span> <span class="s">&#39;NX&#39;</span><span class="p">,</span> <span class="s">&#39;LST&#39;</span><span class="p">,</span> <span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;FRAG&#39;</span><span class="p">,</span> <span class="s">&#39;PRT|ADVP&#39;</span><span class="p">,</span>
					<span class="s">&#39;ADJP&#39;</span><span class="p">,</span> <span class="s">&#39;QP&#39;</span><span class="p">,</span> <span class="s">&#39;CONJP&#39;</span><span class="p">,</span> <span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;INTJ&#39;</span><span class="p">,</span> <span class="s">&#39;PRN&#39;</span><span class="p">,</span> <span class="s">&#39;PRT&#39;</span><span class="p">,</span>
					<span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;RRC&#39;</span><span class="p">,</span> <span class="s">&#39;WHADJP&#39;</span><span class="p">,</span> <span class="s">&#39;WHADVP&#39;</span><span class="p">,</span> <span class="s">&#39;WHNP&#39;</span><span class="p">,</span> <span class="s">&#39;WHPP&#39;</span><span class="p">}},</span>
			<span class="c"># level 1: HP (arguments), MP (modifiers)</span>
			<span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;HP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;UCP&#39;</span><span class="p">,</span> <span class="s">&#39;SQ&#39;</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">,</span> <span class="s">&#39;SBARQ&#39;</span><span class="p">,</span> <span class="s">&#39;SINV&#39;</span><span class="p">,</span>
					<span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;NAC&#39;</span><span class="p">,</span> <span class="s">&#39;NX&#39;</span><span class="p">,</span> <span class="s">&#39;LST&#39;</span><span class="p">,</span> <span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;FRAG&#39;</span><span class="p">},</span>
				<span class="s">&#39;MP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;ADJP&#39;</span><span class="p">,</span> <span class="s">&#39;QP&#39;</span><span class="p">,</span> <span class="s">&#39;CONJP&#39;</span><span class="p">,</span> <span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;INTJ&#39;</span><span class="p">,</span> <span class="s">&#39;PRN&#39;</span><span class="p">,</span> <span class="s">&#39;PRT&#39;</span><span class="p">,</span>
					<span class="s">&#39;PRT|ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;RRC&#39;</span><span class="p">,</span> <span class="s">&#39;WHADJP&#39;</span><span class="p">,</span> <span class="s">&#39;WHADVP&#39;</span><span class="p">,</span> <span class="s">&#39;WHNP&#39;</span><span class="p">,</span>
					<span class="s">&#39;WHPP&#39;</span><span class="p">}},</span>
			<span class="c"># level 2: S (verbal), N (nominal), A (adjectival),</span>
			<span class="c"># 	P (prepositional)</span>
			<span class="c"># note: PRT is part of both A_ and P_ in the paper;</span>
			<span class="c"># UCP is part of both S_ and N_</span>
			<span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;SQ&#39;</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">,</span> <span class="s">&#39;SBARQ&#39;</span><span class="p">,</span> <span class="s">&#39;SINV&#39;</span><span class="p">},</span>
				<span class="s">&#39;N_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;NAC&#39;</span><span class="p">,</span> <span class="s">&#39;NX&#39;</span><span class="p">,</span> <span class="s">&#39;LST&#39;</span><span class="p">,</span> <span class="s">&#39;X&#39;</span><span class="p">,</span> <span class="s">&#39;UCP&#39;</span><span class="p">,</span> <span class="s">&#39;FRAG&#39;</span><span class="p">},</span>
				<span class="s">&#39;A_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;ADJP&#39;</span><span class="p">,</span> <span class="s">&#39;QP&#39;</span><span class="p">,</span> <span class="s">&#39;CONJP&#39;</span><span class="p">,</span> <span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;INTJ&#39;</span><span class="p">,</span> <span class="s">&#39;PRN&#39;</span><span class="p">,</span> <span class="s">&#39;PRT&#39;</span><span class="p">,</span>
					<span class="s">&#39;PRT|ADVP&#39;</span><span class="p">},</span>
				<span class="s">&#39;P_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;RRC&#39;</span><span class="p">,</span> <span class="s">&#39;WHADJP&#39;</span><span class="p">,</span> <span class="s">&#39;WHADVP&#39;</span><span class="p">,</span> <span class="s">&#39;WHNP&#39;</span><span class="p">,</span> <span class="s">&#39;WHPP&#39;</span><span class="p">}},</span>
			<span class="c"># level 3: no-op, return original treebank labels</span>
		<span class="p">},</span>
		<span class="s">&#39;negra&#39;</span><span class="p">:</span> <span class="p">{</span>
			<span class="c"># level 0: P (all phrase labels)</span>
			<span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;P&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="s">&#39;AA&#39;</span><span class="p">,</span> <span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;AVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAC&#39;</span><span class="p">,</span> <span class="s">&#39;CAP&#39;</span><span class="p">,</span> <span class="s">&#39;CAVP&#39;</span><span class="p">,</span> <span class="s">&#39;CCP&#39;</span><span class="p">,</span>
				<span class="s">&#39;CH&#39;</span><span class="p">,</span> <span class="s">&#39;CNP&#39;</span><span class="p">,</span> <span class="s">&#39;CO&#39;</span><span class="p">,</span> <span class="s">&#39;CPP&#39;</span><span class="p">,</span> <span class="s">&#39;CS&#39;</span><span class="p">,</span> <span class="s">&#39;CVP&#39;</span><span class="p">,</span> <span class="s">&#39;CVZ&#39;</span><span class="p">,</span> <span class="s">&#39;DL&#39;</span><span class="p">,</span> <span class="s">&#39;ISU&#39;</span><span class="p">,</span>
				<span class="s">&#39;MPN&#39;</span><span class="p">,</span> <span class="s">&#39;MTA&#39;</span><span class="p">,</span> <span class="s">&#39;NM&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;QL&#39;</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;VZ&#39;</span><span class="p">}},</span>
			<span class="c"># level 1: HP (arguments), MP (modifiers)</span>
			<span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;HP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;VZ&#39;</span><span class="p">,</span> <span class="s">&#39;CO&#39;</span><span class="p">,</span> <span class="s">&#39;AA&#39;</span><span class="p">,</span> <span class="s">&#39;CNP&#39;</span><span class="p">,</span> <span class="s">&#39;CS&#39;</span><span class="p">,</span> <span class="s">&#39;CVP&#39;</span><span class="p">,</span>
					<span class="s">&#39;CVZ&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">,</span> <span class="s">&#39;MPN&#39;</span><span class="p">,</span> <span class="s">&#39;NM&#39;</span><span class="p">,</span> <span class="s">&#39;CH&#39;</span><span class="p">,</span> <span class="s">&#39;CCP&#39;</span><span class="p">,</span> <span class="s">&#39;DL&#39;</span><span class="p">,</span> <span class="s">&#39;ISU&#39;</span><span class="p">,</span> <span class="s">&#39;QL&#39;</span><span class="p">},</span>
				<span class="s">&#39;MP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;AVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAP&#39;</span><span class="p">,</span> <span class="s">&#39;CPP&#39;</span><span class="p">,</span> <span class="s">&#39;CAVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAC&#39;</span><span class="p">,</span>
					<span class="s">&#39;MTA&#39;</span><span class="p">}},</span>
			<span class="c"># level 2: S (verbal), N (nominal), A (adjectival),</span>
			<span class="c"># 	P (prepositional)</span>
			<span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;VZ&#39;</span><span class="p">,</span> <span class="s">&#39;CO&#39;</span><span class="p">,</span> <span class="s">&#39;AA&#39;</span><span class="p">,</span> <span class="s">&#39;CS&#39;</span><span class="p">,</span> <span class="s">&#39;CVP&#39;</span><span class="p">,</span>
					<span class="s">&#39;CVZ&#39;</span><span class="p">,</span> <span class="s">&#39;CCP&#39;</span><span class="p">,</span> <span class="s">&#39;DL&#39;</span><span class="p">,</span> <span class="s">&#39;ISU&#39;</span><span class="p">,</span> <span class="s">&#39;QL&#39;</span><span class="p">},</span>
				<span class="s">&#39;N_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;CNP&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">,</span> <span class="s">&#39;MPN&#39;</span><span class="p">,</span> <span class="s">&#39;NM&#39;</span><span class="p">,</span> <span class="s">&#39;CH&#39;</span><span class="p">},</span>
				<span class="s">&#39;A_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;--&#39;</span><span class="p">,</span> <span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;AVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAP&#39;</span><span class="p">,</span> <span class="s">&#39;CAVP&#39;</span><span class="p">,</span> <span class="s">&#39;MTA&#39;</span><span class="p">}},</span>
				<span class="s">&#39;P_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;CPP&#39;</span><span class="p">,</span> <span class="s">&#39;CAC&#39;</span><span class="p">}</span>
			<span class="c"># level 3: no-op, return original treebank labels</span>
		<span class="p">},</span>
		<span class="s">&#39;alpino&#39;</span><span class="p">:</span> <span class="p">{</span>
			<span class="c"># level 0: P (all phrase labels)</span>
			<span class="mi">0</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;P&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;AHI&#39;</span><span class="p">,</span> <span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;CONJ&#39;</span><span class="p">,</span> <span class="s">&#39;CP&#39;</span><span class="p">,</span> <span class="s">&#39;DETP&#39;</span><span class="p">,</span> <span class="s">&#39;DU&#39;</span><span class="p">,</span> <span class="s">&#39;INF&#39;</span><span class="p">,</span>
					<span class="s">&#39;MWU&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;OTI&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;PPART&#39;</span><span class="p">,</span> <span class="s">&#39;PPRES&#39;</span><span class="p">,</span> <span class="s">&#39;REL&#39;</span><span class="p">,</span> <span class="s">&#39;SMAIN&#39;</span><span class="p">,</span>
					<span class="s">&#39;SSUB&#39;</span><span class="p">,</span> <span class="s">&#39;SV1&#39;</span><span class="p">,</span> <span class="s">&#39;SVAN&#39;</span><span class="p">,</span> <span class="s">&#39;TI&#39;</span><span class="p">,</span> <span class="s">&#39;WHQ&#39;</span><span class="p">,</span> <span class="s">&#39;WHREL&#39;</span><span class="p">,</span> <span class="s">&#39;WHSUB&#39;</span><span class="p">}},</span>
			<span class="c"># level 1: HP (arguments), MP (modifiers)</span>
			<span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;HP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;AHI&#39;</span><span class="p">,</span> <span class="s">&#39;CONJ&#39;</span><span class="p">,</span> <span class="s">&#39;CP&#39;</span><span class="p">,</span> <span class="s">&#39;DETP&#39;</span><span class="p">,</span> <span class="s">&#39;DU&#39;</span><span class="p">,</span> <span class="s">&#39;INF&#39;</span><span class="p">,</span> <span class="s">&#39;MWU&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">,</span>
					<span class="s">&#39;OTI&#39;</span><span class="p">,</span> <span class="s">&#39;PPART&#39;</span><span class="p">,</span> <span class="s">&#39;PPRES&#39;</span><span class="p">,</span> <span class="s">&#39;REL&#39;</span><span class="p">,</span> <span class="s">&#39;SMAIN&#39;</span><span class="p">,</span> <span class="s">&#39;SSUB&#39;</span><span class="p">,</span> <span class="s">&#39;SVAN&#39;</span><span class="p">,</span>
					<span class="s">&#39;SV1&#39;</span><span class="p">,</span> <span class="s">&#39;TI&#39;</span><span class="p">,</span> <span class="s">&#39;WHSUB&#39;</span><span class="p">,</span> <span class="s">&#39;WHQ&#39;</span><span class="p">},</span>
				<span class="s">&#39;MP&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;REL&#39;</span><span class="p">,</span> <span class="s">&#39;WHREL&#39;</span><span class="p">}},</span>
			<span class="c"># level 2: S (verbal), N (nominal), A (adjectival),</span>
			<span class="c"># 	P (prepositional)</span>
			<span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;S_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;AHI&#39;</span><span class="p">,</span> <span class="s">&#39;CP&#39;</span><span class="p">,</span> <span class="s">&#39;DU&#39;</span><span class="p">,</span> <span class="s">&#39;INF&#39;</span><span class="p">,</span> <span class="s">&#39;OTI&#39;</span><span class="p">,</span> <span class="s">&#39;PPART&#39;</span><span class="p">,</span> <span class="s">&#39;PPRES&#39;</span><span class="p">,</span>
					<span class="s">&#39;SMAIN&#39;</span><span class="p">,</span> <span class="s">&#39;SSUB&#39;</span><span class="p">,</span> <span class="s">&#39;SVAN&#39;</span><span class="p">,</span> <span class="s">&#39;SV1&#39;</span><span class="p">,</span> <span class="s">&#39;TI&#39;</span><span class="p">,</span> <span class="s">&#39;WHSUB&#39;</span><span class="p">,</span> <span class="s">&#39;WHQ&#39;</span><span class="p">},</span>
				<span class="s">&#39;N_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;CONJ&#39;</span><span class="p">,</span> <span class="s">&#39;DETP&#39;</span><span class="p">,</span> <span class="s">&#39;MWU&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">},</span>
				<span class="s">&#39;A_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;ADVP&#39;</span><span class="p">,</span> <span class="s">&#39;REL&#39;</span><span class="p">,</span> <span class="s">&#39;WHREL&#39;</span><span class="p">},</span>
				<span class="s">&#39;P_&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s">&#39;PP&#39;</span><span class="p">}},</span>
			<span class="c"># level 3: no-op, return original treebank labels</span>
		<span class="p">},</span>
	<span class="p">}</span>


<div class="viewcode-block" id="expandpresets"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.expandpresets">[docs]</a><span class="k">def</span> <span class="nf">expandpresets</span><span class="p">(</span><span class="n">transformations</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Expand aliases for presets.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">transformations</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">PRESETS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">[</span><span class="n">name</span><span class="p">])]</span>

</div>
<div class="viewcode-block" id="transform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.transform">[docs]</a><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">transformations</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Perform specified sequence of transformations on a tree.</span>

<span class="sd">	State-splits are preceded by &#39;^&#39;. ``transformations`` is a sequence of</span>
<span class="sd">	transformation names (order matters) that will be performed on the given</span>
<span class="sd">	tree (in-place). There are presets for particular treebanks. The name of a</span>
<span class="sd">	preset can be used as an alias that expands to a sequence of</span>
<span class="sd">	transformations; see the variable ``PRESETS``.&quot;&quot;&quot;</span>
	<span class="c"># unfreeze attributes so that they can be modified</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">isinstance</span><span class="p">(</span>
			<span class="nb">getattr</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">)):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">transformations</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;APPEND-FUNC&#39;</span><span class="p">:</span>  <span class="c"># add function to phrasal label</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">functions</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">):</span>  <span class="c"># -LRB-</span>
					<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="s">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FUNC-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/function above phrasal label</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">():</span>
				<span class="n">func</span> <span class="o">=</span> <span class="n">functions</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">):</span>  <span class="c"># -LRB-</span>
					<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
							<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
					<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;-&#39;</span> <span class="o">+</span> <span class="s">&#39;-&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;APPEND-MORPH&#39;</span><span class="p">:</span>  <span class="c"># Append morph. features to POS tag</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtree</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">morph</span> <span class="o">=</span> <span class="s">&#39;--&#39;</span>
				<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">morph</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
				<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">morph</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MORPH-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/morph. features above POS</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">morph</span> <span class="o">=</span> <span class="s">&#39;--&#39;</span>
				<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">morph</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">morph</span><span class="p">,</span>
						<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;LEMMA-NODE&#39;</span><span class="p">:</span>  <span class="c"># insert node w/lemma above terminal</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="n">lemma</span> <span class="o">=</span> <span class="s">&#39;--&#39;</span>
				<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">lemma</span> <span class="o">=</span> <span class="n">quote</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">LEMMA</span><span class="p">])</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span>
						<span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MARK-YEAR&#39;</span><span class="p">:</span>  <span class="c"># mark POS label of year terminals</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">YEARRE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;year&#39;</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PUNCT&#39;</span><span class="p">:</span>  <span class="c"># distinguish sentence-ending punctuation.</span>
			<span class="k">for</span> <span class="n">punct</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">in</span> <span class="s">&#39;.?!&#39;</span><span class="p">):</span>
				<span class="n">punct</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">sent</span><span class="p">[</span><span class="n">punct</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PUNCT-PRUNE&#39;</span><span class="p">:</span>  <span class="c"># remove initial/ending quotes &amp; period</span>
			<span class="n">punctprune</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FANOUT&#39;</span><span class="p">:</span>  <span class="c"># add fan-out markers</span>
			<span class="n">addfanoutmarkers</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PARENT&#39;</span><span class="p">:</span>  <span class="c"># add one level of parent annotation</span>
			<span class="c"># Useful to do here to add the parent annotations before</span>
			<span class="c"># adding any other annotations to the labels.</span>
			<span class="c"># Skips preterminals.</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span>
					<span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;TAGPA&#39;</span><span class="p">:</span>  <span class="c"># Add parent annotation to non-punct. POS tags</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
					<span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">PUNCTUATION</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NP-PP&#39;</span><span class="p">:</span>  <span class="c"># mark PPs under NPs</span>
			<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span>
					<span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">):</span>
				<span class="n">pp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;NP&#39;</span>
		<span class="k">elif</span> <span class="p">(</span><span class="n">negratransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
				<span class="ow">or</span> <span class="n">lassytransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
				<span class="ow">or</span> <span class="n">ptbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
				<span class="ow">or</span> <span class="n">ftbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)):</span>
			<span class="k">pass</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;unrecognized transformation </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">Tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">tree</span>

</div>
<span class="k">def</span> <span class="nf">negratransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Negra / Tiger transforms.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-RC&#39;</span><span class="p">:</span>  <span class="c"># relative clause =&gt; S becomes S^RC</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;RC&#39;</span><span class="p">):</span>
			<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;RC&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">:</span>  <span class="c"># case</span>
		<span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">):</span>
			<span class="n">np</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">np</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PP-NP&#39;</span><span class="p">:</span>  <span class="c"># un-flatten PPs by introducing NPs</span>
		<span class="n">addtopp</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">,</span> <span class="p">)</span>
		<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span><span class="p">):</span>
			<span class="n">ac</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="n">addtopp</span><span class="p">]</span>
			<span class="c"># anything before an initial preposition goes to the PP</span>
			<span class="c"># (modifiers, punctuation), otherwise it goes to the NP;</span>
			<span class="c"># mutatis mutandis for postpositions.</span>
			<span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pp</span><span class="p">]</span>
			<span class="k">if</span> <span class="s">&#39;AC&#39;</span> <span class="ow">in</span> <span class="n">funcs</span> <span class="ow">and</span> <span class="s">&#39;NK&#39;</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">funcs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">funcs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;NK&#39;</span><span class="p">):</span>
					<span class="n">ac</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pp</span><span class="p">[:</span><span class="n">funcs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;AC&#39;</span><span class="p">)]</span>
				<span class="k">if</span> <span class="n">rindex</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rindex</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="s">&#39;NK&#39;</span><span class="p">):</span>
					<span class="n">ac</span> <span class="o">+=</span> <span class="n">pp</span><span class="p">[</span><span class="n">rindex</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="s">&#39;AC&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
			<span class="c"># else:</span>
			<span class="c"># 	print(&#39;PP but no AC or NK&#39;, &#39; &#39;.join(funcs))</span>
			<span class="n">nk</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">pp</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ac</span><span class="p">]</span>
			<span class="c"># introduce a PP unless there is already an NP in the PP</span>
			<span class="c"># (annotation mistake?), or there is a PN and we want to avoid</span>
			<span class="c"># a cylic unary of NP -&gt; PN -&gt; NP.</span>
			<span class="k">if</span> <span class="n">ac</span> <span class="ow">and</span> <span class="n">nk</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
					<span class="ow">or</span> <span class="n">nk</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">)):</span>
				<span class="n">pp</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
				<span class="n">pp</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ac</span> <span class="o">+</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="n">nk</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">:</span>  <span class="c"># introduce determiner phrases (DPs)</span>
		<span class="c"># determiners = {&#39;ART&#39;, &#39;PDS&#39;, &#39;PDAT&#39;, &#39;PIS&#39;, &#39;PIAT&#39;, &#39;PPOSAT&#39;,</span>
		<span class="c"># 	&#39;PRELS&#39;, &#39;PRELAT&#39;, &#39;PWS&#39;, &#39;PWAT&#39;, &#39;PWAV&#39;}</span>
		<span class="n">determiners</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ART&#39;</span><span class="p">}</span>
		<span class="k">for</span> <span class="n">np</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">np</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">determiners</span><span class="p">:</span>
				<span class="n">np</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;DP&#39;</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;PN&#39;</span><span class="p">:</span>
					<span class="n">np1</span> <span class="o">=</span> <span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
					<span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[]</span>
					<span class="n">np</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="n">np1</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-GF&#39;</span><span class="p">:</span>  <span class="c"># VP category split based on head</span>
		<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
			<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_NEGRA&#39;</span><span class="p">:</span>  <span class="c"># introduce finite VP at S level</span>
		<span class="c"># collect objects and modifiers</span>
		<span class="c"># introduce new S level for discourse markers</span>
		<span class="n">newlevel</span> <span class="o">=</span> <span class="s">&#39;DM&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">addtovp</span> <span class="o">=</span> <span class="s">&#39;HD AC DA MO NG OA OA2 OC OG PD VO SVP&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

		<span class="k">def</span> <span class="nf">finitevp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
			<span class="sd">&quot;&quot;&quot;Introduce finite VPs grouping verbs and their objects.&quot;&quot;&quot;</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;FIN&#39;</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)):</span>
				<span class="n">vp</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">in</span> <span class="n">addtovp</span><span class="p">]</span>
				<span class="c"># introduce a VP unless it would lead to a unary</span>
				<span class="c"># VP -&gt; VP production</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">vp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;VP&#39;</span><span class="p">:</span>
					<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">addtovp</span>
							<span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">vp</span><span class="p">]</span>
		<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">if</span> <span class="s">&#39;S&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
			<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">toplevel_s</span><span class="p">:</span>
				<span class="k">while</span> <span class="n">function</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">newlevel</span><span class="p">:</span>
					<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
					<span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
					<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>
		<span class="k">elif</span> <span class="s">&#39;CS&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
			<span class="n">cs</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;CS&#39;</span><span class="p">)]</span>
			<span class="n">toplevel_s</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">cs</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">]</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">toplevel_s</span><span class="p">:</span>
			<span class="n">finitevp</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;POS-PART&#39;</span><span class="p">:</span>  <span class="c"># introduce POS tag for particle verbs</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span>
				<span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;SVP&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)):</span>
			<span class="n">svp</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;SVP&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="c"># apparently there can be a _verb_ particle without a verb.</span>
			<span class="c"># headlines? annotation mistake?</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ishead</span><span class="p">,</span> <span class="n">a</span><span class="p">)):</span>
				<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
					<span class="n">particleverb</span> <span class="o">=</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="n">hd</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">hd</span><span class="p">,</span> <span class="n">svp</span><span class="p">])</span>
					<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">particleverb</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">else</span> <span class="n">x</span>
										<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;SVP&#39;</span><span class="p">]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">:</span>  <span class="c"># introduce SBAR level</span>
		<span class="n">sbarfunc</span> <span class="o">=</span> <span class="s">&#39;CP&#39;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="c"># in the annotation, complementizers belong to the first S</span>
		<span class="c"># in S conjunctions, even when they appear to apply to the whole</span>
		<span class="c"># conjunction.</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">in</span> <span class="n">sbarfunc</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)):</span>
			<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;SBAR&#39;</span>
			<span class="n">s</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NEST&#39;</span><span class="p">:</span>  <span class="c"># introduce nested structures for modifiers</span>
		<span class="c"># (iterated adjunction instead of sister adjunction)</span>
		<span class="n">adjunctable</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">}</span>  <span class="c"># PP AP VP</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="n">adjunctable</span>
				<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">))):</span>
			<span class="n">modifiers</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span><span class="p">]</span>
			<span class="k">if</span> <span class="nb">min</span><span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;MO&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">modifiers</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">modifiers</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
			<span class="k">while</span> <span class="n">modifiers</span><span class="p">:</span>
				<span class="n">modifier</span> <span class="o">=</span> <span class="n">modifiers</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">ParentedTree</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
						<span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">modifier</span><span class="p">]),</span> <span class="n">modifier</span><span class="p">]</span>
				<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="c"># The following transformations as described in Fraser et al (CL, 2013)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;addUnary&#39;</span><span class="p">:</span>  <span class="c"># introduce unary NPs</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span>
					<span class="p">{</span><span class="s">&#39;NN&#39;</span><span class="p">,</span> <span class="s">&#39;PPER&#39;</span><span class="p">,</span> <span class="s">&#39;PDS&#39;</span><span class="p">,</span> <span class="s">&#39;PIS&#39;</span><span class="p">,</span> <span class="s">&#39;PRELS&#39;</span><span class="p">,</span> <span class="s">&#39;CARD&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">}</span>
					<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;ROOT&#39;</span><span class="p">,</span> <span class="s">&#39;DL&#39;</span><span class="p">}):</span>
			<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PN&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># only complex PNs</span>
				<span class="k">continue</span>
			<span class="n">children</span> <span class="o">=</span> <span class="n">node</span><span class="p">[:]</span>
			<span class="n">node</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
			<span class="n">tag</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[:]</span>
			<span class="n">node</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span><span class="p">]</span>
			<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;NP&#39;</span>
			<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
			<span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HD&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;addCase&#39;</span><span class="p">:</span>  <span class="c"># add case features to POS tags</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">case</span> <span class="o">=</span> <span class="n">CASERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">])</span>
			<span class="k">if</span> <span class="n">case</span><span class="p">:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&#39;/&#39;</span> <span class="o">+</span> <span class="n">case</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;elimNKCJ&#39;</span><span class="p">:</span>  <span class="c"># eliminate NK and CJ functions</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NK&#39;</span><span class="p">,</span> <span class="s">&#39;CJ&#39;</span><span class="p">}):</span>
			<span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;NK&#39;</span><span class="p">:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HD&#39;</span>
			<span class="k">else</span><span class="p">:</span>  <span class="c"># elif function(node) == &#39;CJ&#39;:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;lexPrep&#39;</span><span class="p">:</span>  <span class="c"># lexicalize frequent prepositions/conjunctions</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">word</span> <span class="o">=</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&#39;APPR&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">word</span> <span class="ow">in</span> <span class="p">{</span>
					<span class="s">&#39;in&#39;</span><span class="p">,</span> <span class="s">&#39;von&#39;</span><span class="p">,</span> <span class="s">&#39;auf&#39;</span><span class="p">,</span> <span class="s">&#39;durch&#39;</span><span class="p">,</span> <span class="s">&#39;um&#39;</span><span class="p">,</span>
					<span class="s">&#39;unter&#39;</span><span class="p">,</span> <span class="s">&#39;unters&#39;</span><span class="p">,</span> <span class="s">&#39;unterm&#39;</span><span class="p">}:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">word</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s">&#39;KON&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;CD&#39;</span> <span class="ow">and</span> <span class="p">(</span><span class="n">word</span> <span class="ow">in</span> <span class="p">{</span>
					<span class="s">&#39;sowohl&#39;</span><span class="p">,</span> <span class="s">&#39;als&#39;</span><span class="p">,</span> <span class="s">&#39;weder&#39;</span><span class="p">,</span> <span class="s">&#39;entweder&#39;</span><span class="p">,</span> <span class="s">&#39;noch&#39;</span><span class="p">}</span>
					<span class="ow">or</span> <span class="p">(</span><span class="n">word</span> <span class="o">==</span> <span class="s">&#39;oder&#39;</span>  <span class="c"># &#39;oder&#39; if preceded by entweder</span>
						<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;entweder&#39;</span>
							<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sent</span><span class="p">[:</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">word</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;adjAttach&#39;</span><span class="p">:</span>  <span class="c"># annotate attachments of adjuncts</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span>
				<span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;AVP&#39;</span><span class="p">,</span> <span class="s">&#39;ADV&#39;</span><span class="p">,</span> <span class="s">&#39;ADJD&#39;</span><span class="p">}):</span>
			<span class="k">if</span> <span class="n">strip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">}:</span>
				<span class="n">annot</span> <span class="o">=</span> <span class="s">&#39;V&#39;</span>
			<span class="k">elif</span> <span class="n">strip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">}:</span>
				<span class="n">annot</span> <span class="o">=</span> <span class="s">&#39;N&#39;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">annot</span> <span class="o">=</span> <span class="s">&#39;0&#39;</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">annot</span>
			<span class="k">if</span> <span class="n">strip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;AVP&#39;</span><span class="p">:</span>  <span class="c"># propagate to head child</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">annot</span>
						<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;relPath&#39;</span><span class="p">:</span>  <span class="c"># mark path from relative clause to rel. pronoun</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;RC&#39;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span>
					<span class="p">{</span><span class="s">&#39;PRELS&#39;</span><span class="p">,</span> <span class="s">&#39;PRELAT&#39;</span><span class="p">,</span> <span class="s">&#39;PWAV&#39;</span><span class="p">,</span> <span class="s">&#39;PWS&#39;</span><span class="p">}):</span>
				<span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span>
				<span class="k">while</span> <span class="n">child</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
					<span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;rel&#39;</span>
					<span class="n">child</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">parent</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;rel&#39;</span>
				<span class="k">break</span>
			<span class="k">else</span><span class="p">:</span>  <span class="c"># no rel. pronoun found</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;norel&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;whFeat&#39;</span><span class="p">:</span>  <span class="c"># mark NP/PP that immediately dominates WH-pronoun</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">}</span> <span class="ow">and</span>
				<span class="nb">any</span><span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;PWAT&#39;</span><span class="p">,</span> <span class="s">&#39;PWS&#39;</span><span class="p">,</span> <span class="s">&#39;PWAV&#39;</span><span class="p">}</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">n</span><span class="p">)):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;wh&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nounSeq&#39;</span><span class="p">:</span>  <span class="c"># consecutive nouns in NP</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">node</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
				<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="s">&#39;NN&#39;</span><span class="p">):</span>
					<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;seq&#39;</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;properChunks&#39;</span><span class="p">:</span>  <span class="c"># mark POS tags in proper noun chunks</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;PNC&#39;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;name&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markAP&#39;</span><span class="p">:</span>  <span class="c"># mark predicative APs, APs with nominal head</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;AP&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">base</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;ADJD&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">subtrees</span><span class="p">()):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;pred&#39;</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">ishead</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NN&#39;</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">}</span>
					<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;nom&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;subConjType&#39;</span><span class="p">:</span>  <span class="c"># mark type of subordinating conj.</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;SB&#39;</span><span class="p">,</span> <span class="s">&#39;OC&#39;</span><span class="p">,</span> <span class="s">&#39;MO&#39;</span><span class="p">,</span> <span class="s">&#39;RE&#39;</span><span class="p">}):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;KOUS&#39;</span><span class="p">):</span>
					<span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VPfeat&#39;</span><span class="p">:</span>  <span class="c"># mark object VPs with head label</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;OC&#39;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;noHead&#39;</span><span class="p">:</span>  <span class="c"># constituents without head child</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">tree</span>
				<span class="ow">and</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
			<span class="c"># The heuristically found heads do not count.</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;HD&#39;</span><span class="p">,</span> <span class="s">&#39;PNC&#39;</span><span class="p">,</span> <span class="s">&#39;AC&#39;</span><span class="p">,</span> <span class="s">&#39;AVC&#39;</span><span class="p">,</span> <span class="s">&#39;NMC&#39;</span><span class="p">,</span>
					<span class="s">&#39;PH&#39;</span><span class="p">,</span> <span class="s">&#39;PD&#39;</span><span class="p">,</span> <span class="s">&#39;ADC&#39;</span><span class="p">,</span> <span class="s">&#39;UC&#39;</span><span class="p">,</span> <span class="s">&#39;DH&#39;</span><span class="p">}</span>
					<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;nohead&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;noSubj&#39;</span><span class="p">:</span>  <span class="c"># conjunct clauses without subject</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;CJ&#39;</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;SB&#39;</span><span class="p">,</span> <span class="s">&#39;EP&#39;</span><span class="p">}</span>
					<span class="ow">or</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VVIMP&#39;</span><span class="p">,</span> <span class="s">&#39;VAIMP&#39;</span><span class="p">}</span>
					<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;nosubj&#39;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">ptbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Transforms for WSJ section of Penn treebank.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-WH&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">sbar</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sbar</span><span class="p">:</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span>
						<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;WH&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">)):</span>
					<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;WH&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-HD&#39;</span><span class="p">:</span>  <span class="c"># VP category split based on head</span>
		<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
			<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vp</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VB&#39;</span><span class="p">:</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HINF&#39;</span>
			<span class="k">elif</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;TO&#39;</span><span class="p">:</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HTO&#39;</span>
			<span class="k">elif</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;VBN&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">):</span>
				<span class="n">vp</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HPART&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;S-INF&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
			<span class="n">hd</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="k">if</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;VP&#39;</span> <span class="o">+</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HINF&#39;</span><span class="p">,</span>
					<span class="s">&#39;VP&#39;</span> <span class="o">+</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HTO&#39;</span><span class="p">):</span>
				<span class="n">s</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;INF&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_WSJ&#39;</span><span class="p">:</span>  <span class="c"># add disc. finite VP when verb is under S</span>
		<span class="c"># this counters the flattening when a VP is not possible because of</span>
		<span class="c"># non-standard word order; e.g. is John happy</span>
		<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
			<span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;VP&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">):</span>
				<span class="n">vp</span> <span class="o">=</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="p">[])</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
					<span class="c"># FIXME: check which functions should not go in the VP</span>
					<span class="c"># (pre)modifiers unclear.</span>
					<span class="k">if</span> <span class="s">&#39;SBJ&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
						<span class="n">vp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">child</span><span class="p">))</span>
				<span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vp</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MARK-UNARY&#39;</span><span class="p">:</span>  <span class="c"># add -U to unary nodes to avoid cycles</span>
		<span class="k">for</span> <span class="n">unary</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
			<span class="n">unary</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;U&#39;</span>
	<span class="c"># The following transformations are translations of</span>
	<span class="c"># the Stanford Parser state splits described in</span>
	<span class="c"># Accurate Unlexicalized Parsing (ACL 2003)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitIN&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitIN=3</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;IN&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">)</span> <span class="ow">or</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;N&#39;</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">)</span> <span class="ow">or</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;ADJP&#39;</span><span class="p">)):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;Q&#39;</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">):</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;SCC&#39;</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;SC&#39;</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">base</span><span class="p">(</span>
					<span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;WHNP&#39;</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;T&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitIN4&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitIN=4</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;IN&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;P&#39;</span><span class="p">)</span> <span class="ow">or</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">)):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;N&#39;</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;N&#39;</span><span class="p">)</span> <span class="ow">or</span>
					<span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;ADJP&#39;</span><span class="p">)):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;Q&#39;</span>
			<span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base</span><span class="p">(</span>
					<span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">):</span>
				<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">):</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;SCC&#39;</span>
				<span class="k">elif</span> <span class="ow">not</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base</span><span class="p">(</span>
						<span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;ADJP&#39;</span><span class="p">):</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;SC&#39;</span>
			<span class="k">elif</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;SBAR&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">base</span><span class="p">(</span>
					<span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;WHNP&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">base</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="s">&#39;WHADVP&#39;</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;T&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitPercent&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitPercent=1</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s">&#39;%&#39;</span><span class="p">):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">r&#39;%&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitPoss&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitPoss=1</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;POS&#39;</span><span class="p">)):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;P&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitCC&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitCC=2</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;CC&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;but&#39;</span><span class="p">:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;B&#39;</span>
			<span class="k">elif</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s">&#39;&amp;&#39;</span><span class="p">:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;A&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;unaryDT&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser unaryDT=true</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;DT&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;U&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;unaryRB&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser unaryRB=true</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;RB&#39;</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;U&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitAux&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitAux=1</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
				<span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VBZ&#39;</span><span class="p">,</span> <span class="s">&#39;VBP&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">,</span> <span class="s">&#39;VBN&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">,</span> <span class="s">&#39;VB&#39;</span><span class="p">}):</span>
			<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span>
					<span class="s">&#39;is&#39;</span><span class="p">,</span> <span class="s">&#39;am&#39;</span><span class="p">,</span> <span class="s">&#39;are&#39;</span><span class="p">,</span> <span class="s">&#39;was&#39;</span><span class="p">,</span> <span class="s">&#39;were&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;m&quot;</span><span class="p">,</span> <span class="s">&quot;&#39;re&quot;</span><span class="p">,</span> <span class="s">&quot;&#39;s&quot;</span><span class="p">,</span>
					<span class="s">&#39;being&#39;</span><span class="p">,</span> <span class="s">&#39;be&#39;</span><span class="p">,</span> <span class="s">&#39;been&#39;</span><span class="p">}:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;BE&#39;</span>
			<span class="k">elif</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span>
					<span class="s">&#39;have&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;ve&quot;</span><span class="p">,</span> <span class="s">&#39;having&#39;</span><span class="p">,</span> <span class="s">&#39;has&#39;</span><span class="p">,</span> <span class="s">&#39;had&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;d&quot;</span><span class="p">}:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HV&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitAux2&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitAux=2</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
				<span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VBZ&#39;</span><span class="p">,</span> <span class="s">&#39;VBP&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">,</span> <span class="s">&#39;VBN&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">,</span> <span class="s">&#39;VB&#39;</span><span class="p">}):</span>
			<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&quot;&#39;s&quot;</span><span class="p">,</span> <span class="s">&quot;s&quot;</span><span class="p">}:</span>
				<span class="c"># &#39;s can be a contraction of both &quot;is&quot; and &quot;have&quot;</span>
				<span class="n">foundAux</span> <span class="o">=</span> <span class="bp">False</span>
				<span class="k">for</span> <span class="n">sibling</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
					<span class="k">if</span> <span class="n">foundAux</span><span class="p">:</span>
						<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">sibling</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
								<span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VBD&#39;</span><span class="p">,</span> <span class="s">&#39;VBN&#39;</span><span class="p">}</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">sibling</span><span class="p">):</span>
							<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HV&#39;</span>
							<span class="k">break</span>
					<span class="k">elif</span> <span class="n">sibling</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;VBZ&#39;</span><span class="p">):</span>
						<span class="n">foundAux</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;BE&#39;</span>
			<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;am&#39;</span><span class="p">,</span> <span class="s">&#39;is&#39;</span><span class="p">,</span> <span class="s">&#39;are&#39;</span><span class="p">,</span> <span class="s">&#39;was&#39;</span><span class="p">,</span> <span class="s">&#39;were&#39;</span><span class="p">,</span>
					<span class="s">&quot;&#39;m&quot;</span><span class="p">,</span> <span class="s">&quot;&#39;re&quot;</span><span class="p">,</span> <span class="s">&#39;be&#39;</span><span class="p">,</span> <span class="s">&#39;being&#39;</span><span class="p">,</span> <span class="s">&#39;been&#39;</span><span class="p">,</span> <span class="s">&#39;ai&#39;</span><span class="p">}:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;BE&#39;</span>
			<span class="k">elif</span> <span class="n">sent</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">{</span>
					<span class="s">&#39;have&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;ve&quot;</span><span class="p">,</span> <span class="s">&#39;having&#39;</span><span class="p">,</span> <span class="s">&#39;has&#39;</span><span class="p">,</span> <span class="s">&#39;had&#39;</span><span class="p">,</span> <span class="s">&quot;&#39;d&quot;</span><span class="p">}:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;HV&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitVP&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitVP=2</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VBZ&#39;</span><span class="p">,</span> <span class="s">&#39;VBP&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">,</span> <span class="s">&#39;MD&#39;</span><span class="p">}:</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;VBF&#39;</span>
					<span class="k">else</span><span class="p">:</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitVP3&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitVP=3</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">child</span><span class="p">):</span>
					<span class="k">if</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VBZ&#39;</span><span class="p">,</span> <span class="s">&#39;VBP&#39;</span><span class="p">,</span> <span class="s">&#39;VBD&#39;</span><span class="p">,</span> <span class="s">&#39;MD&#39;</span><span class="p">}:</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;VBF&#39;</span>
					<span class="k">elif</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;TO&#39;</span><span class="p">,</span> <span class="s">&#39;VBG&#39;</span><span class="p">,</span> <span class="s">&#39;VBN&#39;</span><span class="p">,</span> <span class="s">&#39;VB&#39;</span><span class="p">}:</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitSGapped&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitSGapped=3</span>
		<span class="n">seenPredCat</span> <span class="o">=</span> <span class="n">seenCC</span> <span class="o">=</span> <span class="n">seenS</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="n">seenNP</span> <span class="o">=</span> <span class="mi">0</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">)):</span>
			<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
				<span class="n">cat2</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span>
				<span class="k">if</span> <span class="n">cat2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">):</span>
					<span class="n">seenNP</span> <span class="o">+=</span> <span class="mi">1</span>
				<span class="k">elif</span> <span class="n">strip</span><span class="p">(</span><span class="n">cat2</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;ADJP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;UCP&#39;</span><span class="p">}:</span>
					<span class="n">seenPredCat</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="k">elif</span> <span class="n">cat2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;CC&#39;</span><span class="p">):</span>
					<span class="n">seenCC</span> <span class="o">=</span> <span class="bp">True</span>
				<span class="k">elif</span> <span class="n">cat2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">):</span>
					<span class="n">seenS</span> <span class="o">=</span> <span class="bp">True</span>
			<span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">seenCC</span> <span class="ow">and</span> <span class="n">seenS</span><span class="p">))</span> <span class="ow">and</span> <span class="p">(</span>
					<span class="n">seenNP</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">seenNP</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">seenPredCat</span><span class="p">)):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;G&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitTMP&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitTMP=TEMPORAL_ACL03PCFG</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s">&#39;TMP&#39;</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
			<span class="n">child</span> <span class="o">=</span> <span class="n">node</span>
			<span class="n">hd</span> <span class="o">=</span> <span class="bp">None</span>
			<span class="k">while</span> <span class="n">node</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">i</span><span class="p">,</span> <span class="n">hd</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
				<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
					<span class="k">break</span>
				<span class="k">if</span> <span class="n">strip</span><span class="p">(</span><span class="n">hd</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;POS&#39;</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
					<span class="n">hd</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
				<span class="n">child</span> <span class="o">=</span> <span class="n">hd</span>
			<span class="k">if</span> <span class="s">&#39;TMP&#39;</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;TMP&#39;</span>
			<span class="k">if</span> <span class="n">hd</span> <span class="ow">and</span> <span class="n">hd</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;N&#39;</span><span class="p">):</span>
				<span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;TMP&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitBaseNP&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitBaseNP=1</span>
		<span class="c"># Mark NPs that only dominate preterminals</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">a</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="p">):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;B&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;dominatesV&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser dominatesV=1</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">)):</span>
			<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tag</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;MD&#39;</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">pos</span><span class="p">()):</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;v&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;splitNPADV&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser splitNPADV=1</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
				<span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&#39;ADV&#39;</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;ADV&#39;</span>
			<span class="k">try</span><span class="p">:</span>
				<span class="n">hd</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
			<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="s">&#39;POS&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">hd</span><span class="o">.</span><span class="n">parent_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
				<span class="n">hd</span> <span class="o">=</span> <span class="n">node</span><span class="p">[</span><span class="n">hd</span><span class="o">.</span><span class="n">parent_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
			<span class="k">while</span> <span class="n">base</span><span class="p">(</span><span class="n">hd</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">):</span>
				<span class="n">hd</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;ADV&#39;</span>
				<span class="k">try</span><span class="p">:</span>
					<span class="n">hd</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">hd</span> <span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
				<span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
					<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markDitransV&#39;</span><span class="p">:</span>  <span class="c"># Stanford Parser markDitransV=2</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;VB&#39;</span><span class="p">)):</span>
			<span class="n">npargs</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="k">if</span> <span class="n">base</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
					<span class="ow">and</span> <span class="s">&#39;TMP&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
			<span class="k">if</span> <span class="n">npargs</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&#39;2Arg&#39;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">ftbtransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Port of manual FTB enrichments specified in Stanford parser.</span>

<span class="sd">	cf. ``FrenchTreebankParserParams.java``&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markinf&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;V&quot;</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VPinf&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;infinitive&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markpart&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;V&quot;</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VPpart&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;participle&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markvn&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;VN&quot;</span><span class="p">):</span>
			<span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
				<span class="n">sub</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;withVN&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;coord1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;COORD&#39;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">strip</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;de2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;P&#39;</span>
				<span class="ow">and</span> <span class="n">DERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]])):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;de2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;de3&#39;</span><span class="p">:</span>
		<span class="c"># @NP|PP|COORD &gt;+(@NP|PP) (@PP &lt;, (@P &lt; /^([Dd]es?|du|d&#39;)$/))</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
				<span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;PP&quot;</span><span class="p">,</span> <span class="s">&quot;COORD&quot;</span><span class="p">)):</span>
			<span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ancestors</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)):</span>
				<span class="k">if</span> <span class="n">PPORNP</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[:</span><span class="n">n</span><span class="p">])):</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
							<span class="ow">and</span> <span class="n">DERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]])):</span>
						<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;de3&quot;</span>
						<span class="k">break</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;markp1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;PP&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;NP&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;n&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvs&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="s">&quot;S&quot;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwadv-s&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvsel1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwadv1&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwadvsel2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWADV&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;D&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwadv2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel1&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;A&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwn1&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel2&#39;</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;P&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwn2&quot;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;mwnsel3&#39;</span><span class="p">:</span>  <span class="c"># noun-noun compound joined with dash.</span>
		<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;MWN&quot;</span>
				<span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span>
				<span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="s">&quot;N&quot;</span><span class="p">):</span>
			<span class="n">t</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="s">&quot;mwn3&quot;</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>


<span class="k">def</span> <span class="nf">lassytransforms</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">_sent</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Transformations for the Dutch Lassy &amp; Alpino treebanks.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nlselectmorph&#39;</span><span class="p">:</span>  <span class="c"># add select morph. feats to coarse POS tags</span>
		<span class="n">SELECTMORPH</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;eigen&#39;</span><span class="p">,</span> <span class="s">&#39;det&#39;</span><span class="p">,</span> <span class="s">&#39;pron&#39;</span><span class="p">,</span> <span class="s">&#39;init&#39;</span><span class="p">,</span> <span class="s">&#39;fin&#39;</span><span class="p">,</span> <span class="s">&#39;neven&#39;</span><span class="p">,</span> <span class="s">&#39;onder&#39;</span><span class="p">,</span>
				<span class="s">&#39;prenom&#39;</span><span class="p">,</span> <span class="s">&#39;nom&#39;</span><span class="p">,</span> <span class="s">&#39;vrij&#39;</span><span class="p">,</span> <span class="s">&#39;pv&#39;</span><span class="p">,</span> <span class="s">&#39;inf&#39;</span><span class="p">,</span> <span class="s">&#39;vd&#39;</span><span class="p">,</span> <span class="s">&#39;od&#39;</span><span class="p">}</span>
		<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
			<span class="n">selected</span> <span class="o">=</span> <span class="p">[</span><span class="n">feat</span> <span class="k">for</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">morphfeats</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
					<span class="k">if</span> <span class="n">feat</span> <span class="ow">in</span> <span class="n">SELECTMORPH</span><span class="p">]</span>
			<span class="n">pos</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="s">&#39;/</span><span class="si">%s</span><span class="s">[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">selected</span><span class="p">))</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nlpercolatemorph&#39;</span><span class="p">:</span>  <span class="c"># percolate select morph tags upwards</span>
		<span class="n">PERCOLATE</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;pv&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;inf&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
		<span class="k">for</span> <span class="n">feat</span><span class="p">,</span> <span class="n">lvl</span> <span class="ow">in</span> <span class="n">PERCOLATE</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="n">feat</span><span class="p">:</span> <span class="n">n</span>
					<span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">morphfeats</span><span class="p">(</span><span class="n">n</span><span class="p">)):</span>
				<span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">pos</span><span class="o">.</span><span class="n">parent</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">lvl</span> <span class="ow">and</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>
						<span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">feat</span><span class="p">):</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="n">feat</span>
					<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
					<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nlmwuhead&#39;</span><span class="p">:</span>  <span class="c"># add label of head child to MWU nodes</span>
		<span class="n">EXPANDCAT</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;MWU&#39;</span><span class="p">}</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="n">EXPANDCAT</span><span class="p">):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">+=</span> <span class="n">STATESPLIT</span> <span class="o">+</span> <span class="nb">next</span><span class="p">(</span>
					<span class="nb">iter</span><span class="p">(</span><span class="n">strip</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span>
					<span class="k">if</span> <span class="n">ishead</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">or</span> <span class="n">a</span> <span class="ow">is</span> <span class="n">node</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nladdunary&#39;</span><span class="p">:</span>  <span class="c"># introduce unary NPs</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="s">&#39;vnw&#39;</span><span class="p">}</span>
				<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;SMAIN&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;INF&#39;</span><span class="p">}):</span>
			<span class="n">children</span> <span class="o">=</span> <span class="n">node</span><span class="p">[:]</span>
			<span class="n">node</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[]</span>
			<span class="n">tag</span> <span class="o">=</span> <span class="n">ParentedTree</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">children</span><span class="p">)</span>
			<span class="n">tag</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[:]</span>
			<span class="n">node</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">tag</span><span class="p">]</span>
			<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;NP&#39;</span>
			<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
			<span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isupper</span><span class="p">():</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;HD&#39;</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">tag</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;hd&#39;</span>
	<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nlelimcnj&#39;</span><span class="p">:</span>  <span class="c"># assign conjuncts the function of the parent</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">function</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;cnj&#39;</span><span class="p">):</span>
			<span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">False</span>
	<span class="k">return</span> <span class="bp">True</span>


<div class="viewcode-block" id="reversetransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.reversetransform">[docs]</a><span class="k">def</span> <span class="nf">reversetransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">transformations</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Undo specified transformations and remove state splits marked by ``^``.</span>

<span class="sd">	Do not apply twice (might remove VPs which shouldn&#39;t be).&quot;&quot;&quot;</span>
	<span class="c"># Generic state-split removal</span>
	<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">STATESPLIT</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
		<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">[:</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">STATESPLIT</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
	<span class="c"># restore linear precedence ordering</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
	<span class="c"># unfreeze attributes so that they can be modified</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">):</span>
			<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">)</span>

	<span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">transformations</span><span class="p">):</span>
		<span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FANOUT&#39;</span><span class="p">:</span>
			<span class="n">removefanoutmarkers</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">:</span>  <span class="c"># remove DPs</span>
			<span class="k">for</span> <span class="n">dp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;DP&#39;</span><span class="p">):</span>
				<span class="n">dp</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;NP&#39;</span>
				<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">:</span>
					<span class="c"># dp1 = dp[1][:]</span>
					<span class="c"># dp[1][:] = []</span>
					<span class="c"># dp[1:] = dp1</span>
					<span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][:],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">dp</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;NEST&#39;</span><span class="p">:</span>  <span class="c"># flatten adjunctions</span>
			<span class="n">nkonly</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;PDAT&#39;</span><span class="p">,</span> <span class="s">&#39;CAP&#39;</span><span class="p">,</span> <span class="s">&#39;PPOSS&#39;</span><span class="p">,</span> <span class="s">&#39;PPOSAT&#39;</span><span class="p">,</span> <span class="s">&#39;ADJA&#39;</span><span class="p">,</span> <span class="s">&#39;FM&#39;</span><span class="p">,</span> <span class="s">&#39;PRF&#39;</span><span class="p">,</span>
					<span class="s">&#39;NM&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">,</span> <span class="s">&#39;NE&#39;</span><span class="p">,</span> <span class="s">&#39;PIAT&#39;</span><span class="p">,</span> <span class="s">&#39;PRELS&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">,</span> <span class="s">&#39;TRUNC&#39;</span><span class="p">,</span> <span class="s">&#39;CH&#39;</span><span class="p">,</span>
					<span class="s">&#39;CNP&#39;</span><span class="p">,</span> <span class="s">&#39;PWAT&#39;</span><span class="p">,</span> <span class="s">&#39;PDS&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;CS&#39;</span><span class="p">,</span> <span class="s">&#39;CARD&#39;</span><span class="p">,</span> <span class="s">&#39;ART&#39;</span><span class="p">,</span> <span class="s">&#39;PWS&#39;</span><span class="p">,</span>
					<span class="s">&#39;PPER&#39;</span><span class="p">}</span>
			<span class="n">probably_nk</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;AP&#39;</span><span class="p">,</span> <span class="s">&#39;PIS&#39;</span><span class="p">}</span> <span class="o">|</span> <span class="n">nkonly</span>
			<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span>
						<span class="ow">and</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;NP&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
						<span class="ow">and</span> <span class="ow">not</span> <span class="nb">set</span><span class="p">(</span><span class="n">labels</span><span class="p">(</span><span class="n">n</span><span class="p">))</span> <span class="o">&amp;</span> <span class="n">probably_nk</span><span class="p">):</span>
					<span class="n">n</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
					<span class="n">n</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">n</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PP-NP&#39;</span><span class="p">:</span>  <span class="c"># flatten PPs</span>
			<span class="k">for</span> <span class="n">pp</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;PP&#39;</span><span class="p">):</span>
				<span class="k">if</span> <span class="s">&#39;NP&#39;</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="ow">and</span> <span class="s">&#39;NN&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">(</span><span class="n">pp</span><span class="p">):</span>
					<span class="c"># ensure NP is in last position</span>
					<span class="n">pp</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
					<span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:],</span> <span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">pp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span><span class="p">:</span>  <span class="c"># merge extra S level</span>
			<span class="k">for</span> <span class="n">sbar</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;SBAR&#39;</span>
					<span class="ow">or</span> <span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>
						<span class="ow">and</span> <span class="n">labels</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">==</span> <span class="p">[</span><span class="s">&#39;PTKANT&#39;</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">]))):</span>
				<span class="n">sbar</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span>
				<span class="k">if</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">:</span>
					<span class="n">sbar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">+</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">sbar</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">sbar</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sbar</span><span class="p">[</span><span class="mi">1</span><span class="p">][:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;VP-FIN_NEGRA&#39;</span><span class="p">:</span>
			<span class="k">def</span> <span class="nf">mergevp</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
				<span class="sd">&quot;&quot;&quot;Merge finite VP with S level.&quot;&quot;&quot;</span>
				<span class="k">for</span> <span class="n">vp</span> <span class="ow">in</span> <span class="p">(</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;VP&#39;</span><span class="p">):</span>
					<span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;FIN&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">]):</span>
						<span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">][:],</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">:</span><span class="n">vp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span> <span class="n">s</span><span class="p">[</span><span class="n">vp</span><span class="p">][:]</span>
			<span class="c"># if any(a.label == &#39;S&#39; for a in tree):</span>
			<span class="c"># 	map(mergevp, [a for a in tree if a.label == &#39;S&#39;])</span>
			<span class="c"># elif any(a.label == &#39;CS&#39; for a in tree):</span>
			<span class="c"># 	map(mergevp, [s for cs in tree for s in cs if cs.label == &#39;CS&#39;</span>
			<span class="c"># 		and s.label == &#39;S&#39;])</span>
			<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
				<span class="n">mergevp</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;POS-PART&#39;</span><span class="p">:</span>
			<span class="c"># remove constituents for particle verbs</span>
			<span class="c"># get the grandfather of each verb particle</span>
			<span class="n">hasparticle</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">any</span><span class="p">(</span><span class="s">&#39;PTKVZ&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">label</span>
					<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">m</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">n</span>
					<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="n">hasparticle</span><span class="p">)):</span>
				<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
					<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">)</span>
						<span class="ow">and</span> <span class="s">&#39;PTKVZ&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span>
							<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">Tree</span><span class="p">))</span>
						<span class="ow">and</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">b</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">)):</span>
						<span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;addUnary&#39;</span><span class="p">:</span>
			<span class="c"># remove phrasal projections for single tokens</span>
			<span class="c"># e.g. S =&gt; NP =&gt; NN becomes S =&gt; NN</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
					<span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">,</span> <span class="s">&#39;ROOT&#39;</span><span class="p">,</span> <span class="s">&#39;DL&#39;</span><span class="p">}):</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">base</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
							<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NN&#39;</span><span class="p">,</span> <span class="s">&#39;PPER&#39;</span><span class="p">,</span> <span class="s">&#39;PDS&#39;</span><span class="p">,</span>
								<span class="s">&#39;PIS&#39;</span><span class="p">,</span> <span class="s">&#39;PRELS&#39;</span><span class="p">,</span> <span class="s">&#39;CARD&#39;</span><span class="p">,</span> <span class="s">&#39;PN&#39;</span><span class="p">}):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
						<span class="n">origfunc</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
						<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
							<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">origfunc</span>
						<span class="n">children</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
						<span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">[]</span>
						<span class="n">child</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">children</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;elimNKCJ&#39;</span><span class="p">:</span>  <span class="c"># restore NK and CJ functions</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
					<span class="ow">in</span> <span class="p">{</span><span class="s">&#39;NP&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">}):</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
					<span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;HD&#39;</span><span class="p">:</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;NK&#39;</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
					<span class="ow">in</span> <span class="p">{</span><span class="s">&#39;CS&#39;</span><span class="p">,</span> <span class="s">&#39;CNP&#39;</span><span class="p">,</span> <span class="s">&#39;CVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAP&#39;</span><span class="p">,</span> <span class="s">&#39;CAVP&#39;</span><span class="p">,</span> <span class="s">&#39;CAC&#39;</span><span class="p">}):</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
					<span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;CD&#39;</span><span class="p">:</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;CJ&#39;</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nladdunary&#39;</span><span class="p">:</span>  <span class="c"># remove unary node</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span>
					<span class="n">strip</span><span class="p">(</span><span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;SMAIN&#39;</span><span class="p">,</span> <span class="s">&#39;PP&#39;</span><span class="p">,</span> <span class="s">&#39;INF&#39;</span><span class="p">}):</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">base</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">)</span>
							<span class="ow">and</span> <span class="n">strip</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;n&#39;</span><span class="p">,</span> <span class="s">&#39;vnw&#39;</span><span class="p">}):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
						<span class="n">origfunc</span> <span class="o">=</span> <span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
						<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">:</span>
							<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">origfunc</span>
						<span class="n">children</span> <span class="o">=</span> <span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span>
						<span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">=</span> <span class="p">[]</span>
						<span class="n">child</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">children</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;nlelimcnj&#39;</span><span class="p">:</span>  <span class="c"># restore cnj function</span>
			<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">base</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s">&#39;CONJ&#39;</span><span class="p">)):</span>
				<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
					<span class="k">if</span> <span class="n">function</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;crd&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">base</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s">&#39;let&#39;</span><span class="p">):</span>
						<span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;cnj&#39;</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;APPEND-FUNC&#39;</span><span class="p">:</span>  <span class="c"># functions appended to phrasal labels</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="s">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span>
					<span class="ow">and</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
					<span class="ow">and</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)):</span>  <span class="c"># -LRB-</span>
				<span class="n">label</span><span class="p">,</span> <span class="n">func</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
		<span class="c"># morphological features appended to phrasal labels</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s">&#39;APPEND-MORPH&#39;</span><span class="p">,</span> <span class="s">&#39;addCase&#39;</span><span class="p">,</span> <span class="s">&#39;nlselectmorph&#39;</span><span class="p">}:</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
				<span class="k">if</span> <span class="s">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
					<span class="n">label</span><span class="p">,</span> <span class="n">morph</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
					<span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
						<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">label</span>
					<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">,</span> <span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">,</span> <span class="s">&#39;)&#39;</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;FUNC-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with function above phrasal labels</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>
					<span class="ow">and</span> <span class="ow">not</span> <span class="n">n</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>  <span class="c"># -LRB-</span>
					<span class="ow">and</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">))):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;MORPH-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with morph. above preterminals</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">))):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
		<span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&#39;LEMMA-NODE&#39;</span><span class="p">:</span>  <span class="c"># nodes with lemmas above words</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">postorder</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)</span>
					<span class="ow">and</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">))):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">LEMMA</span><span class="p">]</span> <span class="o">=</span> <span class="n">unquote</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
				<span class="n">a</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">label</span>
				<span class="n">a</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]))][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

	<span class="c"># restore linear precedence ordering</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
		<span class="n">a</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">n</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">tree</span>

</div>
<div class="viewcode-block" id="collapselabels"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.collapselabels">[docs]</a><span class="k">def</span> <span class="nf">collapselabels</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">_sents</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">tbmapping</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Collapse non-root phrasal labels with specified mapping.</span>

<span class="sd">	Trees are modified in-place.</span>

<span class="sd">	:param tbmapping: a mapping of treebank labels of the form::</span>

<span class="sd">			{coarselabel1: {finelabel1, finelabel2, ...}, ...}</span>

<span class="sd">		Cf. ``treebanktransforms.MAPPINGS``</span>
<span class="sd">	:returns: a tuple ``(trees, mapping)`` with the transformed trees</span>
<span class="sd">		and a mapping of their original labels to the collapsed labels.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">collapse</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Collapse labels of a single tree.&quot;&quot;&quot;</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">islice</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">node</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
				<span class="c"># anything not part of the mapping is stripped</span>
				<span class="c"># (state splits, function tags, &amp;c.)</span>
				<span class="n">mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">LABELRE</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
						<span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">revmapping</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(),</span> <span class="s">&#39;&#39;</span><span class="p">),</span>
						<span class="c"># lambda x: revmapping[x.group()],</span>
						<span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s">&#39;^&#39;</span><span class="p">)</span>
				<span class="k">assert</span> <span class="n">mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="ow">and</span> <span class="n">mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isalpha</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
				<span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span>

	<span class="c"># maps original treebank labels to coarser labels; e.g. NP =&gt; X</span>
	<span class="n">revmapping</span> <span class="o">=</span> <span class="p">{</span><span class="n">finelabel</span><span class="p">:</span> <span class="n">coarselabel</span> <span class="k">for</span> <span class="n">coarselabel</span> <span class="ow">in</span> <span class="n">tbmapping</span>
			<span class="k">for</span> <span class="n">finelabel</span> <span class="ow">in</span> <span class="n">tbmapping</span><span class="p">[</span><span class="n">coarselabel</span><span class="p">]}</span>
	<span class="c"># maps labels after binarization and other transformations,</span>
	<span class="c"># e.g., NP&lt;DT,JJ,NN&gt; =&gt; X&lt;X,X,X&gt;</span>
	<span class="n">mapping</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;Epsilon&#39;</span><span class="p">:</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">,</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">:</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">}</span>
	<span class="c"># collect POS tags, will not be changed</span>
	<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">)):</span>
			<span class="n">mapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
			<span class="n">revmapping</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span>
	<span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
		<span class="n">collapse</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">trees</span><span class="p">,</span> <span class="n">mapping</span>

</div>
<div class="viewcode-block" id="rrtransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rrtransform">[docs]</a><span class="k">def</span> <span class="nf">rrtransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">morphlevels</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">adjunctionlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignorefunctions</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ignorecategories</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">adjleft</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">adjright</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Relational-realizational tree transformation.</span>

<span class="sd">	Every constituent node is expanded to three levels:</span>

<span class="sd">	1) syntactic category, e.g., S</span>
<span class="sd">	2) unordered functional argument structure of children, e.g., S/&lt;SBJ,HD,OBJ&gt;</span>
<span class="sd">	3) for each child:</span>
<span class="sd">		grammatical function + parent syntactic category, e.g., OBJ/S</span>

<span class="sd">	Example::</span>

<span class="sd">		(NP-SBJ (NN-HD ...)) =&gt; (NP (&lt;HD&gt;/NP (HD/NP (NN ...))))</span>

<span class="sd">	:param adjunctionlabel: a grammatical function label identifying</span>
<span class="sd">			adjunctions. They will not be part of argument structures, and</span>
<span class="sd">			their grammatical function will be replaced with their neighboring</span>
<span class="sd">			non-adjunctive functions.</span>
<span class="sd">	:param adjleft, adjright: whether to include the left and right sibling,</span>
<span class="sd">			respectively, when replacing the function label for</span>
<span class="sd">			``adjunctionlabel``.</span>
<span class="sd">	:param ignorefunctions: function labels that do not go into argument</span>
<span class="sd">			structure, but keep their function in their realization to make</span>
<span class="sd">			backtransform possible.</span>
<span class="sd">	:param morphlevels: if nonzero, percolate morphological features this many</span>
<span class="sd">			levels upwards. For a given node, the union of the features of its</span>
<span class="sd">			children are collected, and the result is appended to its syntactic</span>
<span class="sd">			category.</span>
<span class="sd">	:param percolatefeatures: if a sequence is given, percolate only these</span>
<span class="sd">			morphological features; by default all features are used.</span>
<span class="sd">	:returns: a new, transformed tree.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">realize</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Generate realization of a child node by recursion.&quot;&quot;&quot;</span>
		<span class="n">newchild</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">rrtransform</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">morphlevels</span><span class="p">,</span>
				<span class="n">percolatefeatures</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="p">,</span> <span class="n">ignorefunctions</span><span class="p">,</span>
				<span class="n">ignorecategories</span><span class="p">,</span> <span class="n">adjleft</span><span class="p">,</span> <span class="n">adjright</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">:</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span><span class="p">)</span>
				<span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">==</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="p">(</span><span class="n">prevfunc</span> <span class="ow">or</span> <span class="n">nextfunc</span><span class="p">)</span>
				<span class="k">else</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]),</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">),</span> <span class="p">[</span><span class="n">newchild</span><span class="p">])</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span>

	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
		<span class="n">morph</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
		<span class="n">preterminal</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">morph</span><span class="p">),</span> <span class="n">tree</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">morphlevels</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">preterminal</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">morphlevels</span>
		<span class="k">return</span> <span class="n">preterminal</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span>
	<span class="c"># for each node, collect the functions of closest non-adjunctive sibling</span>
	<span class="n">childfuncsl</span> <span class="o">=</span> <span class="p">(</span><span class="n">prevfunc</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">):</span>
			<span class="n">prevfunc</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
		<span class="n">childfuncsl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prevfunc</span><span class="p">)</span>
	<span class="n">childfuncsr</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextfunc</span><span class="p">,</span> <span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;&#39;</span><span class="p">]</span>
	<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
				<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">):</span>
			<span class="n">nextfunc</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
		<span class="n">childfuncsr</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">)</span>
	<span class="n">funcstr</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span>
			<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">!=</span> <span class="n">adjunctionlabel</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorefunctions</span>
					<span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignorecategories</span><span class="p">))</span>
	<span class="n">children</span><span class="p">,</span> <span class="n">feats</span><span class="p">,</span> <span class="n">levels</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">child</span><span class="p">,</span> <span class="n">prevfunc</span><span class="p">,</span> <span class="n">nextfunc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">childfuncsl</span><span class="p">,</span> <span class="n">childfuncsr</span><span class="p">):</span>
		<span class="n">newchild</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">realize</span><span class="p">(</span><span class="n">child</span><span class="p">,</span>
				<span class="n">prevfunc</span> <span class="k">if</span> <span class="n">adjleft</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">,</span>
				<span class="n">nextfunc</span> <span class="k">if</span> <span class="n">adjright</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
		<span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newchild</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">morph</span> <span class="ow">and</span> <span class="n">lvl</span><span class="p">:</span>
			<span class="n">feats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">morph</span><span class="p">)</span>
			<span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lvl</span><span class="p">)</span>
	<span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">0</span>
	<span class="k">if</span> <span class="n">feats</span> <span class="ow">and</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="ow">and</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="s">&#39;ROOT&#39;</span><span class="p">:</span>
		<span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span> <span class="o">=</span> <span class="n">unifymorphfeat</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">levels</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="n">configuration</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">/&lt;</span><span class="si">%s</span><span class="s">&gt;&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">funcstr</span><span class="p">),</span>
			<span class="n">children</span><span class="p">)</span>
	<span class="n">projection</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="s">-</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">morph</span><span class="p">))</span> <span class="k">if</span> <span class="n">morph</span>
			<span class="k">else</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">[</span><span class="n">configuration</span><span class="p">])</span>
	<span class="k">return</span> <span class="n">projection</span><span class="p">,</span> <span class="n">morph</span><span class="p">,</span> <span class="n">lvl</span>

</div>
<div class="viewcode-block" id="rrbacktransform"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rrbacktransform">[docs]</a><span class="k">def</span> <span class="nf">rrbacktransform</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Reverse relational-realizational transformation.</span>

<span class="sd">	:param adjunctionlabel: used to assign a grammatical function to</span>
<span class="sd">		adjunctions that have been converted to contextual labels &#39;next:prev&#39;.</span>
<span class="sd">	:param func: used internally to percolate functional labels.</span>
<span class="sd">	:returns: a new tree.&quot;&quot;&quot;</span>
	<span class="n">morph</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
		<span class="n">tag</span><span class="p">,</span> <span class="n">morph</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
	<span class="k">elif</span> <span class="s">&#39;/&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
				<span class="p">[</span><span class="n">rrbacktransform</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">adjunctionlabel</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
				<span class="p">[</span><span class="n">rrbacktransform</span><span class="p">(</span>
						<span class="n">child</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
						<span class="n">adjunctionlabel</span><span class="p">,</span>
						<span class="n">child</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
					<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
	<span class="n">result</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;--&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">6</span>
	<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">TAG</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">label</span>
	<span class="k">if</span> <span class="n">morph</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span> <span class="o">=</span> <span class="n">morph</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">,</span> <span class="s">&#39;(&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">,</span> <span class="s">&#39;)&#39;</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">func</span> <span class="ow">and</span> <span class="n">adjunctionlabel</span> <span class="ow">and</span> <span class="s">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">func</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjunctionlabel</span>
	<span class="k">elif</span> <span class="n">func</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>
	<span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="rindex"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.rindex">[docs]</a><span class="k">def</span> <span class="nf">rindex</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Like list.index(), but go from right to left.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="labels"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.labels">[docs]</a><span class="k">def</span> <span class="nf">labels</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: the labels of the children of this node.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)]</span>

</div>
<div class="viewcode-block" id="pop"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.pop">[docs]</a><span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Remove this node from its parent node, if it has one.</span>

<span class="sd">	Convenience function for ParentedTrees.&quot;&quot;&quot;</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">parent_index</span><span class="p">)</span>
	<span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">a</span>

</div>
<span class="k">def</span> <span class="nf">base</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">match</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Test whether ``node.label`` equals ``match`` after stripping features.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="o">==</span> <span class="n">match</span>
			<span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">match</span> <span class="o">+</span> <span class="n">STATESPLIT</span><span class="p">)</span>
			<span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">label</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">match</span> <span class="o">+</span> <span class="s">&#39;-&#39;</span><span class="p">))</span>


<div class="viewcode-block" id="strip"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.strip">[docs]</a><span class="k">def</span> <span class="nf">strip</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Equivalent to the effect of the @ operator in tregex.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="s">&#39;-&#39;</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">label</span><span class="p">[:</span><span class="n">label</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)]</span>
	<span class="k">elif</span> <span class="n">STATESPLIT</span> <span class="ow">in</span> <span class="n">label</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">label</span><span class="p">[:</span><span class="n">label</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">STATESPLIT</span><span class="p">)]</span>
	<span class="k">return</span> <span class="n">label</span>

</div>
<div class="viewcode-block" id="ancestors"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.ancestors">[docs]</a><span class="k">def</span> <span class="nf">ancestors</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Yield ancestors of node from direct parent to root node.&quot;&quot;&quot;</span>
	<span class="k">while</span> <span class="n">node</span><span class="p">:</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">parent</span>
		<span class="k">yield</span> <span class="n">node</span>

</div>
<div class="viewcode-block" id="bracketings"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.bracketings">[docs]</a><span class="k">def</span> <span class="nf">bracketings</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Labeled bracketings of a tree.&quot;&quot;&quot;</span>
	<span class="k">return</span> <span class="p">[(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">leaves</span><span class="p">())))</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">))]</span>


<span class="c"># morphological features</span></div>
<div class="viewcode-block" id="morphfeats"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.morphfeats">[docs]</a><span class="k">def</span> <span class="nf">morphfeats</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Return the morphological features of a preterminal node.</span>

<span class="sd">	Features may be separated by dots or commas.&quot;&quot;&quot;</span>
	<span class="n">morph</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">MORPH</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="n">morph</span> <span class="o">=</span> <span class="n">morph</span><span class="p">[</span><span class="n">morph</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">morph</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">)]</span>
	<span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">{}</span>
	<span class="k">return</span> <span class="n">morph</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="unifymorphfeat"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.unifymorphfeat">[docs]</a><span class="k">def</span> <span class="nf">unifymorphfeat</span><span class="p">(</span><span class="n">feats</span><span class="p">,</span> <span class="n">percolatefeatures</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Get the sorted union of features for a sequence of feature vectors.</span>

<span class="sd">	:param feats: a sequence of strings of comma/dot separated feature vectors.</span>
<span class="sd">	:param percolatefeatures: if a set is given, select only these features;</span>
<span class="sd">		by default all features are used.</span>

<span class="sd">	&gt;&gt;&gt; print(unifymorphfeat({&#39;Def.*.*&#39;, &#39;*.Sg.*&#39;, &#39;*.*.Akk&#39;}))</span>
<span class="sd">	Akk.Def.Sg</span>
<span class="sd">	&gt;&gt;&gt; print(unifymorphfeat({&#39;LID[bep,stan,rest]&#39;, &#39;N[soort,ev,zijd,stan]&#39;}))</span>
<span class="sd">	bep,ev,rest,soort,stan,zijd&quot;&quot;&quot;</span>
	<span class="n">sep</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">feats</span><span class="p">)</span> <span class="k">else</span> <span class="s">&#39;,&#39;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">feats</span><span class="p">:</span>
		<span class="k">if</span> <span class="s">&#39;[&#39;</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;[&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">a</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;]&#39;</span><span class="p">)]</span>
		<span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">percolatefeatures</span><span class="p">:</span>
		<span class="n">result</span><span class="o">.</span><span class="n">intersection_update</span><span class="p">(</span><span class="n">percolatefeatures</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">result</span> <span class="o">-</span> <span class="p">{</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">&#39;--&#39;</span><span class="p">}))</span>


<span class="c"># Function tags</span></div>
<div class="viewcode-block" id="function"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.function">[docs]</a><span class="k">def</span> <span class="nf">function</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: The first function tag for node, or the empty string.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="s">&#39;&#39;</span>
	<span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="functions"><a class="viewcode-back" href="../../api/discodop.treebanktransforms.html#discodop.treebanktransforms.functions">[docs]</a><span class="k">def</span> <span class="nf">functions</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: list of function tags for node, or an empty list.&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="s">&#39;source&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;--&#39;</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">[]</span>
	<span class="k">return</span> <span class="n">tree</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">FUNC</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;-&#39;</span><span class="p">)</span>

</div>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;expandpresets&#39;</span><span class="p">,</span> <span class="s">&#39;transform&#39;</span><span class="p">,</span> <span class="s">&#39;reversetransform&#39;</span><span class="p">,</span> <span class="s">&#39;collapselabels&#39;</span><span class="p">,</span>
		<span class="s">&#39;rrtransform&#39;</span><span class="p">,</span> <span class="s">&#39;rrbacktransform&#39;</span><span class="p">,</span> <span class="s">&#39;rindex&#39;</span><span class="p">,</span> <span class="s">&#39;labels&#39;</span><span class="p">,</span> <span class="s">&#39;pop&#39;</span><span class="p">,</span> <span class="s">&#39;strip&#39;</span><span class="p">,</span>
		<span class="s">&#39;ancestors&#39;</span><span class="p">,</span> <span class="s">&#39;bracketings&#39;</span><span class="p">,</span> <span class="s">&#39;morphfeats&#39;</span><span class="p">,</span> <span class="s">&#39;unifymorphfeat&#39;</span><span class="p">,</span> <span class="s">&#39;function&#39;</span><span class="p">,</span>
		<span class="s">&#39;functions&#39;</span><span class="p">]</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref.html">Reference</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>