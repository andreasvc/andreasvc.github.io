<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.grammar &mdash; Disco-DOP 0.5pre1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.5pre1 documentation" href="../../index.html" />
    <link rel="up" title="Module code" href="../index.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for discodop.grammar</h1><div class="highlight"><pre>
<span class="sd">&quot;&quot;&quot;Assorted functions to read off grammars from treebanks.&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> \
		<span class="n">unicode_literals</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">gzip</span>
<span class="kn">import</span> <span class="nn">codecs</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">mul</span><span class="p">,</span> <span class="n">itemgetter</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">count</span><span class="p">,</span> <span class="n">islice</span><span class="p">,</span> <span class="n">repeat</span>
<span class="k">try</span><span class="p">:</span>
	<span class="kn">from</span> <span class="nn">cyordereddict</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
	<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">discodop.tree</span> <span class="kn">import</span> <span class="n">Tree</span><span class="p">,</span> <span class="n">ImmutableTree</span><span class="p">,</span> <span class="n">DiscTree</span>
<span class="kn">from</span> <span class="nn">discodop.treebank</span> <span class="kn">import</span> <span class="n">READERS</span><span class="p">,</span> <span class="n">termindices</span><span class="p">,</span> <span class="n">openread</span>
<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="s">&#39;3&#39;</span><span class="p">:</span>
	<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>  <span class="c"># pylint: disable=redefined-builtin</span>

<span class="n">SHORTUSAGE</span> <span class="o">=</span> <span class="s">&#39;&#39;&#39;Read off grammars from treebanks.</span>
<span class="s">Usage: </span><span class="si">%(cmd)s</span><span class="s"> &lt;type&gt; &lt;input&gt; &lt;output&gt; [options]</span>
<span class="s">or: </span><span class="si">%(cmd)s</span><span class="s"> param &lt;parameter-file&gt; &lt;output-directory&gt;</span>
<span class="s">or: </span><span class="si">%(cmd)s</span><span class="s"> info &lt;rules-file&gt;</span>
<span class="s">or: </span><span class="si">%(cmd)s</span><span class="s"> merge (rules|lexicon|fragments) &lt;input1&gt; &lt;input2&gt;... &lt;output&gt;</span><span class="se">\</span>
<span class="s">&#39;&#39;&#39;</span> <span class="o">%</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cmd</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">RULERE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
		<span class="s">r&#39;(?P&lt;RULE1&gt;(?P&lt;LHS1&gt;[^ \t]+).*)\t&#39;</span>
		<span class="s">r&#39;(?P&lt;WEIGHT1&gt;(?P&lt;FREQ1&gt;[-.e0-9]+)(?:\/[0-9]+)?)$&#39;</span>
		<span class="s">r&#39;|(?P&lt;FREQ2&gt;[-.e0-9]+)\t(?P&lt;RULE2&gt;(?P&lt;LHS2&gt;[^ \t]+).*)$&#39;</span><span class="p">)</span>
<span class="n">FRONTIERORTERM</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&quot;\(([^ ]+)( [0-9]+)(?: [0-9]+)*\)&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="lcfrsproductions"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.lcfrsproductions">[docs]</a><span class="k">def</span> <span class="nf">lcfrsproductions</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">frontiers</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Read off LCFRS productions from a tree with indices and a sentence.</span>

<span class="sd">	Tree should contain integer indices as terminals, and a sentence with the</span>
<span class="sd">	corresponding words for these indices. Always produces monotone LCFRS</span>
<span class="sd">	rules. For best results, tree should be canonicalized. When ``frontiers``</span>
<span class="sd">	is ``True``, frontier nodes will generate empty productions, by default</span>
<span class="sd">	they are ignored.</span>

<span class="sd">	&gt;&gt;&gt; tree = Tree(&quot;(S (VP_2 (V 0) (ADJ 2)) (NP 1))&quot;)</span>
<span class="sd">	&gt;&gt;&gt; sent = &quot;is Mary happy&quot;.split()</span>
<span class="sd">	&gt;&gt;&gt; print(&#39;\\n&#39;.join(printrule(r, yf)  # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">	...		for r, yf in lcfrsproductions(tree, sent)))</span>
<span class="sd">	010	S =&gt; VP_2 NP</span>
<span class="sd">	0,1	VP_2 =&gt; V ADJ</span>
<span class="sd">	is	V =&gt; Epsilon</span>
<span class="sd">	happy	ADJ =&gt; Epsilon</span>
<span class="sd">	Mary	NP =&gt; Epsilon&quot;&quot;&quot;</span>
	<span class="n">leaves</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">leaves</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">leaves</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;indices should be unique. indices: </span><span class="si">%r</span><span class="se">\n</span><span class="s">tree: </span><span class="si">%s</span><span class="s">&#39;</span>
				<span class="o">%</span> <span class="p">(</span><span class="n">leaves</span><span class="p">,</span> <span class="n">tree</span><span class="p">))</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">sent</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no sentence.</span><span class="se">\n</span><span class="s">tree: </span><span class="si">%s</span><span class="se">\n</span><span class="s">indices: </span><span class="si">%r</span><span class="se">\n</span><span class="s">sent: </span><span class="si">%r</span><span class="s">&#39;</span>
				<span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">pprint</span><span class="p">(),</span> <span class="n">leaves</span><span class="p">,</span> <span class="n">sent</span><span class="p">))</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;indices should be integers.</span><span class="se">\n</span><span class="s">tree: </span><span class="si">%s</span><span class="se">\n</span><span class="s">indices: </span><span class="si">%r</span><span class="se">\n</span><span class="s">&#39;</span>
				<span class="s">&#39;sent: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">pprint</span><span class="p">(),</span> <span class="n">leaves</span><span class="p">,</span> <span class="n">sent</span><span class="p">))</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sent</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">leaves</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;indices should point to a word in the sentence.</span><span class="se">\n</span><span class="s">&#39;</span>
			<span class="s">&#39;tree: </span><span class="si">%s</span><span class="se">\n</span><span class="s">indices: </span><span class="si">%r</span><span class="se">\n</span><span class="s">sent: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">pprint</span><span class="p">(),</span> <span class="n">leaves</span><span class="p">,</span> <span class="n">sent</span><span class="p">))</span>
	<span class="n">rules</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">st</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">():</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">st</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">((</span><span class="s">&quot;Empty node. Frontier nodes should designate &quot;</span>
				<span class="s">&quot;which part(s) of the sentence they contribute to.</span><span class="se">\n</span><span class="s">tree:&quot;</span>
				<span class="s">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s">indices: </span><span class="si">%r</span><span class="se">\n</span><span class="s">sent: </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">pprint</span><span class="p">(),</span> <span class="n">leaves</span><span class="p">,</span> <span class="n">sent</span><span class="p">)))</span>
		<span class="c"># elif all(isinstance(a, int) for a in st):</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sent</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>  <span class="c"># terminal node</span>
				<span class="n">rule</span> <span class="o">=</span> <span class="p">((</span><span class="n">st</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">),</span> <span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">))</span>
			<span class="k">elif</span> <span class="n">frontiers</span><span class="p">:</span>
				<span class="n">rule</span> <span class="o">=</span> <span class="p">((</span><span class="n">st</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">),</span> <span class="p">())</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="k">continue</span>
			<span class="c"># else:</span>
			<span class="c"># 	raise ValueError((&quot;Preterminals should dominate a single &quot;</span>
			<span class="c"># 		&quot;terminal; frontier nodes should dominate a sequence of &quot;</span>
			<span class="c"># 		&quot;indices that are None in the sentence.\n&quot;</span>
			<span class="c"># 		&quot;subtree: %s\nsent: %r&quot; % (st, sent)))</span>
		<span class="k">elif</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">st</span><span class="p">):</span>  <span class="c"># isinstance(st[0], Tree):</span>
			<span class="c"># convert leaves() to bitsets</span>
			<span class="n">childleaves</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">leaves</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Tree</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
					<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">st</span><span class="p">]</span>
			<span class="n">leaves</span> <span class="o">=</span> <span class="p">[(</span><span class="n">idx</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">childleaves</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">child</span><span class="p">]</span>
			<span class="n">leaves</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
			<span class="n">previdx</span><span class="p">,</span> <span class="n">prevparent</span> <span class="o">=</span> <span class="n">leaves</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
			<span class="n">yf</span> <span class="o">=</span> <span class="p">[[</span><span class="n">prevparent</span><span class="p">]]</span>
			<span class="k">while</span> <span class="n">leaves</span><span class="p">:</span>
				<span class="n">idx</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">leaves</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
				<span class="k">if</span> <span class="n">idx</span> <span class="o">!=</span> <span class="n">previdx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>  <span class="c"># a discontinuity</span>
					<span class="n">yf</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">parent</span><span class="p">])</span>
				<span class="k">elif</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">prevparent</span><span class="p">:</span>  <span class="c"># switch to a different non-terminal</span>
					<span class="n">yf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
				<span class="c"># otherwise terminal is part of current range</span>
				<span class="n">previdx</span><span class="p">,</span> <span class="n">prevparent</span> <span class="o">=</span> <span class="n">idx</span><span class="p">,</span> <span class="n">parent</span>
			<span class="n">nonterminals</span> <span class="o">=</span> <span class="p">(</span><span class="n">st</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">st</span><span class="p">)</span>
			<span class="n">rule</span> <span class="o">=</span> <span class="p">(</span><span class="n">nonterminals</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="n">yf</span><span class="p">)))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Neither Tree node nor integer index:</span><span class="se">\n</span><span class="s">&quot;</span>
				<span class="s">&quot;</span><span class="si">%r</span><span class="s">, </span><span class="si">%r</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">type</span><span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
		<span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">rules</span>

</div>
<div class="viewcode-block" id="treebankgrammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.treebankgrammar">[docs]</a><span class="k">def</span> <span class="nf">treebankgrammar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">extrarules</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Induce a probabilistic LCFRS with relative frequencies of productions.</span>

<span class="sd">	When trees contain no discontinuities, the result is equivalent to a</span>
<span class="sd">	treebank PCFG.</span>

<span class="sd">	:param extarules: A dictionary of productions that will be merged with the</span>
<span class="sd">		grammar, with (pseudo)frequencies as values.&quot;&quot;&quot;</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">rule</span> <span class="k">for</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">)</span>
			<span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">extrarules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">extrarules</span><span class="p">:</span>
			<span class="n">grammar</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span> <span class="o">+=</span> <span class="n">extrarules</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span>
	<span class="n">lhsfd</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="n">lhsfd</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">freq</span>
	<span class="k">return</span> <span class="n">sortgrammar</span><span class="p">((</span><span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">lhsfd</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
			<span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">freq</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>

</div>
<div class="viewcode-block" id="dopreduction"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.dopreduction">[docs]</a><span class="k">def</span> <span class="nf">dopreduction</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">packedgraph</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">decorater</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">extrarules</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Induce a reduction of DOP to an LCFRS.</span>

<span class="sd">	Similar to how Goodman (1996, 2003) reduces DOP to a PCFG.</span>

<span class="sd">	:param packedgraph: packed graph encoding (Bansal &amp; Klein 2010).</span>
<span class="sd">	:param decorator: a TreeDecorator instance (packedgraph is ignored if this</span>
<span class="sd">		is passed) .</span>
<span class="sd">	:returns: a set of rules with the relative frequency estimate as</span>
<span class="sd">		probilities, and a dictionary with alternate weights.&quot;&quot;&quot;</span>
	<span class="c"># fd: how many subtrees are headed by node X (e.g. NP or NP@1-2),</span>
	<span class="c"># 	counts of NP@... should sum to count of NP</span>
	<span class="c"># ntfd: frequency of a node in treebank</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="n">ntfd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="n">rules</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">decorater</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="n">decorater</span> <span class="o">=</span> <span class="n">TreeDecorator</span><span class="p">(</span><span class="n">memoize</span><span class="o">=</span><span class="n">packedgraph</span><span class="p">)</span>

	<span class="c"># collect rules</span>
	<span class="k">for</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">):</span>
		<span class="n">prods</span> <span class="o">=</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
		<span class="n">dectree</span> <span class="o">=</span> <span class="n">decorater</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
		<span class="n">uprods</span> <span class="o">=</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">dectree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
		<span class="n">nodefreq</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dectree</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">ntfd</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">avar</span><span class="p">),</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bvar</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prods</span><span class="p">,</span> <span class="n">uprods</span><span class="p">):</span>
			<span class="k">assert</span> <span class="n">avar</span> <span class="o">==</span> <span class="n">bvar</span>
			<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cartpi</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="k">else</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
					<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)]):</span>
				<span class="n">rules</span><span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="n">avar</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="n">extrarules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">extrarules</span><span class="p">:</span>
			<span class="n">rules</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span> <span class="o">+=</span> <span class="n">extrarules</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span>
			<span class="n">fd</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">extrarules</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span>

	<span class="k">def</span> <span class="nf">weights</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: rule with RFE and EWE probability.&quot;&quot;&quot;</span>
		<span class="c"># relative frequency estimate, aka DOP1 (Bod 1992; Goodman 1996, 2003)</span>
		<span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">rule</span>
		<span class="n">rfe</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span>
				<span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">),</span> <span class="n">fd</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
		<span class="c"># Bod (2003, figure 3): correction factor for number of subtrees.</span>
		<span class="c"># Caveat: the original formula (Goodman 2003, eq. 8.23) has a_j in the</span>
		<span class="c"># denominator of all rules; this is probably a misprint.</span>
		<span class="n">ewe</span> <span class="o">=</span> <span class="p">(</span><span class="nb">float</span><span class="p">((</span><span class="mi">1</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span>
				<span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">z</span><span class="p">]</span> <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">z</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
				<span class="o">/</span> <span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ntfd</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="c"># Goodman (2003, p 135). any rule corresponding to the introduction of</span>
		<span class="c"># a fragment has a probability of 1/2, else 1.</span>
		<span class="n">shortest</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span>
		<span class="c"># Goodman (2003, eq. 8.22). Prob. of fragment is reduced by factor of 2</span>
		<span class="c"># for each non-root non-terminal it contains.</span>
		<span class="n">bon</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">4</span> <span class="k">if</span> <span class="s">&#39;@&#39;</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">ntfd</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
		<span class="k">return</span> <span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">rfe</span><span class="p">),</span> <span class="n">ewe</span><span class="p">,</span> <span class="n">shortest</span><span class="p">,</span> <span class="n">bon</span>

	<span class="n">rules</span> <span class="o">=</span> <span class="n">sortgrammar</span><span class="p">(</span><span class="n">rules</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
	<span class="n">rules</span><span class="p">,</span> <span class="n">ewe</span><span class="p">,</span> <span class="n">shortest</span><span class="p">,</span> <span class="n">bon</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">weights</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">))</span>
	<span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">rules</span><span class="p">),</span> <span class="nb">dict</span><span class="p">(</span>
			<span class="n">ewe</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">ewe</span><span class="p">),</span> <span class="n">shortest</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">shortest</span><span class="p">),</span> <span class="n">bon</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">bon</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="doubledop"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.doubledop">[docs]</a><span class="k">def</span> <span class="nf">doubledop</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">maxdepth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
		<span class="n">maxfrontier</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">complement</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">numproc</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
		<span class="n">extrarules</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Extract a Double-DOP grammar from a treebank.</span>

<span class="sd">	That is, a fragment grammar containing fragments that occur at least twice,</span>
<span class="sd">	plus all individual productions needed to obtain full coverage.</span>
<span class="sd">	Input trees need to be binarized.</span>

<span class="sd">	:param binarized: Whether the resulting grammar should be binarized;</span>
<span class="sd">		this may be False when bitpar is used which applies its own</span>
<span class="sd">		binarization.</span>
<span class="sd">	:param maxdepth: add non-maximal/non-recurring fragments with depth</span>
<span class="sd">		`1 &lt; depth &lt; maxdepth`.</span>
<span class="sd">	:param maxfrontier: limit number of frontier non-terminals; not yet</span>
<span class="sd">		implemented.</span>
<span class="sd">	:param iterate, complement, numproc: cf. fragments.recurringfragments()</span>
<span class="sd">	:returns: a tuple (grammar, altweights, backtransform)</span>
<span class="sd">		altweights is a dictionary containing alternate weights.&quot;&quot;&quot;</span>

	<span class="kn">from</span> <span class="nn">discodop.fragments</span> <span class="kn">import</span> <span class="n">recurringfragments</span>
	<span class="n">fragments</span> <span class="o">=</span> <span class="n">recurringfragments</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">numproc</span><span class="p">,</span>
			<span class="n">maxdepth</span><span class="o">=</span><span class="n">maxdepth</span><span class="p">,</span> <span class="n">maxfrontier</span><span class="o">=</span><span class="n">maxfrontier</span><span class="p">,</span> <span class="n">iterate</span><span class="o">=</span><span class="n">iterate</span><span class="p">,</span>
			<span class="n">complement</span><span class="o">=</span><span class="n">complement</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">dopgrammar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="n">debug</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="n">binarized</span><span class="p">,</span>
			<span class="n">extrarules</span><span class="o">=</span><span class="n">extrarules</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="dop1"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.dop1">[docs]</a><span class="k">def</span> <span class="nf">dop1</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">maxdepth</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">maxfrontier</span><span class="o">=</span><span class="mi">999</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
		<span class="n">extrarules</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Return an all-fragments DOP1 model with relative frequencies.</span>

<span class="sd">	:param maxdepth: restrict fragments to `1 &lt; depth &lt; maxdepth`.</span>
<span class="sd">	:param maxfrontier: limit number of frontier non-terminals; not yet</span>
<span class="sd">		implemented.&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">discodop.fragments</span> <span class="kn">import</span> <span class="n">allfragments</span>
	<span class="n">fragments</span> <span class="o">=</span> <span class="n">allfragments</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">maxfrontier</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">dopgrammar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="n">binarized</span><span class="p">,</span>
			<span class="n">extrarules</span><span class="o">=</span><span class="n">extrarules</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="dopgrammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.dopgrammar">[docs]</a><span class="k">def</span> <span class="nf">dopgrammar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">fragments</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">extrarules</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Create a DOP grammar from a set of fragments and occurrences.</span>

<span class="sd">	A second level of binarization (a normal form) is needed when fragments are</span>
<span class="sd">	converted to individual grammar rules, which occurs through the removal of</span>
<span class="sd">	internal nodes. The binarization adds unique identifiers so that each</span>
<span class="sd">	grammar rule can be mapped back to its fragment. In fragments with</span>
<span class="sd">	terminals, we replace their POS tags with a tag uniquely identifying that</span>
<span class="sd">	terminal and tag: ``tag@word``.</span>

<span class="sd">	:param fragments: a dictionary of fragments from binarized trees, with</span>
<span class="sd">		occurrences as values (a mapping of sentence number to counts).</span>
<span class="sd">	:param binarized: Whether the resulting grammar should be binarized;</span>
<span class="sd">		this may be False when bitpar is used which applies its own</span>
<span class="sd">		binarization.</span>
<span class="sd">	:param extrarules: Additional rules to add to the grammar.</span>
<span class="sd">	:returns: a tuple (grammar, altweights, backtransform)</span>
<span class="sd">		altweights is a dictionary containing alternate weights.&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">getweight</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;:returns: frequency, EWE, and other weights for fragment.&quot;&quot;&quot;</span>
		<span class="n">freq</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">frag</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="n">frag</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)]</span>
		<span class="n">nonterms</span> <span class="o">=</span> <span class="n">frag</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="c"># Sangati &amp; Zuidema (2011, eq. 5)</span>
		<span class="c"># FIXME: verify that this formula is equivalent to Bod (2003).</span>
		<span class="n">ewe</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">/</span> <span class="n">fragmentcount</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
				<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
		<span class="c"># Bonnema (2003, p. 34)</span>
		<span class="n">bon</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="o">-</span><span class="n">nonterms</span> <span class="o">*</span> <span class="p">(</span><span class="n">freq</span> <span class="o">/</span> <span class="n">ntfd</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
		<span class="n">short</span> <span class="o">=</span> <span class="mf">0.5</span>
		<span class="k">return</span> <span class="n">freq</span><span class="p">,</span> <span class="n">ewe</span><span class="p">,</span> <span class="n">bon</span><span class="p">,</span> <span class="n">short</span>

	<span class="n">uniformweight</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">backtransform</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">ids</span> <span class="o">=</span> <span class="n">UniqueIDs</span><span class="p">()</span>
	<span class="c"># build index of the number of fragments extracted from a tree for ewe</span>
	<span class="n">fragmentcount</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">fragments</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
		<span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">indices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="n">fragmentcount</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+=</span> <span class="n">cnt</span>
	<span class="c"># ntfd: frequency of a non-terminal node in treebank</span>
	<span class="n">ntfd</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">label</span> <span class="k">for</span> <span class="n">tree</span> <span class="ow">in</span> <span class="n">trees</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">tree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">())</span>

	<span class="c"># binarize, turn into LCFRS productions</span>
	<span class="c"># use artificial markers of binarization as disambiguation,</span>
	<span class="c"># construct a mapping of productions to fragments</span>
	<span class="k">for</span> <span class="n">origfrag</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
		<span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span> <span class="o">=</span> <span class="n">origfrag</span>
		<span class="n">prods</span><span class="p">,</span> <span class="n">newfrag</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="n">binarized</span><span class="p">)</span>
		<span class="n">prod</span> <span class="o">=</span> <span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">:</span>  <span class="c"># lexical production</span>
			<span class="n">grammar</span><span class="p">[</span><span class="n">prod</span><span class="p">]</span> <span class="o">=</span> <span class="n">getweight</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">)</span>
			<span class="k">continue</span>

		<span class="c"># first binarized production gets prob. mass</span>
		<span class="n">grammar</span><span class="p">[</span><span class="n">prod</span><span class="p">]</span> <span class="o">=</span> <span class="n">getweight</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">)</span>
		<span class="n">grammar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">repeat</span><span class="p">(</span><span class="n">uniformweight</span><span class="p">)))</span>
		<span class="c"># &amp; becomes key in backtransform</span>
		<span class="n">backtransform</span><span class="p">[</span><span class="n">prod</span><span class="p">]</span> <span class="o">=</span> <span class="n">origfrag</span><span class="p">,</span> <span class="n">newfrag</span>
	<span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
		<span class="n">ids</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
		<span class="n">flatfrags</span> <span class="o">=</span> <span class="p">[</span><span class="n">flatten</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="p">{},</span> <span class="n">binarized</span><span class="p">)</span>
				<span class="k">for</span> <span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">]</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&quot;recurring fragments:&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">flatfrags</span><span class="p">,</span> <span class="n">fragments</span><span class="p">):</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&quot;fragment: </span><span class="si">%s</span><span class="se">\n</span><span class="s">prod:     </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;</span><span class="se">\n\t</span><span class="s">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
				<span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span> <span class="ow">in</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
			<span class="k">print</span><span class="p">(</span><span class="s">&quot;template: </span><span class="si">%s</span><span class="se">\n</span><span class="s">freq: </span><span class="si">%2d</span><span class="s">  sent: </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">fragments</span><span class="p">[</span><span class="n">b</span><span class="p">]),</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;_&#39;</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="bp">None</span>
					<span class="k">else</span> <span class="n">quotelabel</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&quot;backtransform:&quot;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">backtransform</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
			<span class="k">print</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">extrarules</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">extrarules</span><span class="p">:</span>
			<span class="n">x</span> <span class="o">=</span> <span class="n">extrarules</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span>
			<span class="n">a</span> <span class="o">=</span> <span class="n">b</span> <span class="o">=</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="k">if</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
				<span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">grammar</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span>
			<span class="n">grammar</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
	<span class="c"># fix order of grammar rules</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="n">sortgrammar</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
	<span class="c"># align fragments and backtransform with corresponding grammar rules</span>
	<span class="n">fragments</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">((</span><span class="n">frag</span><span class="p">,</span> <span class="n">fragments</span><span class="p">[</span><span class="n">frag</span><span class="p">])</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span>
			<span class="p">(</span><span class="n">backtransform</span><span class="p">[</span><span class="n">rule</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">grammar</span> <span class="k">if</span> <span class="n">rule</span> <span class="ow">in</span>
				<span class="n">backtransform</span><span class="p">))</span>
	<span class="n">backtransform</span> <span class="o">=</span> <span class="p">[</span><span class="n">backtransform</span><span class="p">[</span><span class="n">rule</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">grammar</span>
			<span class="k">if</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">backtransform</span><span class="p">]</span>
	<span class="c"># relative frequences as probabilities (don&#39;t normalize shortest &amp; bon)</span>
	<span class="n">ntsums</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="n">ntsumsewe</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ewe</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
		<span class="n">ntsums</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">freq</span>
		<span class="n">ntsumsewe</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">ewe</span>
	<span class="n">eweweights</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">ewe</span><span class="p">)</span> <span class="o">/</span> <span class="n">ntsumsewe</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
			<span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">ewe</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">]</span>
	<span class="n">bonweights</span> <span class="o">=</span> <span class="p">[</span><span class="n">bon</span> <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">bon</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">]</span>
	<span class="n">shortest</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">]</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="p">[(</span><span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">ntsums</span><span class="p">[</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>
			<span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span>
			<span class="n">ewe</span><span class="o">=</span><span class="n">eweweights</span><span class="p">,</span> <span class="n">bon</span><span class="o">=</span><span class="n">bonweights</span><span class="p">,</span> <span class="n">shortest</span><span class="o">=</span><span class="n">shortest</span><span class="p">),</span> <span class="n">fragments</span>

</div>
<div class="viewcode-block" id="compiletsg"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.compiletsg">[docs]</a><span class="k">def</span> <span class="nf">compiletsg</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Compile a set of weighted fragments (i.e., a TSG) into a grammar.</span>

<span class="sd">	Similar to dopgrammar(), only the values are weights instead of counts.</span>

<span class="sd">	:param fragments: a dictionary of fragments mapped to weights. The</span>
<span class="sd">		fragments may either consist of bracketed strings, or discontinuous</span>
<span class="sd">		bracketed strings as tuples of the form ``(frag, terminals)``.</span>
<span class="sd">	:param binarized: Whether the resulting grammar should be binarized.</span>
<span class="sd">	:returns: a ``(grammar, backtransform, altweights)`` tuple similar to what</span>
<span class="sd">		``doubledop()`` returns; altweights will be empty.&quot;&quot;&quot;</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">backtransform</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">ids</span> <span class="o">=</span> <span class="n">UniqueIDs</span><span class="p">()</span>
	<span class="k">for</span> <span class="n">frag</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">fragments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
			<span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span> <span class="o">=</span> <span class="n">frag</span>
		<span class="k">else</span><span class="p">:</span>  <span class="c"># convert to frag, terminal notation on the fly.</span>
			<span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span> <span class="o">=</span> <span class="n">termindices</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span>
		<span class="n">prods</span><span class="p">,</span> <span class="n">newfrag</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="n">binarized</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">:</span>  <span class="c"># lexical production</span>
			<span class="n">grammar</span><span class="p">[</span><span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">weight</span>
			<span class="k">continue</span>
		<span class="n">grammar</span><span class="p">[</span><span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">weight</span>
		<span class="n">grammar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
		<span class="n">backtransform</span><span class="p">[</span><span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">newfrag</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="n">sortgrammar</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
	<span class="n">backtransform</span> <span class="o">=</span> <span class="p">[</span><span class="n">backtransform</span><span class="p">[</span><span class="n">rule</span><span class="p">]</span> <span class="k">for</span> <span class="n">rule</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">grammar</span>
			<span class="k">if</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">backtransform</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="p">{}</span>

</div>
<div class="viewcode-block" id="sortgrammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.sortgrammar">[docs]</a><span class="k">def</span> <span class="nf">sortgrammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">altweights</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Sort grammar productions in three clusters: phrasal, binarized, lexical.</span>

<span class="sd">	1. normal phrasal rules, ordered by lhs symbol</span>
<span class="sd">	2. non-initial binarized 2dop rules (to align the 2dop backtransform with</span>
<span class="sd">		the rules in cluster 1 which introduce a new fragment)</span>
<span class="sd">	3. lexical rules sorted by word&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">sortkey</span><span class="p">(</span><span class="n">rule</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Sort key ``(word or &#39;&#39;, 2dop binarized rule?, lhs)``.&quot;&quot;&quot;</span>
		<span class="p">(</span><span class="n">nts</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">_p</span> <span class="o">=</span> <span class="n">rule</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">yf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">nts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span> <span class="k">else</span> <span class="s">&#39;&#39;</span>
		<span class="k">return</span> <span class="n">word</span><span class="p">,</span> <span class="s">&#39;}&lt;&#39;</span> <span class="ow">in</span> <span class="n">nts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

	<span class="k">if</span> <span class="n">altweights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">sortkey</span><span class="p">)</span>

	<span class="n">idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">n</span><span class="p">:</span> <span class="n">sortkey</span><span class="p">(</span><span class="n">grammar</span><span class="p">[</span><span class="n">n</span><span class="p">]))</span>
	<span class="n">altweights</span> <span class="o">=</span> <span class="p">{</span><span class="n">name</span><span class="p">:</span> <span class="p">[</span><span class="n">weights</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">weights</span> <span class="ow">in</span> <span class="n">altweights</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="p">[</span><span class="n">grammar</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">grammar</span><span class="p">,</span> <span class="n">altweights</span>

</div>
<div class="viewcode-block" id="flatten"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.flatten">[docs]</a><span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="n">binarized</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Auxiliary function for Double-DOP.</span>

<span class="sd">	Remove internal nodes from a tree and read off the (binarized)</span>
<span class="sd">	productions of the resulting flattened tree. Aside from returning</span>
<span class="sd">	productions, also return tree with lexical and frontier nodes replaced by a</span>
<span class="sd">	templating symbol &#39;{n}&#39; where n is an index.</span>
<span class="sd">	Input is a tree and sentence, as well as an iterator which yields</span>
<span class="sd">	unique IDs for non-terminals introdudced by the binarization;</span>
<span class="sd">	output is a tuple (prods, frag). Trees are in the form of strings.</span>

<span class="sd">	&gt;&gt;&gt; ids = UniqueIDs()</span>
<span class="sd">	&gt;&gt;&gt; sent = [None, &#39;,&#39;, None, &#39;.&#39;]</span>
<span class="sd">	&gt;&gt;&gt; tree = &quot;(ROOT (S_2 0 2) (ROOT|&lt;$,&gt;_2 ($, 1) ($. 3)))&quot;</span>
<span class="sd">	&gt;&gt;&gt; prods, template = flatten(tree, sent, ids, {}, True)</span>
<span class="sd">	&gt;&gt;&gt; print(&#39;\\n&#39;.join(printrule(r, yf) for r, yf in prods))</span>
<span class="sd">	... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">	01	ROOT =&gt; ROOT}&lt;0&gt; $.@.</span>
<span class="sd">	010	ROOT}&lt;0&gt; =&gt; S_2 $,@,</span>
<span class="sd">	,	$,@, =&gt; Epsilon</span>
<span class="sd">	.	$.@. =&gt; Epsilon</span>
<span class="sd">	&gt;&gt;&gt; print(template)</span>
<span class="sd">	(ROOT {0} (ROOT|&lt;$,&gt;_2 {1} {2}))</span>
<span class="sd">	&gt;&gt;&gt; prods, template = flatten(tree, sent, ids, {}, False)</span>
<span class="sd">	&gt;&gt;&gt; print(&#39;\\n&#39;.join(printrule(r, yf) for r, yf in prods))</span>
<span class="sd">	... # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">	0102	ROOT =&gt; S_2 $,@, $.@.</span>
<span class="sd">	,	$,@, =&gt; Epsilon</span>
<span class="sd">	.	$.@. =&gt; Epsilon</span>
<span class="sd">	&gt;&gt;&gt; print(template)</span>
<span class="sd">	(ROOT {0} (ROOT|&lt;$,&gt;_2 {1} {2}))&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">factorconstituent</span><span class="p">,</span> <span class="n">addbitsets</span>

	<span class="k">def</span> <span class="nf">repl</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Add information to a frontier or terminal node.</span>

<span class="sd">		:frontiers: ``(label indices)``</span>
<span class="sd">		:terminals: ``(tag@word idx)``&quot;&quot;&quot;</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c"># index w/leading space</span>
		<span class="n">nn</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">sent</span><span class="p">[</span><span class="n">nn</span><span class="p">]</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>  <span class="c"># (label indices)</span>
		<span class="n">word</span> <span class="o">=</span> <span class="n">quotelabel</span><span class="p">(</span><span class="n">sent</span><span class="p">[</span><span class="n">nn</span><span class="p">])</span>
		<span class="c"># (tag@word idx)</span>
		<span class="k">return</span> <span class="s">&quot;(</span><span class="si">%s</span><span class="s">@</span><span class="si">%s%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">word</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">tree</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">return</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">addbitsets</span><span class="p">(</span><span class="n">tree</span><span class="p">),</span> <span class="n">sent</span><span class="p">),</span> <span class="n">tree</span>
	<span class="c"># give terminals unique POS tags</span>
	<span class="n">prod</span> <span class="o">=</span> <span class="n">FRONTIERORTERM</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">repl</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>
	<span class="c"># remove internal nodes, reorder</span>
	<span class="n">prod</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prod</span><span class="p">[:</span><span class="n">prod</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)],</span>
			<span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">FRONTIERORTERM</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">prod</span><span class="p">),</span>
			<span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))))</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">addbitsets</span><span class="p">(</span><span class="n">prod</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">binarized</span><span class="p">:</span>
		<span class="n">tmp</span> <span class="o">=</span> <span class="n">factorconstituent</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="s">&quot;}&quot;</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">,</span> <span class="n">markfanout</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
				<span class="n">markyf</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
	<span class="n">prods</span> <span class="o">=</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sent</span><span class="p">)</span>
	<span class="c"># remember original order of frontiers / terminals for template</span>
	<span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span> <span class="s">&quot;{</span><span class="si">%d</span><span class="s">}&quot;</span> <span class="o">%</span> <span class="n">n</span>
			<span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">FRONTIERORTERM</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">prod</span><span class="p">))}</span>
	<span class="c"># mark substitution sites and ensure string.</span>
	<span class="n">newtree</span> <span class="o">=</span> <span class="n">FRONTIERORTERM</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">order</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)],</span> <span class="n">tree</span><span class="p">)</span>
	<span class="n">prod</span> <span class="o">=</span> <span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">backtransform</span><span class="p">:</span>
		<span class="c"># normally, rules of fragments are disambiguated by binarization IDs.</span>
		<span class="c"># In case there&#39;s a fragment with only one or two frontier nodes,</span>
		<span class="c"># we add an artficial node.</span>
		<span class="n">newlabel</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%s</span><span class="s">}&lt;</span><span class="si">%s</span><span class="s">&gt;</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">next</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span>
				<span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="s">&#39;_</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
		<span class="n">prod1</span> <span class="o">=</span> <span class="p">((</span><span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">newlabel</span><span class="p">)</span> <span class="o">+</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">:],</span> <span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="c"># we have to determine fanout of the first nonterminal</span>
		<span class="c"># on the right hand side</span>
		<span class="n">prod2</span> <span class="o">=</span> <span class="p">((</span><span class="n">newlabel</span><span class="p">,</span> <span class="n">prod</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]),</span>
			<span class="nb">tuple</span><span class="p">((</span><span class="mi">0</span><span class="p">,)</span> <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">prod</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
			<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">component</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">prods</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">prod1</span><span class="p">,</span> <span class="n">prod2</span><span class="p">]</span>
	<span class="k">return</span> <span class="n">prods</span><span class="p">,</span> <span class="n">newtree</span>

</div>
<div class="viewcode-block" id="nodefreq"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.nodefreq">[docs]</a><span class="k">def</span> <span class="nf">nodefreq</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dectree</span><span class="p">,</span> <span class="n">subtreefd</span><span class="p">,</span> <span class="n">nonterminalfd</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Auxiliary function for DOP reduction.</span>

<span class="sd">	Counts frequencies of nodes and calculate the number of</span>
<span class="sd">	subtrees headed by each node. updates ``subtreefd`` and ``nonterminalfd``</span>
<span class="sd">	as a side effect. Expects a normal tree and a tree with IDs.</span>

<span class="sd">	:param subtreefd: the Counter to store the counts of subtrees</span>
<span class="sd">	:param nonterminalfd: the Counter to store the counts of non-terminals</span>

<span class="sd">	&gt;&gt;&gt; fd = Counter()</span>
<span class="sd">	&gt;&gt;&gt; d = TreeDecorator()</span>
<span class="sd">	&gt;&gt;&gt; tree = Tree(&quot;(S (NP 0) (VP 1))&quot;)</span>
<span class="sd">	&gt;&gt;&gt; dectree = d.decorate(tree, [&#39;mary&#39;, &#39;walks&#39;])</span>
<span class="sd">	&gt;&gt;&gt; nodefreq(tree, dectree, fd, Counter())</span>
<span class="sd">	4</span>
<span class="sd">	&gt;&gt;&gt; fd == Counter({&#39;S&#39;: 4, &#39;NP&#39;: 1, &#39;VP&#39;: 1, &#39;NP@1-0&#39;: 1, &#39;VP@1-1&#39;: 1})</span>
<span class="sd">	True&quot;&quot;&quot;</span>
	<span class="n">nonterminalfd</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="n">nonterminalfd</span><span class="p">[</span><span class="n">dectree</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
	<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Tree</span><span class="p">):</span>
		<span class="n">n</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mul</span><span class="p">,</span> <span class="p">(</span><span class="n">nodefreq</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ux</span><span class="p">,</span> <span class="n">subtreefd</span><span class="p">,</span> <span class="n">nonterminalfd</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
			<span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">ux</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dectree</span><span class="p">)))</span>
	<span class="k">else</span><span class="p">:</span>  <span class="c"># lexical production</span>
		<span class="n">n</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="n">subtreefd</span><span class="p">[</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">+=</span> <span class="n">n</span>
	<span class="c"># only add counts when dectree.label is actually an interior node,</span>
	<span class="c"># e.g., root node receives no ID so shouldn&#39;t be counted twice</span>
	<span class="k">if</span> <span class="n">dectree</span><span class="o">.</span><span class="n">label</span> <span class="o">!=</span> <span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>  <span class="c"># if subtreefd[dectree.label] == 0:</span>
		<span class="c"># NB: assignment, not addition; addressed nodes should be unique, and</span>
		<span class="c"># with packed graph encoding we don&#39;t want duplicate counts.</span>
		<span class="n">subtreefd</span><span class="p">[</span><span class="n">dectree</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
	<span class="k">return</span> <span class="n">n</span>

</div>
<div class="viewcode-block" id="TreeDecorator"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.TreeDecorator">[docs]</a><span class="k">class</span> <span class="nc">TreeDecorator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Auxiliary class for DOP reduction.</span>

<span class="sd">	Adds unique identifiers to each internal non-terminal of a tree.</span>

<span class="sd">	:param memoize: if ``True``, identifiers will be reused for equivalent</span>
<span class="sd">		subtrees (including all terminals).</span>
<span class="sd">	:param n: the initial sentence number.</span>
<span class="sd">	&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memoize</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>  <span class="c"># sentence number</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ids</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># node number</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">memoize</span> <span class="o">=</span> <span class="n">memoize</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">packedgraphs</span> <span class="o">=</span> <span class="p">{}</span>

<div class="viewcode-block" id="TreeDecorator.decorate"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.TreeDecorator.decorate">[docs]</a>	<span class="k">def</span> <span class="nf">decorate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Return a copy of tree with labels decorated with IDs.</span>

<span class="sd">		&gt;&gt;&gt; d = TreeDecorator()</span>
<span class="sd">		&gt;&gt;&gt; tree = Tree(&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;)</span>
<span class="sd">		&gt;&gt;&gt; print(d.decorate(tree, [&#39;the&#39;, &#39;dog&#39;, &#39;walks&#39;]))</span>
<span class="sd">		(S (NP@1-0 (DT@1-1 0) (N@1-2 1)) (VP@1-3 2))</span>
<span class="sd">		&gt;&gt;&gt; d = TreeDecorator(memoize=True)</span>
<span class="sd">		&gt;&gt;&gt; print(d.decorate(Tree(&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;),</span>
<span class="sd">		...		[&#39;the&#39;, &#39;dog&#39;, &#39;walks&#39;]))</span>
<span class="sd">		(S (NP@1-1 (DT@1-2 0) (N@1-3 1)) (VP@1-4 2))</span>
<span class="sd">		&gt;&gt;&gt; print(d.decorate(Tree(&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;),</span>
<span class="sd">		...		[&#39;the&#39;, &#39;dog&#39;, &#39;barks&#39;]))</span>
<span class="sd">		(S (NP@1-1 (DT@1-2 0) (N@1-3 1)) (VP@2-4 2))&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">memoize</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">ids</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="c"># wrap tree to get equality wrt sent</span>
			<span class="n">tree</span> <span class="o">=</span> <span class="n">DiscTree</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">freeze</span><span class="p">(),</span> <span class="n">sent</span><span class="p">)</span>
			<span class="n">dectree</span> <span class="o">=</span> <span class="n">ImmutableTree</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="nb">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_recdecorate</span><span class="p">,</span> <span class="n">tree</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">dectree</span> <span class="o">=</span> <span class="n">Tree</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">True</span><span class="p">))</span>
			<span class="c"># skip top node, should not get an ID</span>
			<span class="k">for</span> <span class="n">m</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">dectree</span><span class="o">.</span><span class="n">subtrees</span><span class="p">(),</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">)):</span>
				<span class="n">a</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">@</span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">dectree</span>
</div>
	<span class="k">def</span> <span class="nf">_recdecorate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Traverse subtrees not yet seen.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">tree</span>
		<span class="k">elif</span> <span class="n">tree</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">packedgraphs</span><span class="p">:</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">ids</span> <span class="o">+=</span> <span class="mi">1</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">packedgraphs</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span> <span class="o">=</span> <span class="n">ImmutableTree</span><span class="p">((</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">@</span><span class="si">%d</span><span class="s">-</span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="n">tree</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ids</span><span class="p">)),</span>
					<span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_recdecorate</span><span class="p">(</span><span class="n">child</span><span class="p">)</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">])</span>
			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">packedgraphs</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>
		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copyexceptindices</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">packedgraphs</span><span class="p">[</span><span class="n">tree</span><span class="p">])</span>

	<span class="k">def</span> <span class="nf">_copyexceptindices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Copy the nonterminals from tree2, but take indices from tree1.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="n">Tree</span><span class="p">):</span>
			<span class="k">return</span> <span class="n">tree1</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ids</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">ImmutableTree</span><span class="p">(</span><span class="n">tree2</span><span class="o">.</span><span class="n">label</span><span class="p">,</span>
			<span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copyexceptindices</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tree1</span><span class="p">,</span> <span class="n">tree2</span><span class="p">)])</span>

</div>
<div class="viewcode-block" id="quotelabel"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.quotelabel">[docs]</a><span class="k">def</span> <span class="nf">quotelabel</span><span class="p">(</span><span class="n">label</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Escapes two things: parentheses and non-ascii characters.</span>

<span class="sd">	Parentheses are replaced by square brackets. Also escapes non-ascii</span>
<span class="sd">	characters, so that phrasal labels can remain ascii-only.&quot;&quot;&quot;</span>
	<span class="n">newlabel</span> <span class="o">=</span> <span class="n">label</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;(&#39;</span><span class="p">,</span> <span class="s">&#39;[&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;)&#39;</span><span class="p">,</span> <span class="s">&#39;]&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">newlabel</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;unicode-escape&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="UniqueIDs"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.UniqueIDs">[docs]</a><span class="k">class</span> <span class="nc">UniqueIDs</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Produce strings with numeric IDs.</span>

<span class="sd">	Can be used as iterator (IDs will never be re-used) and dictionary (IDs</span>
<span class="sd">	will be re-used for same key).</span>

<span class="sd">	&gt;&gt;&gt; ids = UniqueIDs()</span>
<span class="sd">	&gt;&gt;&gt; print(next(ids))</span>
<span class="sd">	0</span>
<span class="sd">	&gt;&gt;&gt; print(ids[&#39;foo&#39;], ids[&#39;bar&#39;], ids[&#39;foo&#39;])</span>
<span class="sd">	1 2 1&quot;&quot;&quot;</span>
	<span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># next available ID</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">ids</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c"># IDs for labels seen</span>

	<span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
		<span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ids</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ids</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cnt</span>
			<span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="n">val</span>

	<span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="k">return</span> <span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

	<span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
		<span class="k">return</span> <span class="bp">self</span>

	<span class="nb">next</span> <span class="o">=</span> <span class="n">__next__</span>

</div>
<div class="viewcode-block" id="rangeheads"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.rangeheads">[docs]</a><span class="k">def</span> <span class="nf">rangeheads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Return first element of each range in a sorted sequence of numbers.</span>

<span class="sd">	&gt;&gt;&gt; rangeheads( (0, 1, 3, 4, 6) )</span>
<span class="sd">	[0, 3, 6]&quot;&quot;&quot;</span>
	<span class="n">sset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
	<span class="k">return</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">if</span> <span class="n">a</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sset</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="ranges"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.ranges">[docs]</a><span class="k">def</span> <span class="nf">ranges</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Partition s into a sequence of lists corresponding to contiguous ranges.</span>

<span class="sd">	&gt;&gt;&gt; list(ranges( (0, 1, 3, 4, 6) ))</span>
<span class="sd">	[[0, 1], [3, 4], [6]]&quot;&quot;&quot;</span>
	<span class="n">rng</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">rng</span> <span class="ow">or</span> <span class="n">a</span> <span class="o">==</span> <span class="n">rng</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
			<span class="n">rng</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="k">yield</span> <span class="n">rng</span>
			<span class="n">rng</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
	<span class="k">if</span> <span class="n">rng</span><span class="p">:</span>
		<span class="k">yield</span> <span class="n">rng</span>

</div>
<div class="viewcode-block" id="defaultparse"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.defaultparse">[docs]</a><span class="k">def</span> <span class="nf">defaultparse</span><span class="p">(</span><span class="n">wordstags</span><span class="p">,</span> <span class="n">rightbranching</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;A default parse to generate when parsing fails.</span>

<span class="sd">	:param rightbranching:</span>
<span class="sd">		when True, return a right branching tree with NPs,</span>
<span class="sd">		otherwise return all words under a single constituent &#39;NOPARSE&#39;.</span>

<span class="sd">	&gt;&gt;&gt; print(defaultparse([(&#39;like&#39;,&#39;X&#39;), (&#39;this&#39;,&#39;X&#39;), (&#39;example&#39;, &#39;NN&#39;),</span>
<span class="sd">	... (&#39;here&#39;,&#39;X&#39;)]))</span>
<span class="sd">	(NOPARSE (X like) (X this) (NN example) (X here))</span>
<span class="sd">	&gt;&gt;&gt; print(defaultparse([(&#39;like&#39;,&#39;X&#39;), (&#39;this&#39;,&#39;X&#39;), (&#39;example&#39;, &#39;NN&#39;),</span>
<span class="sd">	... (&#39;here&#39;,&#39;X&#39;)], True))</span>
<span class="sd">	(NP (X like) (NP (X this) (NP (NN example) (NP (X here)))))&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">rightbranching</span><span class="p">:</span>
		<span class="k">if</span> <span class="n">wordstags</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
			<span class="k">return</span> <span class="s">&quot;(NP (</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">) </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">wordstags</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
					<span class="n">wordstags</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">defaultparse</span><span class="p">(</span><span class="n">wordstags</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">rightbranching</span><span class="p">))</span>
		<span class="k">return</span> <span class="s">&quot;(NP (</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">))&quot;</span> <span class="o">%</span> <span class="n">wordstags</span><span class="p">[</span><span class="mi">0</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="s">&quot;(NOPARSE </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&quot;(</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">a</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">wordstags</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="printrule"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.printrule">[docs]</a><span class="k">def</span> <span class="nf">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;:returns: a string representation of a rule.&quot;&quot;&quot;</span>
	<span class="n">yfstr</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">yf</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="s"> =&gt; </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span>
			<span class="p">(</span><span class="s">&#39;</span><span class="si">%g</span><span class="s">/</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">w</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="k">else</span> <span class="n">w</span><span class="p">,</span>
			<span class="n">yfstr</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

</div>
<div class="viewcode-block" id="cartpi"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.cartpi">[docs]</a><span class="k">def</span> <span class="nf">cartpi</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;The cartesian product of a sequence of iterables.</span>

<span class="sd">	itertools.product doesn&#39;t support infinite sequences!</span>

<span class="sd">	&gt;&gt;&gt; list(islice(cartpi([count(), count(0)]), 9))</span>
<span class="sd">	[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)]&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="n">seq</span><span class="p">:</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="p">)</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">cartpi</span><span class="p">(</span><span class="n">seq</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">return</span> <span class="p">((),</span> <span class="p">)</span>

</div>
<div class="viewcode-block" id="write_lcfrs_grammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.write_lcfrs_grammar">[docs]</a><span class="k">def</span> <span class="nf">write_lcfrs_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">bitpar</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Write a grammar in a simple text file format.</span>

<span class="sd">	Rules are written in the order as they appear in the sequence `grammar`,</span>
<span class="sd">	except that the lexicon file lists words in sorted order (with tags for</span>
<span class="sd">	each word in the order of `grammar`). For a description of the file format,</span>
<span class="sd">	see ``docs/fileformats.rst``.</span>

<span class="sd">	:param grammar:  a sequence of rule tuples, as produced by</span>
<span class="sd">		``treebankgrammar()``, ``dopreduction()``, or ``doubledop()``.</span>
<span class="sd">	:param bitpar: when ``True``, use bitpar format: for rules, put weight</span>
<span class="sd">		first and leave out the yield function.</span>
<span class="sd">	:returns: tuple of strings``(rules, lexicon)``</span>

<span class="sd">	Weights are written in the following format:</span>

<span class="sd">	- if ``bitpar`` is ``False``, write rational fractions; e.g., ``2/3``.</span>
<span class="sd">	- if ``bitpar`` is ``True``, write frequencies (e.g., ``2``)</span>
<span class="sd">		if probabilities sum to 1, i.e., in that case probabilities can be</span>
<span class="sd">		re-computed as relative frequencies. Otherwise, resort to floating</span>
<span class="sd">		point numbers (e.g., ``0.666``, imprecise).&quot;&quot;&quot;</span>
	<span class="n">rules</span><span class="p">,</span> <span class="n">lexicon</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
	<span class="n">lexical</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
	<span class="n">freqs</span> <span class="o">=</span> <span class="n">bitpar</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
			<span class="k">if</span> <span class="n">freqs</span><span class="p">:</span>
				<span class="n">w</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
			<span class="k">else</span><span class="p">:</span>
				<span class="n">w1</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">w</span>
				<span class="k">if</span> <span class="n">bitpar</span><span class="p">:</span>
					<span class="n">w</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w1</span> <span class="o">/</span> <span class="n">w2</span><span class="p">)</span>  <span class="c"># .hex()</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="n">w</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">/</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w1</span><span class="p">,</span> <span class="n">w2</span><span class="p">)</span>
		<span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">hex</span><span class="p">()</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">:</span>
			<span class="n">lexical</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">yf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">w</span><span class="p">))</span>
			<span class="k">continue</span>
		<span class="k">elif</span> <span class="n">bitpar</span><span class="p">:</span>
			<span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r</span><span class="p">))))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">yfstr</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">a</span><span class="p">))</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">yf</span><span class="p">)</span>
			<span class="n">rules</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">r</span><span class="p">),</span> <span class="n">yfstr</span><span class="p">,</span> <span class="n">w</span><span class="p">)))</span>
	<span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">lexical</span><span class="p">:</span>
		<span class="n">lexicon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">lexical</span><span class="p">[</span><span class="n">word</span><span class="p">]:</span>
			<span class="n">lexicon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">tag</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
		<span class="n">lexicon</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
	<span class="k">return</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rules</span><span class="p">),</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lexicon</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="write_lncky_grammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.write_lncky_grammar">[docs]</a><span class="k">def</span> <span class="nf">write_lncky_grammar</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">lexicon</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf-8&#39;</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Convert a bitpar grammar to the format of Mark Jonhson&#39;s cky parser.&quot;&quot;&quot;</span>
	<span class="n">grammar</span> <span class="o">=</span> <span class="p">[]</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">):</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">p</span><span class="p">,</span> <span class="n">rule</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">grammar</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rule</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span>
	<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">lexicon</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">):</span>
		<span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="n">word</span><span class="p">,</span> <span class="n">tags</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
		<span class="n">tags</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">tags</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">tags</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">])</span>
		<span class="n">grammar</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s"> --&gt; </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">word</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">)</span>
	<span class="k">assert</span> <span class="s">&#39;VROOT&#39;</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
	<span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">)</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="subsetgrammar"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.subsetgrammar">[docs]</a><span class="k">def</span> <span class="nf">subsetgrammar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Test whether grammar a is a subset of b.&quot;&quot;&quot;</span>
	<span class="n">difference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">a</span><span class="p">))</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">b</span><span class="p">))</span>
	<span class="k">if</span> <span class="ow">not</span> <span class="n">difference</span><span class="p">:</span>
		<span class="k">return</span> <span class="bp">True</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&quot;missing productions:&quot;</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span> <span class="ow">in</span> <span class="n">difference</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
	<span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="grammarinfo"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.grammarinfo">[docs]</a><span class="k">def</span> <span class="nf">grammarinfo</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">dump</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Print some statistics on a grammar, before it goes through Grammar().</span>

<span class="sd">	:param dump: if given a filename, will dump distribution of parsing</span>
<span class="sd">		complexity to a file (i.e., p.c. 3 occurs 234 times, 4 occurs 120</span>
<span class="sd">		times, etc.)&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">discodop.eval</span> <span class="kn">import</span> <span class="n">mean</span>
	<span class="n">lhs</span> <span class="o">=</span> <span class="p">{</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">}</span>
	<span class="n">l</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">=</span> <span class="s">&quot;labels: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">({</span><span class="n">rule</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span>
							<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">})</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; of which preterminals: </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
		<span class="nb">len</span><span class="p">({</span><span class="n">rule</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span> <span class="k">if</span> <span class="n">rule</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">})</span>
		<span class="ow">or</span> <span class="nb">len</span><span class="p">({</span><span class="n">rule</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span>
				<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">rule</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lhs</span><span class="p">}))</span>
	<span class="n">ll</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span> <span class="k">if</span> <span class="n">rule</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;clauses: </span><span class="si">%d</span><span class="s">  lexical clauses: </span><span class="si">%d</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ll</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; non-lexical clauses: </span><span class="si">%d</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">ll</span><span class="p">)</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">yf</span><span class="p">),</span> <span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;max fan-out: </span><span class="si">%d</span><span class="s"> in &quot;</span> <span class="o">%</span> <span class="n">n</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; average: </span><span class="si">%g</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mean</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">_</span><span class="p">,</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">])</span>
	<span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">yf</span><span class="p">)),</span> <span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span> <span class="k">if</span> <span class="n">rule</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;Epsilon&#39;</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;max variables: </span><span class="si">%d</span><span class="s"> in </span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

	<span class="k">def</span> <span class="nf">parsingcomplexity</span><span class="p">(</span><span class="n">yf</span><span class="p">):</span>
		<span class="sd">&quot;&quot;&quot;Sum the fanouts of LHS &amp; RHS.&quot;&quot;&quot;</span>
		<span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">yf</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
			<span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">yf</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span>  <span class="c"># NB: a lexical production has complexity 1</span>

	<span class="n">pc</span> <span class="o">=</span> <span class="p">{(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">):</span> <span class="n">parsingcomplexity</span><span class="p">(</span><span class="n">yf</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">yf</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">grammar</span><span class="p">}</span>
	<span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pc</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">pc</span><span class="o">.</span><span class="n">get</span><span class="p">)</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;max parsing complexity: </span><span class="si">%d</span><span class="s"> in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
			<span class="n">pc</span><span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">],</span> <span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
	<span class="n">result</span> <span class="o">+=</span> <span class="s">&quot; average </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">mean</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
	<span class="k">if</span> <span class="n">dump</span><span class="p">:</span>
		<span class="n">pcdist</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">pc</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">dump</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
			<span class="n">out</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%d</span><span class="se">\t</span><span class="si">%d</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pcdist</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
	<span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="grammarstats"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.grammarstats">[docs]</a><span class="k">def</span> <span class="nf">grammarstats</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Print statistics for PLCFRS/bitpar grammar (sorted by LHS).&quot;&quot;&quot;</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;LHS</span><span class="se">\t</span><span class="s"># rules</span><span class="se">\t</span><span class="s">freq. mass&#39;</span><span class="p">)</span>
	<span class="n">label</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getreader</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">)((</span><span class="n">gzip</span><span class="o">.</span><span class="n">open</span> <span class="k">if</span> <span class="n">filename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.gz&#39;</span><span class="p">)</span>
			<span class="k">else</span> <span class="nb">open</span><span class="p">)(</span><span class="n">filename</span><span class="p">)):</span>
		<span class="n">match</span> <span class="o">=</span> <span class="n">RULERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;LHS1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;LHS2&#39;</span><span class="p">))</span> <span class="o">!=</span> <span class="n">label</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%d</span><span class="se">\t</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span>
			<span class="n">cnt</span> <span class="o">=</span> <span class="n">freq</span> <span class="o">=</span> <span class="mi">0</span>
			<span class="n">label</span> <span class="o">=</span> <span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;LHS1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;LHS2&#39;</span><span class="p">))</span>
		<span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
		<span class="n">freq</span> <span class="o">+=</span> <span class="nb">float</span><span class="p">((</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;FREQ1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;FREQ2&#39;</span><span class="p">)))</span>
	<span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%d</span><span class="se">\t</span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span>

</div>
<div class="viewcode-block" id="splitweight"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.splitweight">[docs]</a><span class="k">def</span> <span class="nf">splitweight</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Convert a weight / fraction in a string to a float / tuple.</span>

<span class="sd">	&gt;&gt;&gt; [splitweight(a) for a in (&#39;0.5&#39;, &#39;0x1.0000000000000p-1&#39;, &#39;1/2&#39;)]</span>
<span class="sd">	[0.5, 0.5, (1.0, 2.0)]&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="s">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">weight</span><span class="p">:</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
	<span class="k">elif</span> <span class="n">weight</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;0x&#39;</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="convertweight"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.convertweight">[docs]</a><span class="k">def</span> <span class="nf">convertweight</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Convert a weight in a string to a float.</span>

<span class="sd">	&gt;&gt;&gt; [convertweight(a) for a in (&#39;0.5&#39;, &#39;0x1.0000000000000p-1&#39;, &#39;1/2&#39;)]</span>
<span class="sd">	[0.5, 0.5, 0.5]&quot;&quot;&quot;</span>
	<span class="k">if</span> <span class="s">&#39;/&#39;</span> <span class="ow">in</span> <span class="n">weight</span><span class="p">:</span>
		<span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">weight</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">weight</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;0x&#39;</span><span class="p">):</span>
		<span class="k">return</span> <span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
	<span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="stripweight"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.stripweight">[docs]</a><span class="k">def</span> <span class="nf">stripweight</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Extract rule without weight.&quot;&quot;&quot;</span>
	<span class="n">match</span> <span class="o">=</span> <span class="n">RULERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
	<span class="k">if</span> <span class="n">match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Malformed rule:</span><span class="se">\n</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE2&#39;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="sumrules"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.sumrules">[docs]</a><span class="k">def</span> <span class="nf">sumrules</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Given a sorted iterable of rules, sum weights of identical rules.&quot;&quot;&quot;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="n">w1</span> <span class="o">=</span> <span class="mf">0.0</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">match</span> <span class="o">=</span> <span class="n">RULERE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
		<span class="n">rule</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE2&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">rule</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE1&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
					<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%g</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
				<span class="k">else</span><span class="p">:</span>
					<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%g</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">rule</span>
			<span class="n">w1</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE1&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
			<span class="n">w1</span> <span class="o">+=</span> <span class="n">convertweight</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;FREQ2&#39;</span><span class="p">))</span>
		<span class="k">else</span><span class="p">:</span>
			<span class="n">w1</span> <span class="o">+=</span> <span class="n">convertweight</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;WEIGHT1&#39;</span><span class="p">))</span>
	<span class="k">if</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;RULE1&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%g</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">,</span> <span class="n">rule</span><span class="p">)</span>
	<span class="k">else</span><span class="p">:</span>
		<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%g</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="sumlex"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.sumlex">[docs]</a><span class="k">def</span> <span class="nf">sumlex</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Given a sorted lexicon iterable, sum weights of word/tag pairs.&quot;&quot;&quot;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="n">tags</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">word</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">rest</span> <span class="o">=</span> <span class="n">rest</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">word</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">tags</span><span class="p">:</span>
				<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
						<span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">word</span>
			<span class="n">tags</span> <span class="o">=</span> <span class="p">{}</span>
		<span class="k">for</span> <span class="n">tag</span><span class="p">,</span> <span class="n">w2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">rest</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">rest</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]):</span>
			<span class="k">if</span> <span class="n">tag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">tags</span><span class="p">:</span>
				<span class="n">tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
			<span class="n">tags</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">+=</span> <span class="n">convertweight</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">tags</span><span class="p">:</span>
		<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
				<span class="s">&#39;</span><span class="si">%s</span><span class="s"> </span><span class="si">%g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">w1</span> <span class="ow">in</span> <span class="n">tags</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

</div>
<div class="viewcode-block" id="sumfrags"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.sumfrags">[docs]</a><span class="k">def</span> <span class="nf">sumfrags</span><span class="p">(</span><span class="n">iterable</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Sum weights for runs of identical fragments.&quot;&quot;&quot;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
	<span class="n">w1</span> <span class="o">=</span> <span class="mf">0.0</span>
	<span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
		<span class="n">frag</span><span class="p">,</span> <span class="n">w2</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">frag</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">:</span>
			<span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
				<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%g</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">frag</span>
			<span class="n">w1</span> <span class="o">=</span> <span class="mf">0.0</span>
		<span class="n">w1</span> <span class="o">+=</span> <span class="n">convertweight</span><span class="p">(</span><span class="n">w2</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
		<span class="k">yield</span> <span class="s">&#39;</span><span class="si">%s</span><span class="se">\t</span><span class="si">%g</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">w1</span> <span class="o">/</span> <span class="n">n</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="merge"><a class="viewcode-back" href="../../api/discodop.grammar.html#discodop.grammar.merge">[docs]</a><span class="k">def</span> <span class="nf">merge</span><span class="p">(</span><span class="n">filenames</span><span class="p">,</span> <span class="n">outfilename</span><span class="p">,</span> <span class="n">sumfunc</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
	<span class="sd">&quot;&quot;&quot;Interpolate weights of given files.&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">discodop</span> <span class="kn">import</span> <span class="n">plcfrs</span>
	<span class="n">openfiles</span> <span class="o">=</span> <span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">openread</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span> <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">]</span>
	<span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">)((</span><span class="n">gzip</span><span class="o">.</span><span class="n">open</span> <span class="k">if</span> <span class="n">outfilename</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;.gz&#39;</span><span class="p">)</span>
			<span class="k">else</span> <span class="nb">open</span><span class="p">)(</span><span class="n">outfilename</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
		<span class="n">out</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="n">sumfunc</span><span class="p">(</span>
				<span class="n">plcfrs</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="o">*</span><span class="n">openfiles</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">openfiles</span><span class="p">)))</span>

</div>
<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
	<span class="sd">&quot;&quot;&quot;Command line interface to create grammars from treebanks.&quot;&quot;&quot;</span>
	<span class="kn">from</span> <span class="nn">getopt</span> <span class="kn">import</span> <span class="n">gnu_getopt</span><span class="p">,</span> <span class="n">GetoptError</span>
	<span class="kn">from</span> <span class="nn">discodop.treetransforms</span> <span class="kn">import</span> <span class="n">addfanoutmarkers</span><span class="p">,</span> <span class="n">canonicalize</span>
	<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s">&#39;</span><span class="si">%(message)s</span><span class="s">&#39;</span><span class="p">)</span>
	<span class="n">shortoptions</span> <span class="o">=</span> <span class="s">&#39;hs:&#39;</span>
	<span class="n">options</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;help&#39;</span><span class="p">,</span> <span class="s">&#39;gzip&#39;</span><span class="p">,</span> <span class="s">&#39;packed&#39;</span><span class="p">,</span> <span class="s">&#39;bitpar&#39;</span><span class="p">,</span> <span class="s">&#39;inputfmt=&#39;</span><span class="p">,</span> <span class="s">&#39;inputenc=&#39;</span><span class="p">,</span>
			<span class="s">&#39;dopestimator=&#39;</span><span class="p">,</span> <span class="s">&#39;numproc=&#39;</span><span class="p">)</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="n">opts</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">gnu_getopt</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">shortoptions</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
		<span class="n">model</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;info&#39;</span><span class="p">,</span> <span class="s">&#39;merge&#39;</span><span class="p">):</span>
			<span class="n">treebankfile</span><span class="p">,</span> <span class="n">grammarfile</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
	<span class="k">except</span> <span class="p">(</span><span class="n">GetoptError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;error: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">err</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="n">SHORTUSAGE</span><span class="p">)</span>
		<span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="n">opts</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">opts</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;pcfg&#39;</span><span class="p">,</span> <span class="s">&#39;plcfrs&#39;</span><span class="p">,</span> <span class="s">&#39;dopreduction&#39;</span><span class="p">,</span> <span class="s">&#39;doubledop&#39;</span><span class="p">,</span> <span class="s">&#39;ptsg&#39;</span><span class="p">,</span>
			<span class="s">&#39;param&#39;</span><span class="p">,</span> <span class="s">&#39;info&#39;</span><span class="p">,</span> <span class="s">&#39;merge&#39;</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;unrecognized model: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">model</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;dopestimator&#39;</span><span class="p">,</span> <span class="s">&#39;rfe&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;rfe&#39;</span><span class="p">,</span> <span class="s">&#39;ewe&#39;</span><span class="p">,</span> <span class="s">&#39;shortest&#39;</span><span class="p">):</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;unrecognized estimator: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">opts</span><span class="p">[</span><span class="s">&#39;dopestimator&#39;</span><span class="p">])</span>

	<span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;info&#39;</span><span class="p">:</span>
		<span class="n">grammarstats</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;merge&#39;</span><span class="p">:</span>
		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;need at least 2 input and 1 output arguments.&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;rules&#39;</span><span class="p">:</span>
			<span class="n">merge</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sumrules</span><span class="p">,</span> <span class="n">stripweight</span><span class="p">)</span>
		<span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;lexicon&#39;</span><span class="p">:</span>
			<span class="n">merge</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sumlex</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">elif</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;fragments&#39;</span><span class="p">:</span>
			<span class="n">merge</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">args</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">sumfrags</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
		<span class="k">return</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;param&#39;</span><span class="p">:</span>
		<span class="kn">import</span> <span class="nn">os</span>
		<span class="kn">from</span> <span class="nn">discodop.runexp</span> <span class="kn">import</span> <span class="n">readparam</span><span class="p">,</span> <span class="n">loadtraincorpus</span><span class="p">,</span> <span class="n">getposmodel</span>
		<span class="k">if</span> <span class="n">opts</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;all options should be set in parameter file.&#39;</span><span class="p">)</span>
		<span class="n">prm</span> <span class="o">=</span> <span class="n">readparam</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">resultdir</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
		<span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">resultdir</span><span class="p">):</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Directory </span><span class="si">%r</span><span class="s"> already exists.</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">resultdir</span><span class="p">)</span>
		<span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">resultdir</span><span class="p">)</span>
		<span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">train_tagged_sents</span> <span class="o">=</span> <span class="n">loadtraincorpus</span><span class="p">(</span>
				<span class="n">prm</span><span class="o">.</span><span class="n">corpusfmt</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">traincorpus</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">binarization</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">punct</span><span class="p">,</span>
				<span class="n">prm</span><span class="o">.</span><span class="n">functions</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">morphology</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">removeempty</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">ensureroot</span><span class="p">,</span>
				<span class="n">prm</span><span class="o">.</span><span class="n">transformations</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">relationalrealizational</span><span class="p">)</span>
		<span class="n">simplelexsmooth</span> <span class="o">=</span> <span class="bp">False</span>
		<span class="k">if</span> <span class="n">prm</span><span class="o">.</span><span class="n">postagging</span> <span class="ow">and</span> <span class="n">prm</span><span class="o">.</span><span class="n">postagging</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s">&#39;unknownword&#39;</span><span class="p">:</span>
			<span class="n">sents</span><span class="p">,</span> <span class="n">lexmodel</span> <span class="o">=</span> <span class="n">getposmodel</span><span class="p">(</span><span class="n">prm</span><span class="o">.</span><span class="n">postagging</span><span class="p">,</span> <span class="n">train_tagged_sents</span><span class="p">)</span>
			<span class="n">simplelexsmooth</span> <span class="o">=</span> <span class="n">prm</span><span class="o">.</span><span class="n">postagging</span><span class="o">.</span><span class="n">simplelexsmooth</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;ptsg&#39;</span><span class="p">:</span>  <span class="c"># read fragments</span>
		<span class="n">splittedlines</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\t</span><span class="s">&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">openread</span><span class="p">(</span><span class="n">treebankfile</span><span class="p">,</span>
					<span class="n">encoding</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--inputenc&#39;</span><span class="p">,</span> <span class="s">&#39;utf8&#39;</span><span class="p">)))</span>
		<span class="n">fragments</span> <span class="o">=</span> <span class="p">{(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fields</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="k">else</span>
				<span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span> <span class="ow">or</span> <span class="bp">None</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">)])):</span>
					<span class="n">splitweight</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">fields</span> <span class="ow">in</span> <span class="n">splittedlines</span><span class="p">}</span>
	<span class="k">else</span><span class="p">:</span>  <span class="c"># read treebank</span>
		<span class="n">corpus</span> <span class="o">=</span> <span class="n">READERS</span><span class="p">[</span><span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--inputfmt&#39;</span><span class="p">,</span> <span class="s">&#39;export&#39;</span><span class="p">)](</span>
				<span class="n">treebankfile</span><span class="p">,</span>
				<span class="n">encoding</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--inputenc&#39;</span><span class="p">,</span> <span class="s">&#39;utf8&#39;</span><span class="p">))</span>
		<span class="n">trees</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">trees</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="n">sents</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">sents</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
		<span class="k">if</span> <span class="ow">not</span> <span class="n">trees</span><span class="p">:</span>
			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;no trees; is --inputfmt correct?&#39;</span><span class="p">)</span>
		<span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">trees</span><span class="p">:</span>
			<span class="n">canonicalize</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
			<span class="n">addfanoutmarkers</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

	<span class="c"># read off grammar</span>
	<span class="k">if</span> <span class="n">model</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;pcfg&#39;</span><span class="p">,</span> <span class="s">&#39;plcfrs&#39;</span><span class="p">):</span>
		<span class="n">grammar</span> <span class="o">=</span> <span class="n">treebankgrammar</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;dopreduction&#39;</span><span class="p">:</span>
		<span class="n">grammar</span><span class="p">,</span> <span class="n">altweights</span> <span class="o">=</span> <span class="n">dopreduction</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span>
				<span class="n">packedgraph</span><span class="o">=</span><span class="s">&#39;--packed&#39;</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;doubledop&#39;</span><span class="p">:</span>
		<span class="n">grammar</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="n">altweights</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">doubledop</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span>
				<span class="n">numproc</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--numproc&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
				<span class="n">binarized</span><span class="o">=</span><span class="s">&#39;--bitpar&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;ptsg&#39;</span><span class="p">:</span>
		<span class="n">grammar</span><span class="p">,</span> <span class="n">backtransform</span><span class="p">,</span> <span class="n">altweights</span> <span class="o">=</span> <span class="n">compiletsg</span><span class="p">(</span><span class="n">fragments</span><span class="p">,</span>
				<span class="n">binarized</span><span class="o">=</span><span class="s">&#39;--bitpar&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">)</span>
	<span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;param&#39;</span><span class="p">:</span>
		<span class="kn">from</span> <span class="nn">discodop.runexp</span> <span class="kn">import</span> <span class="n">dobinarization</span><span class="p">,</span> <span class="n">getgrammars</span>
		<span class="n">getgrammars</span><span class="p">(</span><span class="n">dobinarization</span><span class="p">(</span><span class="n">trees</span><span class="p">,</span> <span class="n">sents</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">binarization</span><span class="p">,</span>
				<span class="n">prm</span><span class="o">.</span><span class="n">relationalrealizational</span><span class="p">),</span>
				<span class="n">sents</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">stages</span><span class="p">,</span> <span class="n">prm</span><span class="o">.</span><span class="n">testcorpus</span><span class="o">.</span><span class="n">maxwords</span><span class="p">,</span> <span class="n">resultdir</span><span class="p">,</span>
				<span class="n">prm</span><span class="o">.</span><span class="n">numproc</span><span class="p">,</span> <span class="n">lexmodel</span><span class="p">,</span> <span class="n">simplelexsmooth</span><span class="p">,</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">)</span>
		<span class="n">paramfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">resultdir</span><span class="p">,</span> <span class="s">&#39;params.prm&#39;</span><span class="p">)</span>
		<span class="k">with</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">paramfile</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
			<span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;top=&#39;</span><span class="si">%s</span><span class="s">&#39;,</span><span class="se">\n</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span>
					<span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">encoding</span><span class="o">=</span><span class="s">&#39;utf8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read</span><span class="p">()))</span>
		<span class="k">return</span>  <span class="c"># grammars have already been written</span>
	<span class="k">if</span> <span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--dopestimator&#39;</span><span class="p">,</span> <span class="s">&#39;rfe&#39;</span><span class="p">)</span> <span class="o">!=</span> <span class="s">&#39;rfe&#39;</span><span class="p">:</span>
		<span class="n">grammar</span> <span class="o">=</span> <span class="p">[(</span><span class="n">rule</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="n">w</span> <span class="ow">in</span>
				<span class="nb">zip</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">altweights</span><span class="p">[</span><span class="n">opts</span><span class="p">[</span><span class="s">&#39;--dopestimator&#39;</span><span class="p">]])]</span>

	<span class="n">rulesname</span> <span class="o">=</span> <span class="n">grammarfile</span> <span class="o">+</span> <span class="s">&#39;.rules&#39;</span>
	<span class="n">lexiconname</span> <span class="o">=</span> <span class="n">grammarfile</span> <span class="o">+</span> <span class="s">&#39;.lex&#39;</span>
	<span class="n">myopen</span> <span class="o">=</span> <span class="nb">open</span>
	<span class="k">if</span> <span class="s">&#39;--gzip&#39;</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">:</span>
		<span class="n">myopen</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span>
		<span class="n">rulesname</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
		<span class="n">lexiconname</span> <span class="o">+=</span> <span class="s">&#39;.gz&#39;</span>
	<span class="n">bitpar</span> <span class="o">=</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;pcfg&#39;</span> <span class="ow">or</span> <span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;--inputfmt&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;bracket&#39;</span>
	<span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;ptsg&#39;</span><span class="p">:</span>
		<span class="n">bitpar</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">fragments</span><span class="p">)),</span> <span class="nb">tuple</span><span class="p">)</span>
	<span class="k">if</span> <span class="s">&#39;--bitpar&#39;</span> <span class="ow">in</span> <span class="n">opts</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">bitpar</span><span class="p">:</span>
		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;parsing with an unbinarized grammar requires &#39;</span>
				<span class="s">&#39;a grammar in bitpar format.&#39;</span><span class="p">)</span>

	<span class="n">rules</span><span class="p">,</span> <span class="n">lexicon</span> <span class="o">=</span> <span class="n">write_lcfrs_grammar</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">bitpar</span><span class="o">=</span><span class="n">bitpar</span><span class="p">)</span>
	<span class="c"># write output</span>
	<span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">)(</span><span class="n">myopen</span><span class="p">(</span><span class="n">rulesname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">rulesfile</span><span class="p">:</span>
		<span class="n">rulesfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">rules</span><span class="p">)</span>
	<span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">)(</span><span class="n">myopen</span><span class="p">(</span><span class="n">lexiconname</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">lexiconfile</span><span class="p">:</span>
		<span class="n">lexiconfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">lexicon</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">model</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;doubledop&#39;</span><span class="p">,</span> <span class="s">&#39;ptsg&#39;</span><span class="p">):</span>
		<span class="n">backtransformfile</span> <span class="o">=</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">.backtransform</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">grammarfile</span><span class="p">,</span>
			<span class="s">&#39;.gz&#39;</span> <span class="k">if</span> <span class="s">&#39;--gzip&#39;</span> <span class="ow">in</span> <span class="n">opts</span> <span class="k">else</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
		<span class="k">with</span> <span class="n">codecs</span><span class="o">.</span><span class="n">getwriter</span><span class="p">(</span><span class="s">&#39;utf8&#39;</span><span class="p">)(</span><span class="n">myopen</span><span class="p">(</span><span class="n">backtransformfile</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">))</span> <span class="k">as</span> <span class="n">bt</span><span class="p">:</span>
			<span class="n">bt</span><span class="o">.</span><span class="n">writelines</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">backtransform</span><span class="p">)</span>
		<span class="k">print</span><span class="p">(</span><span class="s">&#39;wrote backtransform to&#39;</span><span class="p">,</span> <span class="n">backtransformfile</span><span class="p">)</span>
	<span class="k">print</span><span class="p">(</span><span class="s">&#39;wrote grammar to </span><span class="si">%s</span><span class="s"> and </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">rulesname</span><span class="p">,</span> <span class="n">lexiconname</span><span class="p">))</span>
	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">:</span>  <span class="c"># this is very slow so skip with large grammars</span>
		<span class="k">print</span><span class="p">(</span><span class="n">grammarinfo</span><span class="p">(</span><span class="n">grammar</span><span class="p">))</span>
	<span class="k">try</span><span class="p">:</span>
		<span class="kn">from</span> <span class="nn">discodop.containers</span> <span class="kn">import</span> <span class="n">Grammar</span>
		<span class="k">print</span><span class="p">(</span><span class="n">Grammar</span><span class="p">(</span><span class="n">rules</span><span class="p">,</span> <span class="n">lexicon</span><span class="p">,</span> <span class="n">binarized</span><span class="o">=</span><span class="s">&#39;--bitpar&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">opts</span><span class="p">,</span>
				<span class="n">start</span><span class="o">=</span><span class="n">opts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;-s&#39;</span><span class="p">,</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">grammar</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
				<span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s">&#39;ptsg&#39;</span> <span class="k">else</span> <span class="n">trees</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">label</span><span class="p">))</span><span class="o">.</span><span class="n">testgrammar</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">except</span> <span class="p">(</span><span class="ne">ImportError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
		<span class="k">print</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;lcfrsproductions&#39;</span><span class="p">,</span> <span class="s">&#39;treebankgrammar&#39;</span><span class="p">,</span> <span class="s">&#39;dopreduction&#39;</span><span class="p">,</span> <span class="s">&#39;doubledop&#39;</span><span class="p">,</span>
		<span class="s">&#39;dop1&#39;</span><span class="p">,</span> <span class="s">&#39;dopgrammar&#39;</span><span class="p">,</span> <span class="s">&#39;compiletsg&#39;</span><span class="p">,</span> <span class="s">&#39;sortgrammar&#39;</span><span class="p">,</span> <span class="s">&#39;flatten&#39;</span><span class="p">,</span>
		<span class="s">&#39;nodefreq&#39;</span><span class="p">,</span> <span class="s">&#39;TreeDecorator&#39;</span><span class="p">,</span> <span class="s">&#39;DiscTree&#39;</span><span class="p">,</span> <span class="s">&#39;quotelabel&#39;</span><span class="p">,</span> <span class="s">&#39;UniqueIDs&#39;</span><span class="p">,</span>
		<span class="s">&#39;rangeheads&#39;</span><span class="p">,</span> <span class="s">&#39;ranges&#39;</span><span class="p">,</span> <span class="s">&#39;defaultparse&#39;</span><span class="p">,</span> <span class="s">&#39;printrule&#39;</span><span class="p">,</span> <span class="s">&#39;cartpi&#39;</span><span class="p">,</span>
		<span class="s">&#39;write_lcfrs_grammar&#39;</span><span class="p">,</span> <span class="s">&#39;write_lncky_grammar&#39;</span><span class="p">,</span> <span class="s">&#39;subsetgrammar&#39;</span><span class="p">,</span>
		<span class="s">&#39;grammarinfo&#39;</span><span class="p">,</span> <span class="s">&#39;grammarstats&#39;</span><span class="p">,</span> <span class="s">&#39;splitweight&#39;</span><span class="p">,</span> <span class="s">&#39;convertweight&#39;</span><span class="p">,</span>
		<span class="s">&#39;stripweight&#39;</span><span class="p">,</span> <span class="s">&#39;sumrules&#39;</span><span class="p">,</span> <span class="s">&#39;sumlex&#39;</span><span class="p">,</span> <span class="s">&#39;sumfrags&#39;</span><span class="p">,</span> <span class="s">&#39;merge&#39;</span><span class="p">]</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
	<span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../../index.html">Table Of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html#overview">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ref.html">Reference</a></li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="../../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>