<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>discodop.grammar &mdash; Disco-DOP 0.5pre1 documentation</title>
    
    <link rel="stylesheet" href="../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.5pre1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="Disco-DOP 0.5pre1 documentation" href="../index.html" />
    <link rel="up" title="API documentation" href="../api.html" />
    <link rel="next" title="discodop.heads" href="discodop.heads.html" />
    <link rel="prev" title="discodop.gen" href="discodop.gen.html" /> 
  </head>
  <body role="document">
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="discodop.heads.html" title="discodop.heads"
             accesskey="N">next</a></li>
        <li class="right" >
          <a href="discodop.gen.html" title="discodop.gen"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../ref.html" >Reference</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../api.html" accesskey="U">API documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="module-discodop.grammar">
<span id="discodop-grammar"></span><h1>discodop.grammar<a class="headerlink" href="#module-discodop.grammar" title="Permalink to this headline">Â¶</a></h1>
<p>Assorted functions to read off grammars from treebanks.</p>
<p class="rubric">Functions</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.lcfrsproductions" title="discodop.grammar.lcfrsproductions"><code class="xref py py-obj docutils literal"><span class="pre">lcfrsproductions</span></code></a>(tree,&nbsp;sent[,&nbsp;frontiers])</td>
<td>Read off LCFRS productions from a tree with indices and a sentence.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.treebankgrammar" title="discodop.grammar.treebankgrammar"><code class="xref py py-obj docutils literal"><span class="pre">treebankgrammar</span></code></a>(trees,&nbsp;sents[,&nbsp;extrarules])</td>
<td>Induce a probabilistic LCFRS with relative frequencies of productions.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.dopreduction" title="discodop.grammar.dopreduction"><code class="xref py py-obj docutils literal"><span class="pre">dopreduction</span></code></a>(trees,&nbsp;sents[,&nbsp;packedgraph,&nbsp;...])</td>
<td>Induce a reduction of DOP to an LCFRS.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.doubledop" title="discodop.grammar.doubledop"><code class="xref py py-obj docutils literal"><span class="pre">doubledop</span></code></a>(trees,&nbsp;sents[,&nbsp;debug,&nbsp;binarized,&nbsp;...])</td>
<td>Extract a Double-DOP grammar from a treebank.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.dop1" title="discodop.grammar.dop1"><code class="xref py py-obj docutils literal"><span class="pre">dop1</span></code></a>(trees,&nbsp;sents[,&nbsp;maxdepth,&nbsp;maxfrontier,&nbsp;...])</td>
<td>Return an all-fragments DOP1 model with relative frequencies.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.dopgrammar" title="discodop.grammar.dopgrammar"><code class="xref py py-obj docutils literal"><span class="pre">dopgrammar</span></code></a>(trees,&nbsp;fragments[,&nbsp;binarized,&nbsp;...])</td>
<td>Create a DOP grammar from a set of fragments and occurrences.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.compiletsg" title="discodop.grammar.compiletsg"><code class="xref py py-obj docutils literal"><span class="pre">compiletsg</span></code></a>(fragments[,&nbsp;binarized])</td>
<td>Compile a set of weighted fragments (i.e., a TSG) into a grammar.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.sortgrammar" title="discodop.grammar.sortgrammar"><code class="xref py py-obj docutils literal"><span class="pre">sortgrammar</span></code></a>(grammar[,&nbsp;altweights])</td>
<td>Sort grammar productions in three clusters: phrasal, binarized, lexical.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.flatten" title="discodop.grammar.flatten"><code class="xref py py-obj docutils literal"><span class="pre">flatten</span></code></a>(tree,&nbsp;sent,&nbsp;ids,&nbsp;backtransform,&nbsp;...)</td>
<td>Auxiliary function for Double-DOP.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.nodefreq" title="discodop.grammar.nodefreq"><code class="xref py py-obj docutils literal"><span class="pre">nodefreq</span></code></a>(tree,&nbsp;dectree,&nbsp;subtreefd,&nbsp;nonterminalfd)</td>
<td>Auxiliary function for DOP reduction.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.quotelabel" title="discodop.grammar.quotelabel"><code class="xref py py-obj docutils literal"><span class="pre">quotelabel</span></code></a>(label)</td>
<td>Escapes two things: parentheses and non-ascii characters.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.rangeheads" title="discodop.grammar.rangeheads"><code class="xref py py-obj docutils literal"><span class="pre">rangeheads</span></code></a>(s)</td>
<td>Return first element of each range in a sorted sequence of numbers.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.ranges" title="discodop.grammar.ranges"><code class="xref py py-obj docutils literal"><span class="pre">ranges</span></code></a>(s)</td>
<td>Partition s into a sequence of lists corresponding to contiguous ranges.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.defaultparse" title="discodop.grammar.defaultparse"><code class="xref py py-obj docutils literal"><span class="pre">defaultparse</span></code></a>(wordstags[,&nbsp;rightbranching])</td>
<td>A default parse to generate when parsing fails.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.printrule" title="discodop.grammar.printrule"><code class="xref py py-obj docutils literal"><span class="pre">printrule</span></code></a>(r,&nbsp;yf[,&nbsp;w])</td>
<td><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">returns:</th><td class="field-body">a string representation of a rule.</td>
</tr>
</tbody>
</table>
</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.cartpi" title="discodop.grammar.cartpi"><code class="xref py py-obj docutils literal"><span class="pre">cartpi</span></code></a>(seq)</td>
<td>The cartesian product of a sequence of iterables.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.write_lcfrs_grammar" title="discodop.grammar.write_lcfrs_grammar"><code class="xref py py-obj docutils literal"><span class="pre">write_lcfrs_grammar</span></code></a>(grammar[,&nbsp;bitpar])</td>
<td>Write a grammar in a simple text file format.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.write_lncky_grammar" title="discodop.grammar.write_lncky_grammar"><code class="xref py py-obj docutils literal"><span class="pre">write_lncky_grammar</span></code></a>(rules,&nbsp;lexicon,&nbsp;out[,&nbsp;...])</td>
<td>Convert a bitpar grammar to the format of Mark Jonhson&#8217;s cky parser.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.subsetgrammar" title="discodop.grammar.subsetgrammar"><code class="xref py py-obj docutils literal"><span class="pre">subsetgrammar</span></code></a>(a,&nbsp;b)</td>
<td>Test whether grammar a is a subset of b.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.grammarinfo" title="discodop.grammar.grammarinfo"><code class="xref py py-obj docutils literal"><span class="pre">grammarinfo</span></code></a>(grammar[,&nbsp;dump])</td>
<td>Print some statistics on a grammar, before it goes through Grammar().</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.grammarstats" title="discodop.grammar.grammarstats"><code class="xref py py-obj docutils literal"><span class="pre">grammarstats</span></code></a>(filename)</td>
<td>Print statistics for PLCFRS/bitpar grammar (sorted by LHS).</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.splitweight" title="discodop.grammar.splitweight"><code class="xref py py-obj docutils literal"><span class="pre">splitweight</span></code></a>(weight)</td>
<td>Convert a weight / fraction in a string to a float / tuple.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.convertweight" title="discodop.grammar.convertweight"><code class="xref py py-obj docutils literal"><span class="pre">convertweight</span></code></a>(weight)</td>
<td>Convert a weight in a string to a float.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.stripweight" title="discodop.grammar.stripweight"><code class="xref py py-obj docutils literal"><span class="pre">stripweight</span></code></a>(line)</td>
<td>Extract rule without weight.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.sumrules" title="discodop.grammar.sumrules"><code class="xref py py-obj docutils literal"><span class="pre">sumrules</span></code></a>(iterable,&nbsp;n)</td>
<td>Given a sorted iterable of rules, sum weights of identical rules.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.sumlex" title="discodop.grammar.sumlex"><code class="xref py py-obj docutils literal"><span class="pre">sumlex</span></code></a>(iterable,&nbsp;n)</td>
<td>Given a sorted lexicon iterable, sum weights of word/tag pairs.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.sumfrags" title="discodop.grammar.sumfrags"><code class="xref py py-obj docutils literal"><span class="pre">sumfrags</span></code></a>(iterable,&nbsp;n)</td>
<td>Sum weights for runs of identical fragments.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.merge" title="discodop.grammar.merge"><code class="xref py py-obj docutils literal"><span class="pre">merge</span></code></a>(filenames,&nbsp;outfilename,&nbsp;sumfunc,&nbsp;key)</td>
<td>Interpolate weights of given files.</td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#discodop.grammar.TreeDecorator" title="discodop.grammar.TreeDecorator"><code class="xref py py-obj docutils literal"><span class="pre">TreeDecorator</span></code></a>([memoize,&nbsp;n])</td>
<td>Auxiliary class for DOP reduction.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#discodop.grammar.UniqueIDs" title="discodop.grammar.UniqueIDs"><code class="xref py py-obj docutils literal"><span class="pre">UniqueIDs</span></code></a>()</td>
<td>Produce strings with numeric IDs.</td>
</tr>
</tbody>
</table>
<dl class="function">
<dt id="discodop.grammar.lcfrsproductions">
<code class="descclassname">discodop.grammar.</code><code class="descname">lcfrsproductions</code><span class="sig-paren">(</span><em>tree</em>, <em>sent</em>, <em>frontiers=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#lcfrsproductions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.lcfrsproductions" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Read off LCFRS productions from a tree with indices and a sentence.</p>
<p>Tree should contain integer indices as terminals, and a sentence with the
corresponding words for these indices. Always produces monotone LCFRS
rules. For best results, tree should be canonicalized. When <code class="docutils literal"><span class="pre">frontiers</span></code>
is <code class="docutils literal"><span class="pre">True</span></code>, frontier nodes will generate empty productions, by default
they are ignored.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(S (VP_2 (V 0) (ADJ 2)) (NP 1))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="s">&quot;is Mary happy&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span>  
<span class="gp">... </span>            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span> <span class="ow">in</span> <span class="n">lcfrsproductions</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">)))</span>
<span class="go">010     S =&gt; VP_2 NP</span>
<span class="go">0,1     VP_2 =&gt; V ADJ</span>
<span class="go">is      V =&gt; Epsilon</span>
<span class="go">happy   ADJ =&gt; Epsilon</span>
<span class="go">Mary    NP =&gt; Epsilon</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.treebankgrammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">treebankgrammar</code><span class="sig-paren">(</span><em>trees</em>, <em>sents</em>, <em>extrarules=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#treebankgrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.treebankgrammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Induce a probabilistic LCFRS with relative frequencies of productions.</p>
<p>When trees contain no discontinuities, the result is equivalent to a
treebank PCFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>extarules</strong> &#8211; A dictionary of productions that will be merged with the
grammar, with (pseudo)frequencies as values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.dopreduction">
<code class="descclassname">discodop.grammar.</code><code class="descname">dopreduction</code><span class="sig-paren">(</span><em>trees</em>, <em>sents</em>, <em>packedgraph=False</em>, <em>decorater=None</em>, <em>extrarules=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#dopreduction"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.dopreduction" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Induce a reduction of DOP to an LCFRS.</p>
<p>Similar to how Goodman (1996, 2003) reduces DOP to a PCFG.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>packedgraph</strong> &#8211; packed graph encoding (Bansal &amp; Klein 2010).</li>
<li><strong>decorator</strong> &#8211; a TreeDecorator instance (packedgraph is ignored if this
is passed) .</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a set of rules with the relative frequency estimate as
probilities, and a dictionary with alternate weights.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.doubledop">
<code class="descclassname">discodop.grammar.</code><code class="descname">doubledop</code><span class="sig-paren">(</span><em>trees</em>, <em>sents</em>, <em>debug=False</em>, <em>binarized=True</em>, <em>maxdepth=1</em>, <em>maxfrontier=999</em>, <em>complement=False</em>, <em>iterate=False</em>, <em>numproc=None</em>, <em>extrarules=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#doubledop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.doubledop" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Extract a Double-DOP grammar from a treebank.</p>
<p>That is, a fragment grammar containing fragments that occur at least twice,
plus all individual productions needed to obtain full coverage.
Input trees need to be binarized.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>binarized</strong> &#8211; Whether the resulting grammar should be binarized;
this may be False when bitpar is used which applies its own
binarization.</li>
<li><strong>maxdepth</strong> &#8211; add non-maximal/non-recurring fragments with depth
<cite>1 &lt; depth &lt; maxdepth</cite>.</li>
<li><strong>maxfrontier</strong> &#8211; limit number of frontier non-terminals; not yet
implemented.</li>
<li><strong>complement, numproc</strong> (<em>iterate,</em>) &#8211; cf. fragments.recurringfragments()</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (grammar, altweights, backtransform)
altweights is a dictionary containing alternate weights.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.dop1">
<code class="descclassname">discodop.grammar.</code><code class="descname">dop1</code><span class="sig-paren">(</span><em>trees</em>, <em>sents</em>, <em>maxdepth=4</em>, <em>maxfrontier=999</em>, <em>binarized=True</em>, <em>extrarules=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#dop1"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.dop1" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return an all-fragments DOP1 model with relative frequencies.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>maxdepth</strong> &#8211; restrict fragments to <cite>1 &lt; depth &lt; maxdepth</cite>.</li>
<li><strong>maxfrontier</strong> &#8211; limit number of frontier non-terminals; not yet
implemented.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.dopgrammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">dopgrammar</code><span class="sig-paren">(</span><em>trees</em>, <em>fragments</em>, <em>binarized=True</em>, <em>extrarules=None</em>, <em>debug=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#dopgrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.dopgrammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Create a DOP grammar from a set of fragments and occurrences.</p>
<p>A second level of binarization (a normal form) is needed when fragments are
converted to individual grammar rules, which occurs through the removal of
internal nodes. The binarization adds unique identifiers so that each
grammar rule can be mapped back to its fragment. In fragments with
terminals, we replace their POS tags with a tag uniquely identifying that
terminal and tag: <code class="docutils literal"><span class="pre">tag&#64;word</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragments</strong> &#8211; a dictionary of fragments from binarized trees, with
occurrences as values (a mapping of sentence number to counts).</li>
<li><strong>binarized</strong> &#8211; Whether the resulting grammar should be binarized;
this may be False when bitpar is used which applies its own
binarization.</li>
<li><strong>extrarules</strong> &#8211; Additional rules to add to the grammar.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a tuple (grammar, altweights, backtransform)
altweights is a dictionary containing alternate weights.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.compiletsg">
<code class="descclassname">discodop.grammar.</code><code class="descname">compiletsg</code><span class="sig-paren">(</span><em>fragments</em>, <em>binarized=True</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#compiletsg"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.compiletsg" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Compile a set of weighted fragments (i.e., a TSG) into a grammar.</p>
<p>Similar to dopgrammar(), only the values are weights instead of counts.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fragments</strong> &#8211; a dictionary of fragments mapped to weights. The
fragments may either consist of bracketed strings, or discontinuous
bracketed strings as tuples of the form <code class="docutils literal"><span class="pre">(frag,</span> <span class="pre">terminals)</span></code>.</li>
<li><strong>binarized</strong> &#8211; Whether the resulting grammar should be binarized.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a <code class="docutils literal"><span class="pre">(grammar,</span> <span class="pre">backtransform,</span> <span class="pre">altweights)</span></code> tuple similar to what
<code class="docutils literal"><span class="pre">doubledop()</span></code> returns; altweights will be empty.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.sortgrammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">sortgrammar</code><span class="sig-paren">(</span><em>grammar</em>, <em>altweights=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#sortgrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.sortgrammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sort grammar productions in three clusters: phrasal, binarized, lexical.</p>
<ol class="arabic">
<li><p class="first">normal phrasal rules, ordered by lhs symbol</p>
</li>
<li><dl class="first docutils">
<dt>non-initial binarized 2dop rules (to align the 2dop backtransform with</dt>
<dd><p class="first last">the rules in cluster 1 which introduce a new fragment)</p>
</dd>
</dl>
</li>
<li><p class="first">lexical rules sorted by word</p>
</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.flatten">
<code class="descclassname">discodop.grammar.</code><code class="descname">flatten</code><span class="sig-paren">(</span><em>tree</em>, <em>sent</em>, <em>ids</em>, <em>backtransform</em>, <em>binarized</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#flatten"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.flatten" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Auxiliary function for Double-DOP.</p>
<p>Remove internal nodes from a tree and read off the (binarized)
productions of the resulting flattened tree. Aside from returning
productions, also return tree with lexical and frontier nodes replaced by a
templating symbol &#8216;{n}&#8217; where n is an index.
Input is a tree and sentence, as well as an iterator which yields
unique IDs for non-terminals introdudced by the binarization;
output is a tuple (prods, frag). Trees are in the form of strings.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ids</span> <span class="o">=</span> <span class="n">UniqueIDs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sent</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="s">&#39;,&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;.&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="s">&quot;(ROOT (S_2 0 2) (ROOT|&lt;$,&gt;_2 ($, 1) ($. 3)))&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prods</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="p">{},</span> <span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">))</span>
<span class="gp">... </span>
<span class="go">01      ROOT =&gt; ROOT}&lt;0&gt; $.@.</span>
<span class="go">010     ROOT}&lt;0&gt; =&gt; S_2 $,@,</span>
<span class="go">,       $,@, =&gt; Epsilon</span>
<span class="go">.       $.@. =&gt; Epsilon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="go">(ROOT {0} (ROOT|&lt;$,&gt;_2 {1} {2}))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">prods</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">flatten</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">sent</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="p">{},</span> <span class="bp">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">printrule</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">yf</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">yf</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">))</span>
<span class="gp">... </span>
<span class="go">0102    ROOT =&gt; S_2 $,@, $.@.</span>
<span class="go">,       $,@, =&gt; Epsilon</span>
<span class="go">.       $.@. =&gt; Epsilon</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>
<span class="go">(ROOT {0} (ROOT|&lt;$,&gt;_2 {1} {2}))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.nodefreq">
<code class="descclassname">discodop.grammar.</code><code class="descname">nodefreq</code><span class="sig-paren">(</span><em>tree</em>, <em>dectree</em>, <em>subtreefd</em>, <em>nonterminalfd</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#nodefreq"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.nodefreq" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Auxiliary function for DOP reduction.</p>
<p>Counts frequencies of nodes and calculate the number of
subtrees headed by each node. updates <code class="docutils literal"><span class="pre">subtreefd</span></code> and <code class="docutils literal"><span class="pre">nonterminalfd</span></code>
as a side effect. Expects a normal tree and a tree with IDs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>subtreefd</strong> &#8211; the Counter to store the counts of subtrees</li>
<li><strong>nonterminalfd</strong> &#8211; the Counter to store the counts of non-terminals</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">fd</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">TreeDecorator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&quot;(S (NP 0) (VP 1))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dectree</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;mary&#39;</span><span class="p">,</span> <span class="s">&#39;walks&#39;</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nodefreq</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">dectree</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="n">Counter</span><span class="p">())</span>
<span class="go">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fd</span> <span class="o">==</span> <span class="n">Counter</span><span class="p">({</span><span class="s">&#39;S&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s">&#39;NP&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;VP&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;NP@1-0&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;VP@1-1&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">})</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="class">
<dt id="discodop.grammar.TreeDecorator">
<em class="property">class </em><code class="descclassname">discodop.grammar.</code><code class="descname">TreeDecorator</code><span class="sig-paren">(</span><em>memoize=False</em>, <em>n=1</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#TreeDecorator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.TreeDecorator" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Auxiliary class for DOP reduction.</p>
<p>Adds unique identifiers to each internal non-terminal of a tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>memoize</strong> &#8211; if <code class="docutils literal"><span class="pre">True</span></code>, identifiers will be reused for equivalent
subtrees (including all terminals).</li>
<li><strong>n</strong> &#8211; the initial sentence number.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="discodop.grammar.TreeDecorator.decorate">
<code class="descname">decorate</code><span class="sig-paren">(</span><em>tree</em>, <em>sent</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#TreeDecorator.decorate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.TreeDecorator.decorate" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return a copy of tree with labels decorated with IDs.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">TreeDecorator</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tree</span> <span class="o">=</span> <span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;the&#39;</span><span class="p">,</span> <span class="s">&#39;dog&#39;</span><span class="p">,</span> <span class="s">&#39;walks&#39;</span><span class="p">]))</span>
<span class="go">(S (NP@1-0 (DT@1-1 0) (N@1-2 1)) (VP@1-3 2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">TreeDecorator</span><span class="p">(</span><span class="n">memoize</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">[</span><span class="s">&#39;the&#39;</span><span class="p">,</span> <span class="s">&#39;dog&#39;</span><span class="p">,</span> <span class="s">&#39;walks&#39;</span><span class="p">]))</span>
<span class="go">(S (NP@1-1 (DT@1-2 0) (N@1-3 1)) (VP@1-4 2))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">decorate</span><span class="p">(</span><span class="n">Tree</span><span class="p">(</span><span class="s">&#39;(S (NP (DT 0) (N 1)) (VP 2))&#39;</span><span class="p">),</span>
<span class="gp">... </span>            <span class="p">[</span><span class="s">&#39;the&#39;</span><span class="p">,</span> <span class="s">&#39;dog&#39;</span><span class="p">,</span> <span class="s">&#39;barks&#39;</span><span class="p">]))</span>
<span class="go">(S (NP@1-1 (DT@1-2 0) (N@1-3 1)) (VP@2-4 2))</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="discodop.grammar.DiscTree">
<em class="property">class </em><code class="descclassname">discodop.grammar.</code><code class="descname">DiscTree</code><span class="sig-paren">(</span><em>tree</em>, <em>sent</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/tree.html#DiscTree"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.DiscTree" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Wrap an immutable tree with indices as leaves and a sentence.</p>
<p>Provides hash &amp; equality.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.quotelabel">
<code class="descclassname">discodop.grammar.</code><code class="descname">quotelabel</code><span class="sig-paren">(</span><em>label</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#quotelabel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.quotelabel" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Escapes two things: parentheses and non-ascii characters.</p>
<p>Parentheses are replaced by square brackets. Also escapes non-ascii
characters, so that phrasal labels can remain ascii-only.</p>
</dd></dl>

<dl class="class">
<dt id="discodop.grammar.UniqueIDs">
<em class="property">class </em><code class="descclassname">discodop.grammar.</code><code class="descname">UniqueIDs</code><a class="reference internal" href="../_modules/discodop/grammar.html#UniqueIDs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.UniqueIDs" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Produce strings with numeric IDs.</p>
<p>Can be used as iterator (IDs will never be re-used) and dictionary (IDs
will be re-used for same key).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">ids</span> <span class="o">=</span> <span class="n">UniqueIDs</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">ids</span><span class="p">))</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">],</span> <span class="n">ids</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">],</span> <span class="n">ids</span><span class="p">[</span><span class="s">&#39;foo&#39;</span><span class="p">])</span>
<span class="go">1 2 1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.rangeheads">
<code class="descclassname">discodop.grammar.</code><code class="descname">rangeheads</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#rangeheads"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.rangeheads" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Return first element of each range in a sorted sequence of numbers.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">rangeheads</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="p">)</span>
<span class="go">[0, 3, 6]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.ranges">
<code class="descclassname">discodop.grammar.</code><code class="descname">ranges</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#ranges"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.ranges" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Partition s into a sequence of lists corresponding to contiguous ranges.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">ranges</span><span class="p">(</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span> <span class="p">))</span>
<span class="go">[[0, 1], [3, 4], [6]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.defaultparse">
<code class="descclassname">discodop.grammar.</code><code class="descname">defaultparse</code><span class="sig-paren">(</span><em>wordstags</em>, <em>rightbranching=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#defaultparse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.defaultparse" title="Permalink to this definition">Â¶</a></dt>
<dd><p>A default parse to generate when parsing fails.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>rightbranching</strong> &#8211; when True, return a right branching tree with NPs,
otherwise return all words under a single constituent &#8216;NOPARSE&#8217;.</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">defaultparse</span><span class="p">([(</span><span class="s">&#39;like&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;this&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;example&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s">&#39;here&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">)]))</span>
<span class="go">(NOPARSE (X like) (X this) (NN example) (X here))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span><span class="p">(</span><span class="n">defaultparse</span><span class="p">([(</span><span class="s">&#39;like&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;this&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;example&#39;</span><span class="p">,</span> <span class="s">&#39;NN&#39;</span><span class="p">),</span>
<span class="gp">... </span><span class="p">(</span><span class="s">&#39;here&#39;</span><span class="p">,</span><span class="s">&#39;X&#39;</span><span class="p">)],</span> <span class="bp">True</span><span class="p">))</span>
<span class="go">(NP (X like) (NP (X this) (NP (NN example) (NP (X here)))))</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.printrule">
<code class="descclassname">discodop.grammar.</code><code class="descname">printrule</code><span class="sig-paren">(</span><em>r</em>, <em>yf</em>, <em>w=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#printrule"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.printrule" title="Permalink to this definition">Â¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">a string representation of a rule.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.cartpi">
<code class="descclassname">discodop.grammar.</code><code class="descname">cartpi</code><span class="sig-paren">(</span><em>seq</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#cartpi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.cartpi" title="Permalink to this definition">Â¶</a></dt>
<dd><p>The cartesian product of a sequence of iterables.</p>
<p>itertools.product doesn&#8217;t support infinite sequences!</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">islice</span><span class="p">(</span><span class="n">cartpi</span><span class="p">([</span><span class="n">count</span><span class="p">(),</span> <span class="n">count</span><span class="p">(</span><span class="mi">0</span><span class="p">)]),</span> <span class="mi">9</span><span class="p">))</span>
<span class="go">[(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (0, 8)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.write_lcfrs_grammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">write_lcfrs_grammar</code><span class="sig-paren">(</span><em>grammar</em>, <em>bitpar=False</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#write_lcfrs_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.write_lcfrs_grammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Write a grammar in a simple text file format.</p>
<p>Rules are written in the order as they appear in the sequence <cite>grammar</cite>,
except that the lexicon file lists words in sorted order (with tags for
each word in the order of <cite>grammar</cite>). For a description of the file format,
see <code class="docutils literal"><span class="pre">docs/fileformats.rst</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grammar</strong> &#8211; a sequence of rule tuples, as produced by
<code class="docutils literal"><span class="pre">treebankgrammar()</span></code>, <code class="docutils literal"><span class="pre">dopreduction()</span></code>, or <code class="docutils literal"><span class="pre">doubledop()</span></code>.</li>
<li><strong>bitpar</strong> &#8211; when <code class="docutils literal"><span class="pre">True</span></code>, use bitpar format: for rules, put weight
first and leave out the yield function.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">tuple of strings``(rules, lexicon)``</p>
</td>
</tr>
</tbody>
</table>
<p>Weights are written in the following format:</p>
<ul>
<li><p class="first">if <code class="docutils literal"><span class="pre">bitpar</span></code> is <code class="docutils literal"><span class="pre">False</span></code>, write rational fractions; e.g., <code class="docutils literal"><span class="pre">2/3</span></code>.</p>
</li>
<li><dl class="first docutils">
<dt>if <code class="docutils literal"><span class="pre">bitpar</span></code> is <code class="docutils literal"><span class="pre">True</span></code>, write frequencies (e.g., <code class="docutils literal"><span class="pre">2</span></code>)</dt>
<dd><p class="first last">if probabilities sum to 1, i.e., in that case probabilities can be
re-computed as relative frequencies. Otherwise, resort to floating
point numbers (e.g., <code class="docutils literal"><span class="pre">0.666</span></code>, imprecise).</p>
</dd>
</dl>
</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.write_lncky_grammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">write_lncky_grammar</code><span class="sig-paren">(</span><em>rules</em>, <em>lexicon</em>, <em>out</em>, <em>encoding=u'utf-8'</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#write_lncky_grammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.write_lncky_grammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert a bitpar grammar to the format of Mark Jonhson&#8217;s cky parser.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.subsetgrammar">
<code class="descclassname">discodop.grammar.</code><code class="descname">subsetgrammar</code><span class="sig-paren">(</span><em>a</em>, <em>b</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#subsetgrammar"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.subsetgrammar" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Test whether grammar a is a subset of b.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.grammarinfo">
<code class="descclassname">discodop.grammar.</code><code class="descname">grammarinfo</code><span class="sig-paren">(</span><em>grammar</em>, <em>dump=None</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#grammarinfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.grammarinfo" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Print some statistics on a grammar, before it goes through Grammar().</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dump</strong> &#8211; if given a filename, will dump distribution of parsing
complexity to a file (i.e., p.c. 3 occurs 234 times, 4 occurs 120
times, etc.)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.grammarstats">
<code class="descclassname">discodop.grammar.</code><code class="descname">grammarstats</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#grammarstats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.grammarstats" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Print statistics for PLCFRS/bitpar grammar (sorted by LHS).</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.splitweight">
<code class="descclassname">discodop.grammar.</code><code class="descname">splitweight</code><span class="sig-paren">(</span><em>weight</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#splitweight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.splitweight" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert a weight / fraction in a string to a float / tuple.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">splitweight</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;0.5&#39;</span><span class="p">,</span> <span class="s">&#39;0x1.0000000000000p-1&#39;</span><span class="p">,</span> <span class="s">&#39;1/2&#39;</span><span class="p">)]</span>
<span class="go">[0.5, 0.5, (1.0, 2.0)]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.convertweight">
<code class="descclassname">discodop.grammar.</code><code class="descname">convertweight</code><span class="sig-paren">(</span><em>weight</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#convertweight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.convertweight" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Convert a weight in a string to a float.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">convertweight</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;0.5&#39;</span><span class="p">,</span> <span class="s">&#39;0x1.0000000000000p-1&#39;</span><span class="p">,</span> <span class="s">&#39;1/2&#39;</span><span class="p">)]</span>
<span class="go">[0.5, 0.5, 0.5]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.stripweight">
<code class="descclassname">discodop.grammar.</code><code class="descname">stripweight</code><span class="sig-paren">(</span><em>line</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#stripweight"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.stripweight" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Extract rule without weight.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.sumrules">
<code class="descclassname">discodop.grammar.</code><code class="descname">sumrules</code><span class="sig-paren">(</span><em>iterable</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#sumrules"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.sumrules" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given a sorted iterable of rules, sum weights of identical rules.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.sumlex">
<code class="descclassname">discodop.grammar.</code><code class="descname">sumlex</code><span class="sig-paren">(</span><em>iterable</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#sumlex"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.sumlex" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Given a sorted lexicon iterable, sum weights of word/tag pairs.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.sumfrags">
<code class="descclassname">discodop.grammar.</code><code class="descname">sumfrags</code><span class="sig-paren">(</span><em>iterable</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#sumfrags"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.sumfrags" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Sum weights for runs of identical fragments.</p>
</dd></dl>

<dl class="function">
<dt id="discodop.grammar.merge">
<code class="descclassname">discodop.grammar.</code><code class="descname">merge</code><span class="sig-paren">(</span><em>filenames</em>, <em>outfilename</em>, <em>sumfunc</em>, <em>key</em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/discodop/grammar.html#merge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#discodop.grammar.merge" title="Permalink to this definition">Â¶</a></dt>
<dd><p>Interpolate weights of given files.</p>
</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h3><a href="../index.html">Table Of Contents</a></h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../intro.html#overview">Overview</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../ref.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../discodop.html">Command line options</a></li>
<li class="toctree-l2"><a class="reference internal" href="../params.html">Parser parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../fileformats.html">File formats</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../api.html">API documentation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../api.html#indices-and-tables">Indices and tables</a></li>
</ul>
</li>
</ul>

<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="discodop.heads.html" title="discodop.heads"
             >next</a></li>
        <li class="right" >
          <a href="discodop.gen.html" title="discodop.gen"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Disco-DOP 0.5pre1 documentation</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="../ref.html" >Reference</a> &raquo;</li>
          <li class="nav-item nav-item-2"><a href="../api.html" >API documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, Andreas van Cranenburgh.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
  </body>
</html>